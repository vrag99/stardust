{"version":3,"sources":["../src/constants.ts","../src/types/api/index.ts","../src/types/api/jsonrpc/index.ts","../src/types/api/rpcspec_0_6/index.ts","../src/types/api/rpcspec_0_6/errors.ts","../src/types/api/rpcspec_0_6/components.ts","../src/types/api/rpcspec_0_6/nonspec.ts","../src/types/api/rpcspec_0_7/index.ts","../src/types/api/rpcspec_0_7/errors.ts","../src/types/api/rpcspec_0_7/components.ts","../src/types/api/rpcspec_0_7/nonspec.ts","../src/utils/encode.ts","../src/provider/errors.ts","../src/channel/rpc_0_6.ts","../src/types/index.ts","../src/types/account.ts","../src/types/calldata.ts","../src/types/lib/contract/index.ts","../src/types/lib/index.ts","../src/types/typedData.ts","../src/utils/assert.ts","../src/utils/num.ts","../src/utils/selector.ts","../src/utils/shortString.ts","../src/utils/calldata/byteArray.ts","../src/utils/calldata/cairo.ts","../src/utils/cairoDataTypes/felt.ts","../src/utils/cairoDataTypes/uint256.ts","../src/utils/calldata/enum/CairoCustomEnum.ts","../src/utils/calldata/enum/CairoOption.ts","../src/utils/calldata/enum/CairoResult.ts","../src/utils/calldata/formatter.ts","../src/utils/calldata/parser/parser-0-1.1.0.ts","../src/utils/calldata/parser/parser-2.0.0.ts","../src/utils/calldata/parser/index.ts","../src/utils/calldata/tuple.ts","../src/utils/calldata/propertyOrder.ts","../src/utils/calldata/requestParser.ts","../src/utils/calldata/responseParser.ts","../src/utils/calldata/validate.ts","../src/utils/calldata/index.ts","../src/utils/hash/index.ts","../src/utils/hash/transactionHash/v2.ts","../src/utils/ec.ts","../src/utils/hash/transactionHash/v3.ts","../src/utils/hash/transactionHash/index.ts","../src/utils/hash/classHash.ts","../src/utils/json.ts","../src/utils/stark.ts","../src/utils/contract.ts","../src/utils/fetchPonyfill.ts","../src/utils/provider.ts","../src/utils/transaction.ts","../src/channel/rpc_0_7.ts","../src/utils/responseParser/rpc.ts","../src/provider/rpc.ts","../src/provider/extensions/default.ts","../src/utils/starknetId.ts","../src/provider/extensions/starknetId.ts","../src/provider/interface.ts","../src/provider/index.ts","../src/signer/interface.ts","../src/utils/typedData.ts","../src/utils/merkle.ts","../src/signer/default.ts","../src/signer/ethSigner.ts","../src/utils/eth.ts","../src/utils/events.ts","../src/account/default.ts","../src/account/interface.ts","../src/utils/events/index.ts","../src/contract/default.ts","../src/contract/interface.ts","../src/contract/contractFactory.ts","../src/utils/uint256.ts","../src/utils/address.ts","../src/utils/url.ts","../src/index.ts"],"sourcesContent":["import { ETransactionVersion } from './types/api';\n\nexport { IS_BROWSER } from './utils/encode';\n\n/**\n * Cairo Felt support storing max 31 character\n */\nexport const TEXT_TO_FELT_MAX_LEN = 31;\n\n/**\n * Alternatively use directly from api specification\n * types.RPC.ETransactionVersion\n * For BN do BigInt(TRANSACTION_VERSION.*)\n */\nexport { ETransactionVersion as TRANSACTION_VERSION };\n\nexport const ZERO = 0n;\nexport const MASK_250 = 2n ** 250n - 1n; // 2 ** 250 - 1\nexport const API_VERSION = ZERO;\n\n// based on: https://github.com/starkware-libs/cairo-lang/blob/v0.12.3/src/starkware/starknet/common/storage.cairo#L3\nexport const MAX_STORAGE_ITEM_SIZE = 256n;\nexport const ADDR_BOUND = 2n ** 251n - MAX_STORAGE_ITEM_SIZE;\n\nexport enum BaseUrl {\n  SN_MAIN = 'https://alpha-mainnet.starknet.io',\n  SN_GOERLI = 'https://alpha4.starknet.io',\n  SN_SEPOLIA = 'https://alpha-sepolia.starknet.io',\n}\n\nexport enum NetworkName {\n  SN_MAIN = 'SN_MAIN',\n  SN_GOERLI = 'SN_GOERLI',\n  SN_SEPOLIA = 'SN_SEPOLIA',\n}\n\nexport enum StarknetChainId {\n  SN_MAIN = '0x534e5f4d41494e', // encodeShortString('SN_MAIN'),\n  SN_GOERLI = '0x534e5f474f45524c49', // encodeShortString('SN_GOERLI')\n  SN_SEPOLIA = '0x534e5f5345504f4c4941', // encodeShortString('SN_SEPOLIA')\n}\n\nexport enum TransactionHashPrefix {\n  DECLARE = '0x6465636c617265', // encodeShortString('declare'),\n  DEPLOY = '0x6465706c6f79', // encodeShortString('deploy'),\n  DEPLOY_ACCOUNT = '0x6465706c6f795f6163636f756e74', // encodeShortString('deploy_account'),\n  INVOKE = '0x696e766f6b65', // encodeShortString('invoke'),\n  L1_HANDLER = '0x6c315f68616e646c6572', // encodeShortString('l1_handler'),\n}\n\nexport const enum feeMarginPercentage {\n  L1_BOUND_MAX_AMOUNT = 50,\n  L1_BOUND_MAX_PRICE_PER_UNIT = 50,\n  MAX_FEE = 50,\n}\n\nexport const UDC = {\n  ADDRESS: '0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf',\n  ENTRYPOINT: 'deployContract',\n};\n\nexport const RPC_DEFAULT_VERSION = 'v0_6';\n\nexport const RPC_NODES = {\n  SN_GOERLI: [\n    `https://starknet-testnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/goerli-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n  SN_MAIN: [\n    `https://starknet-mainnet.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/mainnet-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n  SN_SEPOLIA: [\n    `https://starknet-sepolia.public.blastapi.io/rpc/${RPC_DEFAULT_VERSION}`,\n    `https://free-rpc.nethermind.io/sepolia-juno/${RPC_DEFAULT_VERSION}`,\n  ],\n};\n","export * as JRPC from './jsonrpc';\n\nexport * as RPCSPEC06 from './rpcspec_0_6';\nexport * as RPCSPEC07 from './rpcspec_0_7';\nexport * from './rpcspec_0_7';\n","export type RequestBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n  method: string;\n  params?: {};\n};\n\nexport type ResponseBody = {\n  id: number | string;\n  jsonrpc: '2.0';\n} & (SuccessResponseBody | ErrorResponseBody);\n\nexport type SuccessResponseBody = {\n  result: unknown;\n};\n\nexport type ErrorResponseBody = {\n  error: Error;\n};\n\nexport type Error = {\n  code: number;\n  message: string;\n  data?: unknown;\n};\n","/**\n * version 0.6.0\n */\n\nexport { Methods } from './methods';\nexport { ABI } from './contract';\nexport * as Errors from './errors';\nexport * as SPEC from './components';\nexport * from './nonspec';\n","export interface FAILED_TO_RECEIVE_TXN {\n  code: 1;\n  message: 'Failed to write transaction';\n}\n\nexport interface NO_TRACE_AVAILABLE {\n  code: 10;\n  message: 'No trace available for transaction';\n  data: {\n    status: 'RECEIVED' | 'REJECTED';\n  };\n}\n\nexport interface CONTRACT_NOT_FOUND {\n  code: 20;\n  message: 'Contract not found';\n}\n\nexport interface INVALID_MESSAGE_SELECTOR {\n  code: 21;\n  message: 'Invalid message selector';\n}\n\nexport interface INVALID_CALL_DATA {\n  code: 22;\n  message: 'Invalid call data';\n}\n\nexport interface BLOCK_NOT_FOUND {\n  code: 24;\n  message: 'Block not found';\n}\n\nexport interface INVALID_BLOCK_HASH {\n  code: 26;\n  message: 'Invalid block hash';\n}\n\nexport interface INVALID_TXN_INDEX {\n  code: 27;\n  message: 'Invalid transaction index in a block';\n}\n\nexport interface CLASS_HASH_NOT_FOUND {\n  code: 28;\n  message: 'Class hash not found';\n}\n\nexport interface TXN_HASH_NOT_FOUND {\n  code: 29;\n  message: 'Transaction hash not found';\n}\n\nexport interface PAGE_SIZE_TOO_BIG {\n  code: 31;\n  message: 'Requested page size is too big';\n}\n\nexport interface NO_BLOCKS {\n  code: 32;\n  message: 'There are no blocks';\n}\n\nexport interface INVALID_CONTINUATION_TOKEN {\n  code: 33;\n  message: 'The supplied continuation token is invalid or unknown';\n}\n\nexport interface TOO_MANY_KEYS_IN_FILTER {\n  code: 34;\n  message: 'Too many keys provided in a filter';\n}\n\nexport interface CONTRACT_ERROR {\n  code: 40;\n  message: 'Contract error';\n  data: {\n    revert_error: string;\n  };\n}\n\nexport interface TRANSACTION_EXECUTION_ERROR {\n  code: 41;\n  message: 'Transaction execution error';\n  data: {\n    transaction_index: number;\n    execution_error: string;\n  };\n}\n\nexport interface CLASS_ALREADY_DECLARED {\n  code: 51;\n  message: 'Class already declared';\n}\n\nexport interface INVALID_TRANSACTION_NONCE {\n  code: 52;\n  message: 'Invalid transaction nonce';\n}\n\nexport interface INSUFFICIENT_MAX_FEE {\n  code: 53;\n  message: 'Max fee is smaller than the minimal transaction cost (validation plus fee transfer)';\n}\n\nexport interface INSUFFICIENT_ACCOUNT_BALANCE {\n  code: 54;\n  message: \"Account balance is smaller than the transaction's max_fee\";\n}\n\nexport interface VALIDATION_FAILURE {\n  code: 55;\n  message: 'Account validation failed';\n  data: string;\n}\n\nexport interface COMPILATION_FAILED {\n  code: 56;\n  message: 'Compilation failed';\n}\n\nexport interface CONTRACT_CLASS_SIZE_IS_TOO_LARGE {\n  code: 57;\n  message: 'Contract class size it too large';\n}\n\nexport interface NON_ACCOUNT {\n  code: 58;\n  message: 'Sender address in not an account contract';\n}\n\nexport interface DUPLICATE_TX {\n  code: 59;\n  message: 'A transaction with the same hash already exists in the mempool';\n}\n\nexport interface COMPILED_CLASS_HASH_MISMATCH {\n  code: 60;\n  message: 'the compiled class hash did not match the one supplied in the transaction';\n}\n\nexport interface UNSUPPORTED_TX_VERSION {\n  code: 61;\n  message: 'the transaction version is not supported';\n}\n\nexport interface UNSUPPORTED_CONTRACT_CLASS_VERSION {\n  code: 62;\n  message: 'the contract class version is not supported';\n}\n\nexport interface UNEXPECTED_ERROR {\n  code: 63;\n  message: 'An unexpected error occurred';\n  data: string;\n}\n","/**\n * PRIMITIVES\n */\n\n/**\n * A field element. represented by at most 63 hex digits\n * @pattern ^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$\n */\nexport type FELT = string;\n/**\n * an ethereum address represented as 40 hex digits\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type ETH_ADDRESS = string;\n/**\n * A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.\n * @pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$\n */\nexport type STORAGE_KEY = string;\nexport type ADDRESS = FELT;\nexport type NUM_AS_HEX = string;\n/**\n * 64 bit integers, represented by hex string of length at most 16\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$\"\n */\nexport type u64 = string;\n/**\n * 64 bit integers, represented by hex string of length at most 32\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$\"\n */\nexport type u128 = string;\nexport type SIGNATURE = Array<FELT>;\nexport type BLOCK_NUMBER = number;\nexport type BLOCK_HASH = FELT;\nexport type TXN_HASH = FELT;\nexport type CHAIN_ID = NUM_AS_HEX;\nexport type STRUCT_ABI_TYPE = 'struct';\nexport type EVENT_ABI_TYPE = 'event';\nexport type FUNCTION_ABI_TYPE = 'function' | 'l1_handler' | 'constructor';\n// Represents the type of an entry point.\nexport type ENTRY_POINT_TYPE = 'EXTERNAL' | 'L1_HANDLER' | 'CONSTRUCTOR';\n// Represents the type of a function call.\nexport type CALL_TYPE = 'DELEGATE' | 'LIBRARY_CALL' | 'CALL';\n// Represents the status of the transaction\nexport type TXN_STATUS = 'RECEIVED' | 'REJECTED' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\n// Flags that indicate how to simulate a given transaction. By default, the sequencer behavior is replicated locally (enough funds are expected to be in the account, and the fee will be deducted from the balance before the simulation of the next transaction). To skip the fee charge, use the SKIP_FEE_CHARGE flag.\nexport type SIMULATION_FLAG = 'SKIP_VALIDATE' | 'SKIP_FEE_CHARGE';\n// Data availability mode\nexport type DA_MODE = 'L1' | 'L2';\nexport type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';\nexport type TXN_FINALITY_STATUS = 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\nexport type TXN_EXECUTION_STATUS = 'SUCCEEDED' | 'REVERTED';\nexport type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';\nexport type BLOCK_TAG = 'latest' | 'pending';\n\n/**\n * READ API\n */\n\nexport type EVENTS_CHUNK = {\n  // Returns matching events\n  events: EMITTED_EVENT[];\n  // Use this token in a subsequent query to obtain the next page. Should not appear if there are no more pages.\n  continuation_token?: string;\n};\n\nexport type RESULT_PAGE_REQUEST = {\n  // The token returned from the previous query. If no token is provided the first page is returned.\n  continuation_token?: string;\n  // Chunk size\n  chunk_size: number;\n};\n\nexport type EMITTED_EVENT = EVENT & {\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  transaction_hash: TXN_HASH;\n};\n\nexport type EVENT = {\n  from_address: ADDRESS;\n} & EVENT_CONTENT;\n\nexport type EVENT_CONTENT = {\n  keys: FELT[];\n  data: FELT[];\n};\n\nexport type EVENT_FILTER = {\n  from_block?: BLOCK_ID;\n  to_block?: BLOCK_ID;\n  address?: ADDRESS;\n  keys?: FELT[][];\n};\n\nexport type BLOCK_ID =\n  | {\n      block_hash?: BLOCK_HASH;\n      block_number?: BLOCK_NUMBER;\n    }\n  | BLOCK_TAG;\n\nexport type SYNC_STATUS = {\n  starting_block_hash: BLOCK_HASH;\n  starting_block_num: BLOCK_NUMBER;\n  current_block_hash: BLOCK_HASH;\n  current_block_num: BLOCK_NUMBER;\n  highest_block_hash: BLOCK_HASH;\n  highest_block_num: BLOCK_NUMBER;\n};\n\nexport type NEW_CLASSES = {\n  class_hash: FELT;\n  compiled_class_hash: FELT;\n};\n\nexport type REPLACED_CLASS = {\n  class_hash: FELT;\n  contract_address: FELT;\n};\n\nexport type NONCE_UPDATE = {\n  contract_address: ADDRESS;\n  nonce: FELT;\n};\n\nexport type STATE_DIFF = {\n  storage_diffs: CONTRACT_STORAGE_DIFF_ITEM[];\n  deprecated_declared_classes: FELT[];\n  declared_classes: NEW_CLASSES[];\n  deployed_contracts: DEPLOYED_CONTRACT_ITEM[];\n  replaced_classes: REPLACED_CLASS[];\n  nonces: NONCE_UPDATE[];\n};\n\nexport type PENDING_STATE_UPDATE = {\n  old_root: FELT;\n  state_diff: STATE_DIFF;\n  block_hash: never; // diverge: this makes it distinct\n};\n\nexport type STATE_UPDATE = {\n  block_hash: BLOCK_HASH;\n  old_root: FELT;\n  new_root: FELT;\n  state_diff: STATE_DIFF;\n};\n\nexport type BLOCK_BODY_WITH_TX_HASHES = {\n  transactions: TXN_HASH[];\n};\n\nexport type BLOCK_BODY_WITH_TXS = {\n  transactions: (TXN & {\n    transaction_hash: TXN_HASH;\n  })[];\n};\n\nexport type BLOCK_HEADER = {\n  block_hash: BLOCK_HASH;\n  parent_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  new_root: FELT;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  starknet_version: string;\n};\n\nexport type PENDING_BLOCK_HEADER = {\n  parent_hash: BLOCK_HASH;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  starknet_version: string;\n};\n\nexport type BLOCK_WITH_TX_HASHES = { status: BLOCK_STATUS } & BLOCK_HEADER &\n  BLOCK_BODY_WITH_TX_HASHES;\n\nexport type BLOCK_WITH_TXS = { status: BLOCK_STATUS } & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;\n\nexport type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & PENDING_BLOCK_HEADER;\n\nexport type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & PENDING_BLOCK_HEADER;\n\nexport type DEPLOYED_CONTRACT_ITEM = {\n  address: FELT;\n  class_hash: FELT;\n};\n\nexport type CONTRACT_STORAGE_DIFF_ITEM = {\n  // The contract address for which the storage changed (in FELT format)\n  address: string;\n  // The changes in the storage of the contract\n  storage_entries: StorageDiffItem[];\n};\n\nexport type StorageDiffItem = {\n  // The key of the changed value (in FELT format)\n  key: string;\n  // The new value applied to the given address (in FELT format)\n  value: string;\n};\n\nexport type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;\n\nexport type DECLARE_TXN = DECLARE_TXN_V0 | DECLARE_TXN_V1 | DECLARE_TXN_V2 | DECLARE_TXN_V3;\n\nexport type DECLARE_TXN_V0 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type BROADCASTED_TXN =\n  | BROADCASTED_INVOKE_TXN\n  | BROADCASTED_DECLARE_TXN\n  | BROADCASTED_DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_INVOKE_TXN = INVOKE_TXN;\n\nexport type BROADCASTED_DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_DECLARE_TXN =\n  | BROADCASTED_DECLARE_TXN_V1\n  | BROADCASTED_DECLARE_TXN_V2\n  | BROADCASTED_DECLARE_TXN_V3;\n\nexport type BROADCASTED_DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  // todo: check if working, prev i fixed it with NUM_AS_HEX\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: DEPRECATED_CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN_V1 | DEPLOY_ACCOUNT_TXN_V3;\n\nexport type DEPLOY_ACCOUNT_TXN_V1 = {\n  type: 'DEPLOY_ACCOUNT';\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type DEPLOY_ACCOUNT_TXN_V3 = {\n  type: 'DEPLOY_ACCOUNT';\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_TXN = {\n  type: 'DEPLOY';\n  version: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type INVOKE_TXN = INVOKE_TXN_V0 | INVOKE_TXN_V1 | INVOKE_TXN_V3;\n\nexport type INVOKE_TXN_V0 = {\n  type: 'INVOKE';\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type INVOKE_TXN_V1 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n};\n\nexport type INVOKE_TXN_V3 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type L1_HANDLER_TXN = {\n  version: FELT;\n  type: 'L1_HANDLER';\n  nonce: NUM_AS_HEX;\n} & FUNCTION_CALL;\n\nexport type COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  execution_status: TXN_EXECUTION_STATUS;\n  finality_status: TXN_FINALITY_STATUS;\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  messages_sent: MSG_TO_L1[];\n  revert_reason?: string;\n  events: EVENT[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type PENDING_COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  messages_sent: MSG_TO_L1[];\n  events: EVENT[];\n  revert_reason?: string;\n  finality_status: 'ACCEPTED_ON_L2';\n  execution_status: TXN_EXECUTION_STATUS;\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_TXN_RECEIPT = {\n  type: 'DEPLOY';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type PENDING_L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & PENDING_COMMON_RECEIPT_PROPERTIES;\n\nexport type TXN_RECEIPT =\n  | INVOKE_TXN_RECEIPT\n  | L1_HANDLER_TXN_RECEIPT\n  | DECLARE_TXN_RECEIPT\n  | DEPLOY_TXN_RECEIPT\n  | DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type PENDING_TXN_RECEIPT =\n  | PENDING_INVOKE_TXN_RECEIPT\n  | PENDING_L1_HANDLER_TXN_RECEIPT\n  | PENDING_DECLARE_TXN_RECEIPT\n  | PENDING_DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type MSG_TO_L1 = {\n  from_address: FELT;\n  to_address: FELT;\n  payload: FELT[];\n};\n\nexport type MSG_FROM_L1 = {\n  from_address: ETH_ADDRESS;\n  to_address: ADDRESS;\n  entry_point_selector: FELT;\n  payload: FELT[];\n};\n\nexport type FUNCTION_CALL = {\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type CONTRACT_CLASS = {\n  sierra_program: FELT[];\n  contract_class_version: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: SIERRA_ENTRY_POINT[];\n    EXTERNAL: SIERRA_ENTRY_POINT[];\n    L1_HANDLER: SIERRA_ENTRY_POINT[];\n  };\n  abi: string;\n};\n\nexport type DEPRECATED_CONTRACT_CLASS = {\n  program: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: DEPRECATED_CAIRO_ENTRY_POINT[];\n    EXTERNAL: DEPRECATED_CAIRO_ENTRY_POINT[];\n    L1_HANDLER: DEPRECATED_CAIRO_ENTRY_POINT[];\n  };\n  abi: CONTRACT_ABI;\n};\n\nexport type DEPRECATED_CAIRO_ENTRY_POINT = {\n  offset: NUM_AS_HEX | number;\n  selector: FELT;\n};\n\nexport type SIERRA_ENTRY_POINT = {\n  selector: FELT;\n  function_idx: number;\n};\n\nexport type CONTRACT_ABI = readonly CONTRACT_ABI_ENTRY[];\n\nexport type CONTRACT_ABI_ENTRY = {\n  selector: FELT;\n  input: string;\n  output: string;\n};\n\nexport type STRUCT_ABI_ENTRY = {\n  type: STRUCT_ABI_TYPE;\n  name: string;\n  size: number;\n  members: STRUCT_MEMBER[];\n};\n\nexport type STRUCT_MEMBER = TYPED_PARAMETER & {\n  offset: number;\n};\n\nexport type EVENT_ABI_ENTRY = {\n  type: EVENT_ABI_TYPE;\n  name: string;\n  keys: TYPED_PARAMETER[];\n  data: TYPED_PARAMETER[];\n};\n\nexport type FUNCTION_STATE_MUTABILITY = 'view';\n\nexport type FUNCTION_ABI_ENTRY = {\n  type: FUNCTION_ABI_TYPE;\n  name: string;\n  inputs: TYPED_PARAMETER[];\n  outputs: TYPED_PARAMETER[];\n  stateMutability: FUNCTION_STATE_MUTABILITY;\n};\n\nexport type TYPED_PARAMETER = {\n  name: string;\n  type: string;\n};\n\nexport type SIMULATION_FLAG_FOR_ESTIMATE_FEE = 'SKIP_VALIDATE';\nexport type PRICE_UNIT = 'WEI' | 'FRI';\n\nexport type FEE_ESTIMATE = {\n  gas_consumed: FELT;\n  gas_price: FELT;\n  overall_fee: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type FEE_PAYMENT = {\n  amount: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type RESOURCE_BOUNDS_MAPPING = {\n  l1_gas: RESOURCE_BOUNDS;\n  l2_gas: RESOURCE_BOUNDS;\n};\n\nexport type RESOURCE_BOUNDS = {\n  max_amount: u64;\n  max_price_per_unit: u128;\n};\n\nexport type RESOURCE_PRICE = {\n  price_in_fri: FELT;\n  price_in_wei: FELT;\n};\n\nexport type EXECUTION_RESOURCES = {\n  steps: number;\n  memory_holes?: number;\n  range_check_builtin_applications?: number;\n  pedersen_builtin_applications?: number;\n  poseidon_builtin_applications?: number;\n  ec_op_builtin_applications?: number;\n  ecdsa_builtin_applications?: number;\n  bitwise_builtin_applications?: number;\n  keccak_builtin_applications?: number;\n  segment_arena_builtin?: number;\n};\n\n/**\n * TRACE API\n */\n\n// Represents a transaction trace including the execution details.\nexport type TRANSACTION_TRACE = {\n  invoke_tx_trace?: INVOKE_TXN_TRACE;\n  declare_tx_trace?: DECLARE_TXN_TRACE;\n  deploy_account_tx_trace?: DEPLOY_ACCOUNT_TXN_TRACE;\n  l1_handler_tx_trace?: L1_HANDLER_TXN_TRACE;\n};\n\n// Represents a transaction trace for an invoke transaction.\nexport type INVOKE_TXN_TRACE = {\n  type: 'INVOKE';\n  execute_invocation: FUNCTION_INVOCATION | { revert_reason: string };\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for a declare transaction.\nexport type DECLARE_TXN_TRACE = {\n  type: 'DECLARE';\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for a deploy account transaction.\nexport type DEPLOY_ACCOUNT_TXN_TRACE = {\n  type: 'DEPLOY_ACCOUNT';\n  constructor_invocation: FUNCTION_INVOCATION;\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a transaction trace for an L1 handler transaction.\nexport type L1_HANDLER_TXN_TRACE = {\n  type: 'L1_HANDLER';\n  function_invocation: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a nested function call.\nexport type NESTED_CALL = FUNCTION_INVOCATION;\n\n// Represents a function invocation along with its execution details.\nexport type FUNCTION_INVOCATION = FUNCTION_CALL & {\n  caller_address: string;\n  class_hash: string;\n  entry_point_type: ENTRY_POINT_TYPE;\n  call_type: CALL_TYPE;\n  result: string[];\n  calls: NESTED_CALL[];\n  events: ORDERED_EVENT[];\n  messages: ORDERED_MESSAGE[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\n// Represents an ordered event alongside its order within the transaction.\nexport type ORDERED_EVENT = {\n  order: number;\n  event: EVENT;\n};\n\n// Represents an ordered message alongside its order within the transaction.\nexport type ORDERED_MESSAGE = {\n  order: number;\n  message: MSG_TO_L1;\n};\n","/**\n * Types that are not in spec but required for UX\n */\nimport {\n  ADDRESS,\n  BLOCK_HASH,\n  BLOCK_NUMBER,\n  BLOCK_WITH_TXS,\n  BLOCK_WITH_TX_HASHES,\n  BROADCASTED_TXN,\n  CHAIN_ID,\n  CONTRACT_CLASS,\n  CONTRACT_STORAGE_DIFF_ITEM,\n  DEPRECATED_CONTRACT_CLASS,\n  EMITTED_EVENT,\n  EVENT,\n  EVENTS_CHUNK,\n  EVENT_FILTER,\n  FEE_ESTIMATE,\n  FEE_PAYMENT,\n  FELT,\n  MSG_FROM_L1,\n  NONCE_UPDATE,\n  PENDING_BLOCK_WITH_TXS,\n  PENDING_BLOCK_WITH_TX_HASHES,\n  PENDING_STATE_UPDATE,\n  PENDING_TXN_RECEIPT,\n  PRICE_UNIT,\n  REPLACED_CLASS,\n  RESOURCE_BOUNDS_MAPPING,\n  RESULT_PAGE_REQUEST,\n  SIMULATION_FLAG,\n  STATE_UPDATE,\n  SYNC_STATUS,\n  TRANSACTION_TRACE,\n  TXN,\n  TXN_EXECUTION_STATUS,\n  TXN_HASH,\n  TXN_RECEIPT,\n  TXN_STATUS,\n} from './components';\n\n// METHOD RESPONSES\n// response starknet_getClass\nexport type ContractClass = CONTRACT_CLASS | DEPRECATED_CONTRACT_CLASS;\n// response starknet_simulateTransactions\nexport type SimulateTransaction = {\n  transaction_trace: TRANSACTION_TRACE;\n  fee_estimation: FEE_ESTIMATE;\n};\nexport type SimulateTransactionResponse = SimulateTransaction[];\n// response starknet_estimateFee\nexport type FeeEstimate = FEE_ESTIMATE;\n// response starknet_getTransactionByHash, starknet_getTransactionByBlockIdAndIndex\nexport type TransactionWithHash = TXN & { transaction_hash: TXN_HASH };\n// response starknet_blockHashAndNumber\nexport type BlockHashAndNumber = { block_hash: BLOCK_HASH; block_number: BLOCK_NUMBER };\n// response starknet_getBlockWithTxs\nexport type BlockWithTxs = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;\n// response starknet_getBlockWithTxHashes\nexport type BlockWithTxHashes = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;\n// response starknet_getStateUpdate\nexport type StateUpdate = STATE_UPDATE | PENDING_STATE_UPDATE;\n// response starknet_traceBlockTransactions\nexport type BlockTransactionsTraces = { transaction_hash: FELT; trace_root: TRANSACTION_TRACE }[];\n// response starknet_syncing\nexport type Syncing = false | SYNC_STATUS;\n// response starknet_getEvents\nexport type Events = EVENTS_CHUNK;\nexport type EmittedEvent = EMITTED_EVENT;\nexport type Event = EVENT;\n// response starknet_addInvokeTransaction\nexport type InvokedTransaction = { transaction_hash: TXN_HASH };\n// response starknet_addDeclareTransaction\nexport type DeclaredTransaction = { transaction_hash: TXN_HASH; class_hash: FELT };\n// response starknet_addDeployAccountTransaction\nexport type DeployedAccountTransaction = { transaction_hash: TXN_HASH; contract_address: FELT };\n\n// Nice Components names\nexport type ContractAddress = ADDRESS;\nexport type Felt = FELT;\nexport type Nonce = FELT;\nexport type TransactionHash = TXN_HASH;\nexport type TransactionTrace = TRANSACTION_TRACE;\nexport type BlockHash = BLOCK_HASH;\nexport type TransactionReceipt = TXN_RECEIPT | PENDING_TXN_RECEIPT;\nexport type Receipt = TXN_RECEIPT;\nexport type PendingReceipt = PENDING_TXN_RECEIPT;\nexport type EventFilter = EVENT_FILTER & RESULT_PAGE_REQUEST;\nexport type SimulationFlags = Array<SIMULATION_FLAG>;\nexport type L1Message = MSG_FROM_L1;\nexport type BaseTransaction = BROADCASTED_TXN;\nexport type ChainId = CHAIN_ID;\nexport type Transaction = TXN;\nexport type TransactionStatus = {\n  finality_status: TXN_STATUS;\n  execution_status?: TXN_EXECUTION_STATUS;\n};\nexport type ResourceBounds = RESOURCE_BOUNDS_MAPPING;\nexport type FeePayment = FEE_PAYMENT;\nexport type PriceUnit = PRICE_UNIT;\n\n// Diff Than Seq\nexport type StorageDiffs = Array<CONTRACT_STORAGE_DIFF_ITEM>;\nexport type DeprecatedDeclaredClasses = Array<FELT>;\nexport type NonceUpdates = NONCE_UPDATE[];\nexport type ReplacedClasses = REPLACED_CLASS[];\n\n// Enums Derived From Spec Types (require manual check for changes)\nexport enum ETransactionType {\n  DECLARE = 'DECLARE',\n  DEPLOY = 'DEPLOY',\n  DEPLOY_ACCOUNT = 'DEPLOY_ACCOUNT',\n  INVOKE = 'INVOKE',\n  L1_HANDLER = 'L1_HANDLER',\n}\n\nexport enum ESimulationFlag {\n  SKIP_VALIDATE = 'SKIP_VALIDATE',\n  SKIP_FEE_CHARGE = 'SKIP_FEE_CHARGE',\n}\n\nexport enum ETransactionStatus {\n  RECEIVED = 'RECEIVED',\n  REJECTED = 'REJECTED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\n\nexport enum ETransactionFinalityStatus {\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\nexport enum ETransactionExecutionStatus {\n  SUCCEEDED = 'SUCCEEDED',\n  REVERTED = 'REVERTED',\n}\n\nexport enum EBlockTag {\n  LATEST = 'latest',\n  PENDING = 'pending',\n}\n\n// 'L1' | 'L2'\nexport enum EDataAvailabilityMode {\n  L1 = 'L1',\n  L2 = 'L2',\n}\n\n// 0 | 1\nexport enum EDAMode {\n  L1,\n  L2,\n}\n\n/**\n * V_ Transaction versions HexString\n * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)\n */\nexport enum ETransactionVersion {\n  V0 = '0x0',\n  V1 = '0x1',\n  V2 = '0x2',\n  V3 = '0x3',\n  F0 = '0x100000000000000000000000000000000',\n  F1 = '0x100000000000000000000000000000001',\n  F2 = '0x100000000000000000000000000000002',\n  F3 = '0x100000000000000000000000000000003',\n}\n\n/**\n * Old Transaction Versions\n */\nexport enum ETransactionVersion2 {\n  V0 = '0x0',\n  V1 = '0x1',\n  V2 = '0x2',\n  F0 = '0x100000000000000000000000000000000',\n  F1 = '0x100000000000000000000000000000001',\n  F2 = '0x100000000000000000000000000000002',\n}\n\n/**\n * V3 Transaction Versions\n */\nexport enum ETransactionVersion3 {\n  V3 = '0x3',\n  F3 = '0x100000000000000000000000000000003',\n}\n","/**\n * version v0.7.0-rc1\n */\n\nexport { Methods } from './methods';\nexport { ABI } from './contract';\nexport * as Errors from './errors';\nexport * as SPEC from './components';\nexport * from './nonspec';\n","export * from '../rpcspec_0_6/errors';\n","/**\n * PRIMITIVES\n */\n\n/**\n * A field element. represented by at most 63 hex digits\n * @pattern ^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,62})$\n */\nexport type FELT = string;\n/**\n * an ethereum address represented as 40 hex digits\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type ETH_ADDRESS = string;\n/**\n * A storage key. Represented as up to 62 hex digits, 3 bits, and 5 leading zeroes.\n * @pattern ^0x0[0-7]{1}[a-fA-F0-9]{0,62}$\n */\nexport type STORAGE_KEY = string;\nexport type ADDRESS = FELT;\nexport type NUM_AS_HEX = string;\n/**\n * 64 bit integers, represented by hex string of length at most 16\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,15})$\"\n */\nexport type u64 = string;\n/**\n * 64 bit integers, represented by hex string of length at most 32\n * \"pattern\": \"^0x(0|[a-fA-F1-9]{1}[a-fA-F0-9]{0,31})$\"\n */\nexport type u128 = string;\nexport type SIGNATURE = Array<FELT>;\nexport type BLOCK_NUMBER = number;\nexport type BLOCK_HASH = FELT;\nexport type TXN_HASH = FELT;\nexport type CHAIN_ID = NUM_AS_HEX;\nexport type STRUCT_ABI_TYPE = 'struct';\nexport type EVENT_ABI_TYPE = 'event';\nexport type FUNCTION_ABI_TYPE = 'function' | 'l1_handler' | 'constructor';\n// Represents the type of an entry point.\nexport type ENTRY_POINT_TYPE = 'EXTERNAL' | 'L1_HANDLER' | 'CONSTRUCTOR';\n// Represents the type of a function call.\nexport type CALL_TYPE = 'DELEGATE' | 'LIBRARY_CALL' | 'CALL';\n// Represents the status of the transaction\nexport type TXN_STATUS = 'RECEIVED' | 'REJECTED' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\n// Flags that indicate how to simulate a given transaction. By default, the sequencer behavior is replicated locally (enough funds are expected to be in the account, and the fee will be deducted from the balance before the simulation of the next transaction). To skip the fee charge, use the SKIP_FEE_CHARGE flag.\nexport type SIMULATION_FLAG = 'SKIP_VALIDATE' | 'SKIP_FEE_CHARGE';\n// Data availability mode\nexport type DA_MODE = 'L1' | 'L2';\nexport type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';\nexport type TXN_FINALITY_STATUS = 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1';\nexport type TXN_EXECUTION_STATUS = 'SUCCEEDED' | 'REVERTED';\nexport type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';\nexport type BLOCK_TAG = 'latest' | 'pending';\n\n/**\n * READ API\n */\n\nexport type EVENTS_CHUNK = {\n  // Returns matching events\n  events: EMITTED_EVENT[];\n  // Use this token in a subsequent query to obtain the next page. Should not appear if there are no more pages.\n  continuation_token?: string;\n};\n\nexport type RESULT_PAGE_REQUEST = {\n  // The token returned from the previous query. If no token is provided the first page is returned.\n  continuation_token?: string;\n  // Chunk size\n  chunk_size: number;\n};\n\nexport type EMITTED_EVENT = EVENT & {\n  block_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  transaction_hash: TXN_HASH;\n};\n\nexport type EVENT = {\n  from_address: ADDRESS;\n} & EVENT_CONTENT;\n\nexport type EVENT_CONTENT = {\n  keys: FELT[];\n  data: FELT[];\n};\n\nexport type EVENT_FILTER = {\n  from_block?: BLOCK_ID;\n  to_block?: BLOCK_ID;\n  address?: ADDRESS;\n  keys?: FELT[][];\n};\n\nexport type BLOCK_ID =\n  | {\n      block_hash?: BLOCK_HASH;\n      block_number?: BLOCK_NUMBER;\n    }\n  | BLOCK_TAG;\n\nexport type SYNC_STATUS = {\n  starting_block_hash: BLOCK_HASH;\n  starting_block_num: BLOCK_NUMBER;\n  current_block_hash: BLOCK_HASH;\n  current_block_num: BLOCK_NUMBER;\n  highest_block_hash: BLOCK_HASH;\n  highest_block_num: BLOCK_NUMBER;\n};\n\nexport type NEW_CLASSES = {\n  class_hash: FELT;\n  compiled_class_hash: FELT;\n};\n\nexport type REPLACED_CLASS = {\n  class_hash: FELT;\n  contract_address: FELT;\n};\n\nexport type NONCE_UPDATE = {\n  contract_address: ADDRESS;\n  nonce: FELT;\n};\n\nexport type STATE_DIFF = {\n  storage_diffs: CONTRACT_STORAGE_DIFF_ITEM[];\n  deprecated_declared_classes: FELT[];\n  declared_classes: NEW_CLASSES[];\n  deployed_contracts: DEPLOYED_CONTRACT_ITEM[];\n  replaced_classes: REPLACED_CLASS[];\n  nonces: NONCE_UPDATE[];\n};\n\nexport type PENDING_STATE_UPDATE = {\n  old_root: FELT;\n  state_diff: STATE_DIFF;\n  block_hash: never; // diverge: this makes it distinct\n};\n\nexport type STATE_UPDATE = {\n  block_hash: BLOCK_HASH;\n  old_root: FELT;\n  new_root: FELT;\n  state_diff: STATE_DIFF;\n};\n\nexport type BLOCK_BODY_WITH_TX_HASHES = {\n  transactions: TXN_HASH[];\n};\n\nexport type BLOCK_BODY_WITH_TXS = {\n  transactions: (TXN & {\n    transaction_hash: TXN_HASH;\n  })[];\n};\n\nexport type BLOCK_BODY_WITH_RECEIPTS = {\n  transactions: {\n    transaction: TXN;\n    receipt: TXN_RECEIPT;\n  }[];\n};\n\nexport type BLOCK_HEADER = {\n  block_hash: BLOCK_HASH;\n  parent_hash: BLOCK_HASH;\n  block_number: BLOCK_NUMBER;\n  new_root: FELT;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  l1_data_gas_price: RESOURCE_PRICE;\n  l1_da_mode: 'BLOB' | 'CALLDATA';\n  starknet_version: string;\n};\n\nexport type PENDING_BLOCK_HEADER = {\n  parent_hash: BLOCK_HASH;\n  timestamp: number;\n  sequencer_address: FELT;\n  l1_gas_price: RESOURCE_PRICE;\n  l1_data_gas_price: RESOURCE_PRICE;\n  l1_da_mode: 'BLOB' | 'CALLDATA';\n  starknet_version: string;\n};\n\nexport type BLOCK_WITH_TX_HASHES = { status: BLOCK_STATUS } & BLOCK_HEADER &\n  BLOCK_BODY_WITH_TX_HASHES;\n\nexport type BLOCK_WITH_TXS = { status: BLOCK_STATUS } & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;\n\nexport type BLOCK_WITH_RECEIPTS = {\n  status: BLOCK_STATUS;\n} & BLOCK_HEADER &\n  BLOCK_BODY_WITH_RECEIPTS;\n\nexport type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & PENDING_BLOCK_HEADER;\n\nexport type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & PENDING_BLOCK_HEADER;\n\nexport type PENDING_BLOCK_WITH_RECEIPTS = BLOCK_BODY_WITH_RECEIPTS & PENDING_BLOCK_HEADER;\n\nexport type DEPLOYED_CONTRACT_ITEM = {\n  address: FELT;\n  class_hash: FELT;\n};\n\nexport type CONTRACT_STORAGE_DIFF_ITEM = {\n  // The contract address for which the storage changed (in FELT format)\n  address: string;\n  // The changes in the storage of the contract\n  storage_entries: StorageDiffItem[];\n};\n\nexport type StorageDiffItem = {\n  // The key of the changed value (in FELT format)\n  key: string;\n  // The new value applied to the given address (in FELT format)\n  value: string;\n};\n\nexport type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;\n\nexport type DECLARE_TXN = DECLARE_TXN_V0 | DECLARE_TXN_V1 | DECLARE_TXN_V2 | DECLARE_TXN_V3;\n\nexport type DECLARE_TXN_V0 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n};\n\nexport type DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  class_hash: FELT;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type BROADCASTED_TXN =\n  | BROADCASTED_INVOKE_TXN\n  | BROADCASTED_DECLARE_TXN\n  | BROADCASTED_DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_INVOKE_TXN = INVOKE_TXN;\n\nexport type BROADCASTED_DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN;\n\nexport type BROADCASTED_DECLARE_TXN =\n  | BROADCASTED_DECLARE_TXN_V1\n  | BROADCASTED_DECLARE_TXN_V2\n  | BROADCASTED_DECLARE_TXN_V3;\n\nexport type BROADCASTED_DECLARE_TXN_V1 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  max_fee: FELT;\n  // todo: check if working, prev i fixed it with NUM_AS_HEX\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: DEPRECATED_CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V2 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  max_fee: FELT;\n  version: '0x2' | '0x100000000000000000000000000000002';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n};\n\nexport type BROADCASTED_DECLARE_TXN_V3 = {\n  type: 'DECLARE';\n  sender_address: ADDRESS;\n  compiled_class_hash: FELT;\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_class: CONTRACT_CLASS;\n  // new...\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_ACCOUNT_TXN = DEPLOY_ACCOUNT_TXN_V1 | DEPLOY_ACCOUNT_TXN_V3;\n\nexport type DEPLOY_ACCOUNT_TXN_V1 = {\n  type: 'DEPLOY_ACCOUNT';\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type DEPLOY_ACCOUNT_TXN_V3 = {\n  type: 'DEPLOY_ACCOUNT';\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type DEPLOY_TXN = {\n  type: 'DEPLOY';\n  version: FELT;\n  contract_address_salt: FELT;\n  constructor_calldata: FELT[];\n  class_hash: FELT;\n};\n\nexport type INVOKE_TXN = INVOKE_TXN_V0 | INVOKE_TXN_V1 | INVOKE_TXN_V3;\n\nexport type INVOKE_TXN_V0 = {\n  type: 'INVOKE';\n  max_fee: FELT;\n  version: '0x0' | '0x100000000000000000000000000000000';\n  signature: SIGNATURE;\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type INVOKE_TXN_V1 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  max_fee: FELT;\n  version: '0x1' | '0x100000000000000000000000000000001';\n  signature: SIGNATURE;\n  nonce: FELT;\n};\n\nexport type INVOKE_TXN_V3 = {\n  type: 'INVOKE';\n  sender_address: ADDRESS;\n  calldata: FELT[];\n  version: '0x3' | '0x100000000000000000000000000000003';\n  signature: SIGNATURE;\n  nonce: FELT;\n  resource_bounds: RESOURCE_BOUNDS_MAPPING;\n  tip: u64;\n  paymaster_data: FELT[];\n  account_deployment_data: FELT[];\n  nonce_data_availability_mode: DA_MODE;\n  fee_data_availability_mode: DA_MODE;\n};\n\nexport type L1_HANDLER_TXN = {\n  version: '0x0';\n  type: 'L1_HANDLER';\n  nonce: NUM_AS_HEX;\n} & FUNCTION_CALL;\n\nexport type COMMON_RECEIPT_PROPERTIES = {\n  transaction_hash: TXN_HASH;\n  actual_fee: FEE_PAYMENT;\n  execution_status: TXN_EXECUTION_STATUS;\n  finality_status: TXN_FINALITY_STATUS;\n  messages_sent: MSG_TO_L1[];\n  revert_reason?: string;\n  events: EVENT[];\n  execution_resources: EXECUTION_RESOURCES;\n};\n\nexport type INVOKE_TXN_RECEIPT = {\n  type: 'INVOKE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type DECLARE_TXN_RECEIPT = {\n  type: 'DECLARE';\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_ACCOUNT_TXN_RECEIPT = {\n  type: 'DEPLOY_ACCOUNT';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type DEPLOY_TXN_RECEIPT = {\n  type: 'DEPLOY';\n  contract_address: FELT;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type L1_HANDLER_TXN_RECEIPT = {\n  type: 'L1_HANDLER';\n  message_hash: NUM_AS_HEX;\n} & COMMON_RECEIPT_PROPERTIES;\n\nexport type TXN_RECEIPT =\n  | INVOKE_TXN_RECEIPT\n  | L1_HANDLER_TXN_RECEIPT\n  | DECLARE_TXN_RECEIPT\n  | DEPLOY_TXN_RECEIPT\n  | DEPLOY_ACCOUNT_TXN_RECEIPT;\n\nexport type TXN_RECEIPT_WITH_BLOCK_INFO = TXN_RECEIPT & {\n  block_hash?: BLOCK_HASH;\n  block_number?: BLOCK_NUMBER;\n};\n\nexport type MSG_TO_L1 = {\n  from_address: FELT;\n  to_address: FELT;\n  payload: FELT[];\n};\n\nexport type MSG_FROM_L1 = {\n  from_address: ETH_ADDRESS;\n  to_address: ADDRESS;\n  entry_point_selector: FELT;\n  payload: FELT[];\n};\n\nexport type FUNCTION_CALL = {\n  contract_address: ADDRESS;\n  entry_point_selector: FELT;\n  calldata: FELT[];\n};\n\nexport type CONTRACT_CLASS = {\n  sierra_program: FELT[];\n  contract_class_version: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: SIERRA_ENTRY_POINT[];\n    EXTERNAL: SIERRA_ENTRY_POINT[];\n    L1_HANDLER: SIERRA_ENTRY_POINT[];\n  };\n  abi: string;\n};\n\nexport type DEPRECATED_CONTRACT_CLASS = {\n  program: string;\n  entry_points_by_type: {\n    CONSTRUCTOR: DEPRECATED_CAIRO_ENTRY_POINT[];\n    EXTERNAL: DEPRECATED_CAIRO_ENTRY_POINT[];\n    L1_HANDLER: DEPRECATED_CAIRO_ENTRY_POINT[];\n  };\n  abi: CONTRACT_ABI;\n};\n\nexport type DEPRECATED_CAIRO_ENTRY_POINT = {\n  offset: NUM_AS_HEX | number;\n  selector: FELT;\n};\n\nexport type SIERRA_ENTRY_POINT = {\n  selector: FELT;\n  function_idx: number;\n};\n\nexport type CONTRACT_ABI = readonly CONTRACT_ABI_ENTRY[];\n\nexport type CONTRACT_ABI_ENTRY = {\n  selector: FELT;\n  input: string;\n  output: string;\n};\n\nexport type STRUCT_ABI_ENTRY = {\n  type: STRUCT_ABI_TYPE;\n  name: string;\n  size: number;\n  members: STRUCT_MEMBER[];\n};\n\nexport type STRUCT_MEMBER = TYPED_PARAMETER & {\n  offset: number;\n};\n\nexport type EVENT_ABI_ENTRY = {\n  type: EVENT_ABI_TYPE;\n  name: string;\n  keys: TYPED_PARAMETER[];\n  data: TYPED_PARAMETER[];\n};\n\nexport type FUNCTION_STATE_MUTABILITY = 'view';\n\nexport type FUNCTION_ABI_ENTRY = {\n  type: FUNCTION_ABI_TYPE;\n  name: string;\n  inputs: TYPED_PARAMETER[];\n  outputs: TYPED_PARAMETER[];\n  stateMutability: FUNCTION_STATE_MUTABILITY;\n};\n\nexport type TYPED_PARAMETER = {\n  name: string;\n  type: string;\n};\n\nexport type SIMULATION_FLAG_FOR_ESTIMATE_FEE = 'SKIP_VALIDATE';\nexport type PRICE_UNIT = 'WEI' | 'FRI';\n\nexport type FEE_ESTIMATE = {\n  gas_consumed: FELT;\n  gas_price: FELT;\n  data_gas_consumed: FELT;\n  data_gas_price: FELT;\n  overall_fee: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type FEE_PAYMENT = {\n  amount: FELT;\n  unit: PRICE_UNIT;\n};\n\nexport type RESOURCE_BOUNDS_MAPPING = {\n  l1_gas: RESOURCE_BOUNDS;\n  l2_gas: RESOURCE_BOUNDS;\n};\n\nexport type RESOURCE_BOUNDS = {\n  max_amount: u64;\n  max_price_per_unit: u128;\n};\n\nexport type RESOURCE_PRICE = {\n  price_in_fri: FELT;\n  price_in_wei: FELT;\n};\n\nexport type COMPUTATION_RESOURCES = {\n  steps: number;\n  memory_holes?: number;\n  range_check_builtin_applications?: number;\n  pedersen_builtin_applications?: number;\n  poseidon_builtin_applications?: number;\n  ec_op_builtin_applications?: number;\n  ecdsa_builtin_applications?: number;\n  bitwise_builtin_applications?: number;\n  keccak_builtin_applications?: number;\n  segment_arena_builtin?: number;\n};\n\nexport type EXECUTION_RESOURCES = COMPUTATION_RESOURCES & {\n  data_availability: {\n    l1_gas: number;\n    l1_data_gas: number;\n  };\n};\n\n/**\n * TRACE API\n */\n\n// Represents a transaction trace including the execution details.\nexport type TRANSACTION_TRACE = {\n  invoke_tx_trace?: INVOKE_TXN_TRACE;\n  declare_tx_trace?: DECLARE_TXN_TRACE;\n  deploy_account_tx_trace?: DEPLOY_ACCOUNT_TXN_TRACE;\n  l1_handler_tx_trace?: L1_HANDLER_TXN_TRACE;\n};\n\n// Represents a transaction trace for an invoke transaction.\nexport type INVOKE_TXN_TRACE = {\n  type: 'INVOKE';\n  execute_invocation: FUNCTION_INVOCATION | { revert_reason: string };\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n  execution_resources: EXECUTION_RESOURCES;\n};\n\n// Represents a transaction trace for a declare transaction.\nexport type DECLARE_TXN_TRACE = {\n  type: 'DECLARE';\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n  execution_resources: EXECUTION_RESOURCES;\n};\n\n// Represents a transaction trace for a deploy account transaction.\nexport type DEPLOY_ACCOUNT_TXN_TRACE = {\n  type: 'DEPLOY_ACCOUNT';\n  constructor_invocation: FUNCTION_INVOCATION;\n  validate_invocation?: FUNCTION_INVOCATION;\n  fee_transfer_invocation?: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n  execution_resources: EXECUTION_RESOURCES;\n};\n\n// Represents a transaction trace for an L1 handler transaction.\nexport type L1_HANDLER_TXN_TRACE = {\n  type: 'L1_HANDLER';\n  function_invocation: FUNCTION_INVOCATION;\n  state_diff?: STATE_DIFF;\n};\n\n// Represents a nested function call.\nexport type NESTED_CALL = FUNCTION_INVOCATION;\n\n// Represents a function invocation along with its execution details.\nexport type FUNCTION_INVOCATION = FUNCTION_CALL & {\n  caller_address: string;\n  class_hash: string;\n  entry_point_type: ENTRY_POINT_TYPE;\n  call_type: CALL_TYPE;\n  result: string[];\n  calls: NESTED_CALL[];\n  events: ORDERED_EVENT[];\n  messages: ORDERED_MESSAGE[];\n  execution_resources: COMPUTATION_RESOURCES;\n};\n\n// Represents an ordered event alongside its order within the transaction.\nexport type ORDERED_EVENT = {\n  order: number;\n  event: EVENT;\n};\n\n// Represents an ordered message alongside its order within the transaction.\nexport type ORDERED_MESSAGE = {\n  order: number;\n  message: MSG_TO_L1;\n};\n","/**\n * Types that are not in spec but required for UX\n */\nimport {\n  ADDRESS,\n  BLOCK_HASH,\n  BLOCK_NUMBER,\n  BLOCK_WITH_RECEIPTS,\n  BLOCK_WITH_TXS,\n  BLOCK_WITH_TX_HASHES,\n  BROADCASTED_TXN,\n  CHAIN_ID,\n  CONTRACT_CLASS,\n  CONTRACT_STORAGE_DIFF_ITEM,\n  DEPRECATED_CONTRACT_CLASS,\n  EMITTED_EVENT,\n  EVENT,\n  EVENTS_CHUNK,\n  EVENT_FILTER,\n  FEE_ESTIMATE,\n  FEE_PAYMENT,\n  FELT,\n  MSG_FROM_L1,\n  NONCE_UPDATE,\n  PENDING_BLOCK_WITH_RECEIPTS,\n  PENDING_BLOCK_WITH_TXS,\n  PENDING_BLOCK_WITH_TX_HASHES,\n  PENDING_STATE_UPDATE,\n  PRICE_UNIT,\n  REPLACED_CLASS,\n  RESOURCE_BOUNDS_MAPPING,\n  RESULT_PAGE_REQUEST,\n  SIMULATION_FLAG,\n  STATE_UPDATE,\n  SYNC_STATUS,\n  TRANSACTION_TRACE,\n  TXN,\n  TXN_EXECUTION_STATUS,\n  TXN_HASH,\n  TXN_RECEIPT,\n  TXN_RECEIPT_WITH_BLOCK_INFO,\n  TXN_STATUS,\n} from './components';\n\n// METHOD RESPONSES\n// response starknet_getClass\nexport type ContractClass = CONTRACT_CLASS | DEPRECATED_CONTRACT_CLASS;\n// response starknet_simulateTransactions\nexport type SimulateTransaction = {\n  transaction_trace: TRANSACTION_TRACE;\n  fee_estimation: FEE_ESTIMATE;\n};\nexport type SimulateTransactionResponse = SimulateTransaction[];\n// response starknet_estimateFee\nexport type FeeEstimate = FEE_ESTIMATE;\n// response starknet_getTransactionByHash, starknet_getTransactionByBlockIdAndIndex\nexport type TransactionWithHash = TXN & { transaction_hash: TXN_HASH };\n// response starknet_blockHashAndNumber\nexport type BlockHashAndNumber = { block_hash: BLOCK_HASH; block_number: BLOCK_NUMBER };\n// response starknet_getBlockWithTxs\nexport type BlockWithTxs = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;\n// response starknet_getBlockWithTxHashes\nexport type BlockWithTxHashes = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;\n// response starknet_getBlockWithReceipts\nexport type BlockWithTxReceipts = BLOCK_WITH_RECEIPTS | PENDING_BLOCK_WITH_RECEIPTS;\n// response starknet_getStateUpdate\nexport type StateUpdate = STATE_UPDATE | PENDING_STATE_UPDATE;\n// response starknet_traceBlockTransactions\nexport type BlockTransactionsTraces = { transaction_hash: FELT; trace_root: TRANSACTION_TRACE }[];\n// response starknet_syncing\nexport type Syncing = false | SYNC_STATUS;\n// response starknet_getEvents\nexport type Events = EVENTS_CHUNK;\nexport type EmittedEvent = EMITTED_EVENT;\nexport type Event = EVENT;\n// response starknet_addInvokeTransaction\nexport type InvokedTransaction = { transaction_hash: TXN_HASH };\n// response starknet_addDeclareTransaction\nexport type DeclaredTransaction = { transaction_hash: TXN_HASH; class_hash: FELT };\n// response starknet_addDeployAccountTransaction\nexport type DeployedAccountTransaction = { transaction_hash: TXN_HASH; contract_address: FELT };\n\n// Nice Components names\nexport type ContractAddress = ADDRESS;\nexport type Felt = FELT;\nexport type Nonce = FELT;\nexport type TransactionHash = TXN_HASH;\nexport type TransactionTrace = TRANSACTION_TRACE;\nexport type BlockHash = BLOCK_HASH;\nexport type TransactionReceipt = TXN_RECEIPT_WITH_BLOCK_INFO;\nexport type Receipt = TXN_RECEIPT_WITH_BLOCK_INFO & BlockHashAndNumber;\nexport type PendingReceipt = TXN_RECEIPT;\nexport type EventFilter = EVENT_FILTER & RESULT_PAGE_REQUEST;\nexport type SimulationFlags = Array<SIMULATION_FLAG>;\nexport type L1Message = MSG_FROM_L1;\nexport type BaseTransaction = BROADCASTED_TXN;\nexport type ChainId = CHAIN_ID;\nexport type Transaction = TXN;\nexport type TransactionStatus = {\n  finality_status: TXN_STATUS;\n  execution_status?: TXN_EXECUTION_STATUS;\n};\nexport type ResourceBounds = RESOURCE_BOUNDS_MAPPING;\nexport type FeePayment = FEE_PAYMENT;\nexport type PriceUnit = PRICE_UNIT;\n\n// Diff Than Seq\nexport type StorageDiffs = Array<CONTRACT_STORAGE_DIFF_ITEM>;\nexport type DeprecatedDeclaredClasses = Array<FELT>;\nexport type NonceUpdates = NONCE_UPDATE[];\nexport type ReplacedClasses = REPLACED_CLASS[];\n\n// Enums Derived From Spec Types (require manual check for changes)\nexport enum ETransactionType {\n  DECLARE = 'DECLARE',\n  DEPLOY = 'DEPLOY',\n  DEPLOY_ACCOUNT = 'DEPLOY_ACCOUNT',\n  INVOKE = 'INVOKE',\n  L1_HANDLER = 'L1_HANDLER',\n}\n\nexport enum ESimulationFlag {\n  SKIP_VALIDATE = 'SKIP_VALIDATE',\n  SKIP_FEE_CHARGE = 'SKIP_FEE_CHARGE',\n}\n\nexport enum ETransactionStatus {\n  RECEIVED = 'RECEIVED',\n  REJECTED = 'REJECTED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\n\nexport enum ETransactionFinalityStatus {\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\nexport enum ETransactionExecutionStatus {\n  SUCCEEDED = 'SUCCEEDED',\n  REVERTED = 'REVERTED',\n}\n\nexport enum EBlockTag {\n  LATEST = 'latest',\n  PENDING = 'pending',\n}\n\n// 'L1' | 'L2'\nexport enum EDataAvailabilityMode {\n  L1 = 'L1',\n  L2 = 'L2',\n}\n\n// 0 | 1\nexport enum EDAMode {\n  L1,\n  L2,\n}\n\n/**\n * V_ Transaction versions HexString\n * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)\n */\nexport enum ETransactionVersion {\n  V0 = '0x0',\n  V1 = '0x1',\n  V2 = '0x2',\n  V3 = '0x3',\n  F0 = '0x100000000000000000000000000000000',\n  F1 = '0x100000000000000000000000000000001',\n  F2 = '0x100000000000000000000000000000002',\n  F3 = '0x100000000000000000000000000000003',\n}\n\n/**\n * Old Transaction Versions\n */\nexport enum ETransactionVersion2 {\n  V0 = '0x0',\n  V1 = '0x1',\n  V2 = '0x2',\n  F0 = '0x100000000000000000000000000000000',\n  F1 = '0x100000000000000000000000000000001',\n  F2 = '0x100000000000000000000000000000002',\n}\n\n/**\n * V3 Transaction Versions\n */\nexport enum ETransactionVersion3 {\n  V3 = '0x3',\n  F3 = '0x100000000000000000000000000000003',\n}\n","import { base64 } from '@scure/base';\n\n/* eslint-disable no-param-reassign */\nexport const IS_BROWSER = typeof window !== 'undefined';\n\nconst STRING_ZERO = '0';\n\n/**\n * Some functions recreated from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts\n * enc-utils is not a dependency to avoid using `Buffer` which only works in node and not browsers\n */\n\n/**\n * Convert array buffer to string\n *\n * *[internal usage]*\n */\nexport function arrayBufferToString(array: ArrayBuffer): string {\n  return new Uint8Array(array).reduce((data, byte) => data + String.fromCharCode(byte), '');\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * *[internal usage]*\n */\nexport function utf8ToArray(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\n/**\n * Convert utf8-string to Uint8Array\n *\n * @deprecated equivalent to 'utf8ToArray', alias will be removed\n */\nexport function stringToArrayBuffer(str: string): Uint8Array {\n  return utf8ToArray(str);\n}\n\n/**\n * Convert string to array buffer (browser and node compatible)\n */\nexport function atobUniversal(a: string): Uint8Array {\n  return base64.decode(a);\n}\n\n/**\n * Convert array buffer to string (browser and node compatible)\n */\nexport function btoaUniversal(b: ArrayBuffer): string {\n  return base64.encode(new Uint8Array(b));\n}\n\n/**\n * Convert array buffer to hex-string\n * @returns format: hex-string\n */\nexport function buf2hex(buffer: Uint8Array) {\n  return buffer.reduce((r, x) => r + x.toString(16).padStart(2, '0'), '');\n}\n\n/**\n * Remove hex prefix '0x' from hex-string\n * @param hex hex-string\n * @returns format: base16-string\n */\nexport function removeHexPrefix(hex: string): string {\n  return hex.replace(/^0x/i, '');\n}\n\n/**\n * Add hex prefix '0x' to base16-string\n * @param hex base16-string\n * @returns format: hex-string\n */\nexport function addHexPrefix(hex: string): string {\n  return `0x${removeHexPrefix(hex)}`;\n}\n\n/**\n * Prepend or append to string\n *\n * *[internal usage]*\n */\nfunction padString(str: string, length: number, left: boolean, padding = STRING_ZERO): string {\n  const diff = length - str.length;\n  let result = str;\n  if (diff > 0) {\n    const pad = padding.repeat(diff);\n    result = left ? pad + str : str + pad;\n  }\n  return result;\n}\n\n/**\n * Prepend string (default with '0')\n */\nexport function padLeft(str: string, length: number, padding = STRING_ZERO): string {\n  return padString(str, length, true, padding);\n}\n\n/**\n * Calculate byte length of string\n *\n * *[no internal usage]*\n */\nexport function calcByteLength(str: string, byteSize = 8): number {\n  const { length } = str;\n  const remainder = length % byteSize;\n  return remainder ? ((length - remainder) / byteSize) * byteSize + byteSize : length;\n}\n\n/**\n * Prepend '0' to string bytes\n *\n * *[no internal usage]*\n */\nexport function sanitizeBytes(str: string, byteSize = 8, padding = STRING_ZERO): string {\n  return padLeft(str, calcByteLength(str, byteSize), padding);\n}\n\n/**\n * Prepend '0' to hex-string bytes\n *\n * *[no internal usage]*\n * @param hex hex-string\n * @returns format: hex-string\n */\nexport function sanitizeHex(hex: string): string {\n  hex = removeHexPrefix(hex);\n  hex = sanitizeBytes(hex, 2);\n  if (hex) {\n    hex = addHexPrefix(hex);\n  }\n  return hex;\n}\n\n/**\n * String transformation util\n *\n * Pascal case to screaming snake case\n */\nexport const pascalToSnake = (text: string) =>\n  /[a-z]/.test(text)\n    ? text\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase()\n    : text;\n","// eslint-disable-next-line max-classes-per-file\nexport function fixStack(target: Error, fn: Function = target.constructor) {\n  const { captureStackTrace } = Error as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  captureStackTrace && captureStackTrace(target, fn);\n}\n\nexport function fixProto(target: Error, prototype: {}) {\n  const { setPrototypeOf } = Object as any;\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-proto, no-param-reassign\n  setPrototypeOf ? setPrototypeOf(target, prototype) : ((target as any).__proto__ = prototype);\n}\n\n/* eslint-disable max-classes-per-file */\nexport class CustomError extends Error {\n  name!: string;\n\n  constructor(message?: string) {\n    super(message);\n    // set error name as constructor name, make it not enumerable to keep native Error behavior\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors\n    // see https://github.com/adriengibrat/ts-custom-error/issues/30\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true,\n    });\n    // fix the extended error prototype chain\n    // because typescript __extends implementation can't\n    // see https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    fixProto(this, new.target.prototype);\n    // try to remove constructor from stack trace\n    fixStack(this);\n  }\n}\n\nexport class LibraryError extends CustomError {}\n\nexport class GatewayError extends LibraryError {\n  constructor(\n    message: string,\n    public errorCode: string\n  ) {\n    super(message);\n  }\n}\n\nexport class HttpError extends LibraryError {\n  constructor(\n    message: string,\n    public errorCode: number\n  ) {\n    super(message);\n  }\n}\n","import { NetworkName, StarknetChainId } from '../constants';\nimport { LibraryError } from '../provider/errors';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RpcProviderOptions,\n  TransactionType,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC06 as RPC } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport fetch from '../utils/fetchPonyfill';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { getHexStringArray, toHex, toStorageKey } from '../utils/num';\nimport { Block, getDefaultNodeUrl, isV3Tx, isVersion, wait } from '../utils/provider';\nimport { decompressProgram, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.pending,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  readonly retries: number;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  private chainId?: StarknetChainId;\n\n  private specVersion?: string;\n\n  readonly waitMode: Boolean; // behave like web2 rpc and return when tx is processed\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, specVersion, waitMode } =\n      optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl as NetworkName, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(undefined, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.specVersion = specVersion;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return fetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify(params, null, 2)}\\n \n        ${code}: ${message}: ${stringify(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  public async getSpecVersion() {\n    this.specVersion ??= (await this.fetchEndpoint('starknet_specVersion')) as StarknetChainId;\n    return this.specVersion;\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    }: getSimulateTransactionOptions = {}\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5000;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      RPC.ETransactionExecutionStatus.SUCCEEDED,\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.SPEC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion('0.5', await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [RPC.ESimulationFlag.SKIP_VALIDATE] : [],\n      };\n    } // else v(0.5) no flags\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // V1\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: RPC.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // V3\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          type: RPC.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      // V1 Cairo 0\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          version: RPC.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      // V2 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      // V3 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    } else {\n      throw Error('declare unspotted parameters');\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // v1\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // v3\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: toHex(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0),\n      };\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: RPC.ETransactionType.INVOKE, // TODO: Diff between sequencer and rpc invoke type\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        // Cairo 0 - v1\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details,\n        } as RPC.SPEC.BROADCASTED_DECLARE_TXN_V1;\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // v1 v3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3) as RPC.SPEC.INVOKE_TXN['version'],\n        ...restDetails,\n      } as RPC.SPEC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","export * from './account';\nexport * from './calldata';\nexport * from './contract';\nexport * from './lib';\nexport * from './provider';\nexport * from './signer';\nexport * from './typedData';\nexport * from './cairoEnum';\n\nexport * as RPC from './api';\n","import { EDataAvailabilityMode, ETransactionVersion, ResourceBounds } from './api';\nimport {\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  Call,\n  DeclareContractPayload,\n  DeployAccountContractPayload,\n  TransactionType,\n  UniversalDeployerContractPayload,\n  V3TransactionDetails,\n} from './lib';\nimport { DeclareTransactionReceiptResponse, EstimateFeeResponse } from './provider';\n\nexport interface EstimateFee extends EstimateFeeResponse {}\n\nexport type EstimateFeeBulk = Array<EstimateFee>;\n\n// TODO: This is too wide generic with optional params\nexport type AccountInvocationsFactoryDetails = {\n  versions: Array<`${ETransactionVersion}`>;\n  nonce?: BigNumberish;\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n} & Partial<V3TransactionDetails>;\n\nexport interface UniversalDetails {\n  nonce?: BigNumberish;\n  blockIdentifier?: BlockIdentifier;\n  maxFee?: BigNumberish; // ignored on estimate\n  tip?: BigNumberish;\n  paymasterData?: BigNumberish[];\n  accountDeploymentData?: BigNumberish[];\n  nonceDataAvailabilityMode?: EDataAvailabilityMode;\n  feeDataAvailabilityMode?: EDataAvailabilityMode;\n  version?: BigNumberish;\n  resourceBounds?: ResourceBounds; // ignored on estimate\n  skipValidate?: boolean; // ignored on non-estimate\n}\n\nexport interface EstimateFeeDetails extends UniversalDetails {}\n\nexport interface DeployContractResponse {\n  contract_address: string;\n  transaction_hash: string;\n}\n\nexport type MultiDeployContractResponse = {\n  contract_address: Array<string>;\n  transaction_hash: string;\n};\n\nexport type DeployContractUDCResponse = {\n  contract_address: string;\n  transaction_hash: string;\n  address: string;\n  deployer: string;\n  unique: string;\n  classHash: string;\n  calldata_len: string;\n  calldata: Array<string>;\n  salt: string;\n};\n\nexport type DeclareDeployUDCResponse = {\n  declare: {\n    class_hash: BigNumberish;\n  } & Partial<DeclareTransactionReceiptResponse>;\n  deploy: DeployContractUDCResponse;\n};\n\nexport type SimulateTransactionDetails = {\n  nonce?: BigNumberish;\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n  skipExecute?: boolean;\n} & Partial<V3TransactionDetails>;\n\nexport enum SIMULATION_FLAG {\n  SKIP_VALIDATE = 'SKIP_VALIDATE',\n  SKIP_EXECUTE = 'SKIP_EXECUTE',\n}\n\nexport type EstimateFeeAction =\n  | {\n      type: TransactionType.INVOKE;\n      payload: AllowArray<Call>;\n    }\n  | {\n      type: TransactionType.DECLARE;\n      payload: DeclareContractPayload;\n    }\n  | {\n      type: TransactionType.DEPLOY_ACCOUNT;\n      payload: DeployAccountContractPayload;\n    }\n  | {\n      type: TransactionType.DEPLOY;\n      payload: UniversalDeployerContractPayload;\n    };\n\nexport type StarkProfile = {\n  name?: string;\n  profilePicture?: string;\n  discord?: string;\n  twitter?: string;\n  github?: string;\n  proofOfPersonhood?: boolean;\n};\n","export enum ValidateType {\n  DEPLOY = 'DEPLOY',\n  CALL = 'CALL',\n  INVOKE = 'INVOKE',\n}\n\nexport enum Uint {\n  u8 = 'core::integer::u8',\n  u16 = 'core::integer::u16',\n  u32 = 'core::integer::u32',\n  u64 = 'core::integer::u64',\n  u128 = 'core::integer::u128',\n  u256 = 'core::integer::u256', // This one is struct\n}\n\nexport enum Literal {\n  ClassHash = 'core::starknet::class_hash::ClassHash',\n  ContractAddress = 'core::starknet::contract_address::ContractAddress',\n}\n","import { LegacyCompiledContract, LegacyContractClass } from './legacy';\nimport { CompiledSierra, SierraContractClass } from './sierra';\n\n// Final types\n/**\n * format produced after compressing compiled contract\n * CompressedCompiledContract\n */\nexport type ContractClass = LegacyContractClass | SierraContractClass;\n\n/**\n * format produced after compile .cairo to .json\n */\nexport type CompiledContract = LegacyCompiledContract | CompiledSierra;\n\n/**\n * Compressed or decompressed Cairo0 or Cairo1 Contract\n */\nexport type CairoContract = ContractClass | CompiledContract;\n\n// Basic elements\nexport enum EntryPointType {\n  EXTERNAL = 'EXTERNAL',\n  L1_HANDLER = 'L1_HANDLER',\n  CONSTRUCTOR = 'CONSTRUCTOR',\n}\n\nexport * from './abi';\nexport * from './legacy';\nexport * from './sierra';\n","import { StarknetChainId } from '../../constants';\nimport { weierstrass } from '../../utils/ec';\nimport { EDataAvailabilityMode, ResourceBounds } from '../api';\nimport { CairoEnum } from '../cairoEnum';\nimport { CompiledContract, CompiledSierraCasm, ContractClass } from './contract';\n\nexport type WeierstrassSignatureType = weierstrass.SignatureType;\nexport type ArraySignatureType = string[];\nexport type Signature = ArraySignatureType | WeierstrassSignatureType;\n\nexport type BigNumberish = string | number | bigint;\n\nexport type ByteArray = {\n  data: BigNumberish[];\n  pending_word: BigNumberish;\n  pending_word_len: BigNumberish;\n};\n\n/**\n * Compiled calldata ready to be sent\n * decimal-string array\n */\nexport type Calldata = string[] & { readonly __compiled__?: true };\n\n/**\n * Represents an integer in the range [0, 2^256)\n */\nexport interface Uint256 {\n  // The low 128 bits of the value\n  low: BigNumberish;\n  // The high 128 bits of the value\n  high: BigNumberish;\n}\n\n/**\n * BigNumberish array\n * use CallData.compile() to convert to Calldata\n */\nexport type RawCalldata = BigNumberish[];\n\n/**\n * Hexadecimal-string array\n */\nexport type HexCalldata = string[];\n\nexport type AllowArray<T> = T | T[];\n\nexport type OptionalPayload<T> = { payload: T } | T;\n\nexport type RawArgs = RawArgsObject | RawArgsArray;\n\nexport type RawArgsObject = {\n  [inputName: string]: MultiType | MultiType[] | RawArgs;\n};\n\nexport type RawArgsArray = Array<MultiType | MultiType[] | RawArgs>;\n\nexport type MultiType = BigNumberish | Uint256 | object | boolean | CairoEnum;\n\nexport type UniversalDeployerContractPayload = {\n  classHash: BigNumberish;\n  salt?: string;\n  unique?: boolean;\n  constructorCalldata?: RawArgs;\n};\n\nexport type DeployAccountContractPayload = {\n  classHash: string;\n  constructorCalldata?: RawArgs;\n  addressSalt?: BigNumberish;\n  contractAddress?: string;\n};\n\nexport type DeployAccountContractTransaction = Omit<\n  DeployAccountContractPayload,\n  'contractAddress'\n> & {\n  signature?: Signature;\n};\n\nexport type DeclareContractPayload = {\n  contract: CompiledContract | string;\n  classHash?: string;\n  casm?: CompiledSierraCasm;\n  compiledClassHash?: string;\n};\n\nexport type CompleteDeclareContractPayload = {\n  contract: CompiledContract | string;\n  classHash: string;\n  casm?: CompiledSierraCasm;\n  compiledClassHash?: string;\n};\n\nexport type DeclareAndDeployContractPayload = Omit<UniversalDeployerContractPayload, 'classHash'> &\n  DeclareContractPayload;\n\nexport type DeclareContractTransaction = {\n  contract: ContractClass;\n  senderAddress: string;\n  signature?: Signature;\n  compiledClassHash?: string;\n};\n\nexport type CallDetails = {\n  contractAddress: string;\n  calldata?: RawArgs | Calldata;\n  entrypoint?: string;\n};\n\nexport type Invocation = CallDetails & { signature?: Signature };\n\nexport type Call = CallDetails & { entrypoint: string };\n\nexport type CairoVersion = '0' | '1' | undefined;\nexport type CompilerVersion = '0' | '1' | '2' | undefined;\n\nexport type InvocationsDetails = {\n  nonce?: BigNumberish;\n  maxFee?: BigNumberish;\n  version?: BigNumberish;\n} & Partial<V3TransactionDetails>;\n\nexport type V3TransactionDetails = {\n  nonce: BigNumberish;\n  version: BigNumberish;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDataAvailabilityMode;\n  feeDataAvailabilityMode: EDataAvailabilityMode;\n};\n\n/**\n * Contain all additional details params\n */\nexport type Details = {\n  nonce: BigNumberish;\n  maxFee: BigNumberish;\n  version: BigNumberish;\n  chainId: StarknetChainId;\n};\n\nexport type InvocationsDetailsWithNonce =\n  | (InvocationsDetails & {\n      nonce: BigNumberish;\n    })\n  | V3TransactionDetails;\n\nexport enum TransactionType {\n  DECLARE = 'DECLARE',\n  DEPLOY = 'DEPLOY',\n  DEPLOY_ACCOUNT = 'DEPLOY_ACCOUNT',\n  INVOKE = 'INVOKE_FUNCTION',\n}\n\n/**\n * new statuses are defined by props: finality_status and execution_status\n * to be #deprecated\n */\nexport enum TransactionStatus {\n  NOT_RECEIVED = 'NOT_RECEIVED',\n  RECEIVED = 'RECEIVED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n  REJECTED = 'REJECTED',\n  REVERTED = 'REVERTED',\n}\n\nexport enum TransactionFinalityStatus {\n  NOT_RECEIVED = 'NOT_RECEIVED',\n  RECEIVED = 'RECEIVED',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n}\n\nexport enum TransactionExecutionStatus {\n  REJECTED = 'REJECTED',\n  REVERTED = 'REVERTED',\n  SUCCEEDED = 'SUCCEEDED',\n}\n\nexport enum BlockStatus {\n  PENDING = 'PENDING',\n  ACCEPTED_ON_L1 = 'ACCEPTED_ON_L1',\n  ACCEPTED_ON_L2 = 'ACCEPTED_ON_L2',\n  REJECTED = 'REJECTED',\n}\n\nexport enum BlockTag {\n  pending = 'pending',\n  latest = 'latest',\n}\n\nexport type BlockNumber = BlockTag | null | number;\n\n/**\n * hex string and BN are detected as block hashes\n * decimal string and number are detected as block numbers\n * null appends nothing to the request url\n */\nexport type BlockIdentifier = BlockNumber | BigNumberish;\n\n/**\n * items used by AccountInvocations\n */\nexport type AccountInvocationItem = (\n  | ({ type: TransactionType.DECLARE } & DeclareContractTransaction)\n  | ({ type: TransactionType.DEPLOY_ACCOUNT } & DeployAccountContractTransaction)\n  | ({ type: TransactionType.INVOKE } & Invocation)\n) &\n  InvocationsDetailsWithNonce;\n\n/**\n * Complete invocations array with account details (internal type from account -> provider)\n */\nexport type AccountInvocations = AccountInvocationItem[];\n\n/**\n * Invocations array user provide to bulk method (simulate)\n */\nexport type Invocations = Array<\n  | ({ type: TransactionType.DECLARE } & OptionalPayload<DeclareContractPayload>)\n  | ({ type: TransactionType.DEPLOY } & OptionalPayload<\n      AllowArray<UniversalDeployerContractPayload>\n    >)\n  | ({ type: TransactionType.DEPLOY_ACCOUNT } & OptionalPayload<DeployAccountContractPayload>)\n  | ({ type: TransactionType.INVOKE } & OptionalPayload<AllowArray<Call>>)\n>;\n\nexport type Tupled = { element: any; type: string };\n\nexport type Args = {\n  [inputName: string]: BigNumberish | BigNumberish[] | ParsedStruct | ParsedStruct[];\n};\nexport type ParsedStruct = {\n  [key: string]: BigNumberish | BigNumberish[] | ParsedStruct | Uint256;\n};\n\nexport type waitForTransactionOptions = {\n  retryInterval?: number;\n  successStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;\n  errorStates?: Array<TransactionFinalityStatus | TransactionExecutionStatus>;\n};\n\nexport type getSimulateTransactionOptions = {\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n  skipExecute?: boolean;\n  skipFeeCharge?: boolean;\n};\n\nexport type getContractVersionOptions = {\n  blockIdentifier?: BlockIdentifier;\n  compiler?: boolean;\n};\n\nexport type getEstimateFeeBulkOptions = {\n  blockIdentifier?: BlockIdentifier;\n  skipValidate?: boolean;\n};\n\nexport interface CallStruct {\n  to: string;\n  selector: string;\n  calldata: string[];\n}\n\n/**\n * Represent Contract version\n */\nexport type ContractVersion = {\n  /** version of the cairo language */\n  cairo: CairoVersion;\n  /** version of the cairo compiler used to compile the contract */\n  compiler: CompilerVersion;\n};\n\nexport * from './contract';\n","// TODO: adjust starknet casing in v6\n\nexport enum TypedDataRevision {\n  Active = '1',\n  Legacy = '0',\n}\n\nexport type StarkNetEnumType = {\n  name: string;\n  type: 'enum';\n  contains: string;\n};\n\nexport type StarkNetMerkleType = {\n  name: string;\n  type: 'merkletree';\n  contains: string;\n};\n\n/**\n * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types.\n *\n * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712\n * standard.\n */\nexport type StarkNetType =\n  | {\n      name: string;\n      type: string;\n    }\n  | StarkNetEnumType\n  | StarkNetMerkleType;\n\n/**\n * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.\n */\nexport interface StarkNetDomain extends Record<string, unknown> {\n  name?: string;\n  version?: string;\n  chainId?: string | number;\n  revision?: string;\n}\n\n/**\n * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.\n */\nexport interface TypedData {\n  types: Record<string, StarkNetType[]>;\n  primaryType: string;\n  domain: StarkNetDomain;\n  message: Record<string, unknown>;\n}\n","export default function assert(condition: any, message?: string): asserts condition {\n  if (!condition) {\n    throw new Error(message || 'Assertion failure');\n  }\n}\n","import { hexToBytes as hexToBytesNoble } from '@noble/curves/abstract/utils';\n\nimport { BigNumberish } from '../types';\nimport assert from './assert';\nimport { addHexPrefix, removeHexPrefix } from './encode';\n\n/** @deprecated prefer importing from 'types' over 'num' */\nexport type { BigNumberish };\n\n/**\n * Test if string is hex-string\n * @param hex hex-string\n */\nexport function isHex(hex: string): boolean {\n  return /^0x[0-9a-f]*$/i.test(hex);\n}\n\n/**\n * Convert BigNumberish to bigint\n */\nexport function toBigInt(value: BigNumberish): bigint {\n  return BigInt(value);\n}\n\n/**\n * Test if value is bigint\n */\nexport function isBigInt(value: any): value is bigint {\n  return typeof value === 'bigint';\n}\n\n/**\n * Convert BigNumberish to hex-string\n * @returns format: hex-string\n */\nexport function toHex(number: BigNumberish): string {\n  return addHexPrefix(toBigInt(number).toString(16));\n}\n\n/**\n * Alias of ToHex\n */\nexport const toHexString = toHex;\n\n/**\n * Convert BigNumberish to storage-key-string\n *\n * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.\n *\n * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:\n * `0x0 + [0-7] + 62 hex = 0x + 64 hex`\n * @returns format: storage-key-string\n */\nexport function toStorageKey(number: BigNumberish): string {\n  const res = addHexPrefix(toBigInt(number).toString(16).padStart(64, '0'));\n  return res;\n}\n\n/**\n * Convert hexadecimal string to decimal string\n * @param hex hex-string\n * @returns format: decimal string\n */\nexport function hexToDecimalString(hex: string): string {\n  return BigInt(addHexPrefix(hex)).toString(10);\n}\n\n/**\n * Remove hex string leading zero and lowercase it\n * @example '0x01A...' -> '0x1a..'\n * @param hex hex-string\n * @returns format: hex-string\n */\nexport const cleanHex = (hex: string) => hex.toLowerCase().replace(/^(0x)0+/, '$1');\n\n/**\n * Asserts input is equal to or greater then lowerBound and lower then upperBound.\n *\n * The `inputName` parameter is used in the assertion message.\n */\nexport function assertInRange(\n  input: BigNumberish,\n  lowerBound: BigNumberish,\n  upperBound: BigNumberish,\n  inputName = ''\n) {\n  const messageSuffix = inputName === '' ? 'invalid length' : `invalid ${inputName} length`;\n  const inputBigInt = BigInt(input);\n  const lowerBoundBigInt = BigInt(lowerBound);\n  const upperBoundBigInt = BigInt(upperBound);\n\n  assert(\n    inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt,\n    `Message not signable, ${messageSuffix}.`\n  );\n}\n\n/**\n * Convert BigNumberish array to decimal string array\n * @returns format: decimal string array\n */\nexport function bigNumberishArrayToDecimalStringArray(rawCalldata: BigNumberish[]): string[] {\n  return rawCalldata.map((x) => toBigInt(x).toString(10));\n}\n\n/**\n * Convert BigNumberish array to hexadecimal string array\n * @returns format: hex-string array\n */\nexport function bigNumberishArrayToHexadecimalStringArray(rawCalldata: BigNumberish[]): string[] {\n  return rawCalldata.map((x) => toHex(x));\n}\n\n/**\n * Test if string is whole number (0, 1, 2, 3...)\n */\nexport const isStringWholeNumber = (value: string) => /^\\d+$/.test(value);\n\n/**\n * Convert string to decimal string\n * @returns format: decimal string\n */\nexport function getDecimalString(value: string) {\n  if (isHex(value)) {\n    return hexToDecimalString(value);\n  }\n  if (isStringWholeNumber(value)) {\n    return value;\n  }\n  throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\n\n/**\n * Convert string to hexadecimal string\n * @returns format: hex-string\n */\nexport function getHexString(value: string) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  throw new Error(`${value} need to be hex-string or whole-number-string`);\n}\n\n/**\n * Convert string array to hex-string array\n * @returns format: hex-string array\n */\nexport function getHexStringArray(value: Array<string>) {\n  return value.map((el) => getHexString(el));\n}\n\n/**\n * Convert boolean to \"0\" or \"1\"\n */\nexport const toCairoBool = (value: boolean): string => (+value).toString();\n\n/**\n * Convert hex-string to an array of Bytes (Uint8Array)\n * @param value hex-string\n */\nexport function hexToBytes(value: string): Uint8Array {\n  if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);\n\n  let adaptedValue: string = removeHexPrefix(value);\n  if (adaptedValue.length % 2 !== 0) {\n    adaptedValue = `0${adaptedValue}`;\n  }\n  return hexToBytesNoble(adaptedValue);\n}\n\n/**\n *\n * @param number value to be increased\n * @param percent integer as percent ex. 50 for 50%\n * @returns increased value\n */\nexport function addPercent(number: BigNumberish, percent: number) {\n  const bigIntNum = BigInt(number);\n  return bigIntNum + (bigIntNum * BigInt(percent)) / 100n;\n}\n","import { keccak } from '@scure/starknet';\n\nimport { MASK_250 } from '../constants';\nimport { BigNumberish } from '../types';\nimport { addHexPrefix, removeHexPrefix, utf8ToArray } from './encode';\nimport { hexToBytes, isHex, isStringWholeNumber, toHex, toHexString } from './num';\n\n/**\n * Calculate hex-string keccak hash for a given BigNumberish\n *\n * BigNumberish -> hex-string keccak hash\n * @returns format: hex-string\n */\nexport function keccakBn(value: BigNumberish): string {\n  const hexWithoutPrefix = removeHexPrefix(toHex(BigInt(value)));\n  const evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : `0${hexWithoutPrefix}`;\n  return addHexPrefix(keccak(hexToBytes(addHexPrefix(evenHex))).toString(16));\n}\n\n/**\n * Calculate hex-string keccak hash for a given string\n *\n * String -> hex-string keccak hash\n * @returns format: hex-string\n */\nfunction keccakHex(str: string): string {\n  return addHexPrefix(keccak(utf8ToArray(str)).toString(16));\n}\n\n/**\n * Calculate bigint keccak hash for a given string\n *\n * String -> bigint keccak hash\n *\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L17-L22)\n * @param str the value you want to get the keccak hash from\n * @returns starknet keccak hash as BigInt\n */\nexport function starknetKeccak(str: string): bigint {\n  const hash = BigInt(keccakHex(str));\n  // eslint-disable-next-line no-bitwise\n  return hash & MASK_250;\n}\n\n/**\n * Calculate hex-string selector for a given abi-function-name\n *\n * Abi-function-name -> hex-string selector\n *\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L25-L26)\n * @param funcName ascii-string of 'abi function name'\n * @returns format: hex-string; selector for 'abi function name'\n */\nexport function getSelectorFromName(funcName: string) {\n  // sometimes BigInteger pads the hex string with zeros, which is not allowed in the starknet api\n  return toHex(starknetKeccak(funcName));\n}\n\n/**\n * Calculate hex-string selector from abi-function-name, decimal string or hex string\n *\n * ('abi-function-name' or dec-string or hex-string) -> hex-string selector\n *\n * @param value hex-string | dec-string | ascii-string\n * @returns format: hex-string\n */\nexport function getSelector(value: string) {\n  if (isHex(value)) {\n    return value;\n  }\n  if (isStringWholeNumber(value)) {\n    return toHexString(value);\n  }\n  return getSelectorFromName(value);\n}\n","import { TEXT_TO_FELT_MAX_LEN } from '../constants';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { isHex, isStringWholeNumber } from './num';\n\n/**\n * Test if string contains only ASCII characters (string can be ascii text)\n */\nexport function isASCII(str: string) {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\n/**\n * Test if string is a Cairo short string (string has less or equal 31 characters)\n */\nexport function isShortString(str: string) {\n  return str.length <= TEXT_TO_FELT_MAX_LEN;\n}\n\n/**\n * Test if string contains only numbers (string can be converted to decimal number)\n */\nexport function isDecimalString(str: string): boolean {\n  return /^[0-9]*$/i.test(str);\n}\n\n/**\n * Test if value is a free-from string text, and not a hex string or number string\n */\nexport function isText(val: any) {\n  return typeof val === 'string' && !isHex(val) && !isStringWholeNumber(val);\n}\n\n/**\n * Test if value is short text\n */\nexport const isShortText = (val: any) => isText(val) && isShortString(val);\n\n/**\n * Test if value is long text\n */\nexport const isLongText = (val: any) => isText(val) && !isShortString(val);\n\n/**\n * Split long text into short strings\n */\nexport function splitLongString(longStr: string): string[] {\n  const regex = RegExp(`[^]{1,${TEXT_TO_FELT_MAX_LEN}}`, 'g');\n  return longStr.match(regex) || [];\n}\n\n/**\n * Convert an ASCII string to a hexadecimal string.\n * @param str short string (ASCII string, 31 characters max)\n * @returns format: hex-string; 248 bits max\n * @example\n * ```typescript\n * const myEncodedString: string = encodeShortString(\"uri/pict/t38.jpg\");\n * // return hex string (ex.\"0x7572692f706963742f7433382e6a7067\")\n * ```\n */\nexport function encodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (!isShortString(str)) throw new Error(`${str} is too long`);\n  return addHexPrefix(str.replace(/./g, (char) => char.charCodeAt(0).toString(16)));\n}\n\n/**\n * Convert a hexadecimal or decimal string to an ASCII string.\n * @param str representing a 248 bit max number (ex. \"0x1A4F64EA56\" or \"236942575435676423\")\n * @returns format: short string; 31 characters max\n * @example\n * ```typescript\n * const myDecodedString: string = decodeShortString(\"0x7572692f706963742f7433382e6a7067\");\n * // return string (ex.\"uri/pict/t38.jpg\")\n * ```\n */\nexport function decodeShortString(str: string): string {\n  if (!isASCII(str)) throw new Error(`${str} is not an ASCII string`);\n  if (isHex(str)) {\n    return removeHexPrefix(str).replace(/.{2}/g, (hex) => String.fromCharCode(parseInt(hex, 16)));\n  }\n  if (isDecimalString(str)) {\n    return decodeShortString('0X'.concat(BigInt(str).toString(16)));\n  }\n  throw new Error(`${str} is not Hex or decimal`);\n}\n","import { BigNumberish, ByteArray } from '../../types/lib';\nimport { toHex } from '../num';\nimport { decodeShortString, encodeShortString, splitLongString } from '../shortString';\n\n/**\n * convert a Cairo ByteArray to a JS string\n * @param myByteArray Cairo representation of a LongString\n * @returns a JS string\n * @example\n * ```typescript\n * const myByteArray = {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n * const result: String = stringFromByteArray(myByteArray); // ABCDEFGHI\n * ```\n */\nexport function stringFromByteArray(myByteArray: ByteArray): string {\n  const pending_word: string =\n    BigInt(myByteArray.pending_word) === 0n\n      ? ''\n      : decodeShortString(toHex(myByteArray.pending_word));\n  return (\n    myByteArray.data.reduce<string>((cumuledString, encodedString: BigNumberish) => {\n      const add: string =\n        BigInt(encodedString) === 0n ? '' : decodeShortString(toHex(encodedString));\n      return cumuledString + add;\n    }, '') + pending_word\n  );\n}\n\n/**\n * convert a JS string to a Cairo ByteArray\n * @param myString a JS string\n * @returns Cairo representation of a LongString\n * @example\n * ```typescript\n * const myByteArray: ByteArray = byteArrayFromString(\"ABCDEFGHI\");\n * ```\n * Result is :\n * {\n *    data: [],\n *    pending_word: '0x414243444546474849',\n *    pending_word_len: 9\n * }\n */\nexport function byteArrayFromString(targetString: string): ByteArray {\n  const shortStrings: string[] = splitLongString(targetString);\n  const remainder: string = shortStrings[shortStrings.length - 1];\n  const shortStringsEncoded: BigNumberish[] = shortStrings.map(encodeShortString);\n\n  const [pendingWord, pendingWordLength] =\n    remainder === undefined || remainder.length === 31\n      ? ['0x00', 0]\n      : [shortStringsEncoded.pop()!, remainder.length];\n\n  return {\n    data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,\n    pending_word: pendingWord,\n    pending_word_len: pendingWordLength,\n  };\n}\n","import {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  ContractVersion,\n  Literal,\n  Uint,\n  Uint256,\n} from '../../types';\nimport { CairoFelt } from '../cairoDataTypes/felt';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\n\n// Intended for internal usage, maybe should be exported somewhere else and not exported to utils\nexport const isLen = (name: string) => /_len$/.test(name);\nexport const isTypeFelt = (type: string) => type === 'felt' || type === 'core::felt252';\nexport const isTypeArray = (type: string) =>\n  /\\*/.test(type) ||\n  type.startsWith('core::array::Array::') ||\n  type.startsWith('core::array::Span::');\nexport const isTypeTuple = (type: string) => /^\\(.*\\)$/i.test(type);\nexport const isTypeNamedTuple = (type: string) => /\\(.*\\)/i.test(type) && type.includes(':');\nexport const isTypeStruct = (type: string, structs: AbiStructs) => type in structs;\nexport const isTypeEnum = (type: string, enums: AbiEnums) => type in enums;\nexport const isTypeOption = (type: string) => type.startsWith('core::option::Option::');\nexport const isTypeResult = (type: string) => type.startsWith('core::result::Result::');\nexport const isTypeUint = (type: string) => Object.values(Uint).includes(type as Uint);\n// Legacy Export\nexport const isTypeUint256 = (type: string) => CairoUint256.isAbiType(type);\nexport const isTypeLiteral = (type: string) => Object.values(Literal).includes(type as Literal);\nexport const isTypeBool = (type: string) => type === 'core::bool';\nexport const isTypeContractAddress = (type: string) =>\n  type === 'core::starknet::contract_address::ContractAddress';\nexport const isTypeEthAddress = (type: string) =>\n  type === 'core::starknet::eth_address::EthAddress';\nexport const isTypeBytes31 = (type: string) => type === 'core::bytes_31::bytes31';\nexport const isTypeByteArray = (type: string) => type === 'core::byte_array::ByteArray';\nexport const isCairo1Type = (type: string) => type.includes('::');\nexport const getArrayType = (type: string) => {\n  if (isCairo1Type(type)) {\n    return type.substring(type.indexOf('<') + 1, type.lastIndexOf('>'));\n  }\n  return type.replace('*', '');\n};\n\n/**\n * Test if an ABI comes from a Cairo 1 contract\n * @param abi representing the interface of a Cairo contract\n * @returns TRUE if it is an ABI from a Cairo1 contract\n * @example\n * ```typescript\n * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);\n * ```\n */\nexport function isCairo1Abi(abi: Abi): boolean {\n  const { cairo } = getAbiContractVersion(abi);\n  if (cairo === undefined) {\n    throw Error('Unable to determine Cairo version');\n  }\n  return cairo === '1';\n}\n\n/**\n * Return ContractVersion (Abi version) based on Abi\n * or undefined for unknown version\n * @param abi\n * @returns string\n */\nexport function getAbiContractVersion(abi: Abi): ContractVersion {\n  // determine by interface for \"Cairo 1.2\"\n  if (abi.find((it) => it.type === 'interface')) {\n    return { cairo: '1', compiler: '2' };\n  }\n\n  // determine by function io types \"Cairo 1.1\" or \"Cairo 0.0\"\n  // find first function with inputs or outputs\n  const testFunction = abi.find(\n    (it) => it.type === 'function' && (it.inputs.length || it.outputs.length)\n  );\n  if (!testFunction) {\n    return { cairo: undefined, compiler: undefined };\n  }\n  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;\n  if (isCairo1Type(io[0].type)) {\n    return { cairo: '1', compiler: '1' };\n  }\n  return { cairo: '0', compiler: '0' };\n}\n\n/**\n * named tuple cairo type is described as js object {}\n * struct cairo type are described as js object {}\n * array cairo type are described as js array []\n */\n\n/**\n * Create Uint256 Cairo type (helper for common struct type)\n * @example\n * ```typescript\n * uint256('892349863487563453485768723498');\n * ```\n */\nexport const uint256 = (it: BigNumberish): Uint256 => {\n  return new CairoUint256(it).toUint256DecimalString();\n};\n\n/**\n * Create unnamed tuple Cairo type (helper same as common struct type)\n * @example\n * ```typescript\n * tuple(1, '0x101', 16);\n * ```\n */\nexport const tuple = (\n  ...args: (BigNumberish | object | boolean)[]\n): Record<number, BigNumberish | object | boolean> => ({ ...args });\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function felt(it: BigNumberish): string {\n  return CairoFelt(it);\n}\n","// TODO Convert to CairoFelt base on CairoUint256 and implement it in the codebase in the backward compatible manner\n\nimport { BigNumberish, isBigInt, isHex, isStringWholeNumber } from '../num';\nimport { encodeShortString, isShortString, isText } from '../shortString';\n\n/**\n * Create felt Cairo type (cairo type helper)\n * @returns format: felt-string\n */\nexport function CairoFelt(it: BigNumberish): string {\n  // BN or number\n  if (isBigInt(it) || (typeof it === 'number' && Number.isInteger(it))) {\n    return it.toString();\n  }\n  // string text\n  if (isText(it)) {\n    if (!isShortString(it as string))\n      throw new Error(\n        `${it} is a long string > 31 chars, felt can store short strings, split it to array of short strings`\n      );\n    const encoded = encodeShortString(it as string);\n    return BigInt(encoded).toString();\n  }\n  // hex string\n  if (typeof it === 'string' && isHex(it)) {\n    // toBN().toString\n    return BigInt(it).toString();\n  }\n  // string number (already converted), or unhandled type\n  if (typeof it === 'string' && isStringWholeNumber(it)) {\n    return it;\n  }\n  // bool to felt\n  if (typeof it === 'boolean') {\n    return `${+it}`;\n  }\n\n  throw new Error(`${it} can't be computed by felt()`);\n}\n","/* eslint-disable no-bitwise */\n/**\n * Singular class handling cairo u256 data type\n */\n\nimport { BigNumberish, Uint256 } from '../../types';\nimport { addHexPrefix } from '../encode';\nimport { CairoFelt } from './felt';\n\nexport const UINT_128_MAX = (1n << 128n) - 1n;\nexport const UINT_256_MAX = (1n << 256n) - 1n;\nexport const UINT_256_MIN = 0n;\nexport const UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;\nexport const UINT_256_LOW_MIN = 0n;\nexport const UINT_256_HIGH_MIN = 0n;\n\nexport class CairoUint256 {\n  public low: bigint;\n\n  public high: bigint;\n\n  static abiSelector = 'core::integer::u256';\n\n  /**\n   * Default constructor (Lib usage)\n   * @param bigNumberish BigNumberish value representing uin256\n   */\n  public constructor(bigNumberish: BigNumberish);\n  /**\n   * Direct props initialization (Api response)\n   */\n  public constructor(low: BigNumberish, high: BigNumberish);\n  /**\n   * Initialization from Uint256 object\n   */\n  public constructor(uint256: Uint256);\n\n  public constructor(...arr: any[]) {\n    if (typeof arr[0] === 'object' && arr.length === 1 && 'low' in arr[0] && 'high' in arr[0]) {\n      const props = CairoUint256.validateProps(arr[0].low, arr[0].high);\n      this.low = props.low;\n      this.high = props.high;\n    } else if (arr.length === 1) {\n      const bigInt = CairoUint256.validate(arr[0]);\n      this.low = bigInt & UINT_128_MAX;\n      this.high = bigInt >> 128n;\n    } else if (arr.length === 2) {\n      const props = CairoUint256.validateProps(arr[0], arr[1]);\n      this.low = props.low;\n      this.high = props.high;\n    } else {\n      throw Error('Incorrect constructor parameters');\n    }\n  }\n\n  /**\n   * Validate if BigNumberish can be represented as Unit256\n   */\n  static validate(bigNumberish: BigNumberish) {\n    const bigInt = BigInt(bigNumberish);\n    if (bigInt < UINT_256_MIN) throw Error('bigNumberish is smaller than UINT_256_MIN');\n    if (bigInt > UINT_256_MAX) throw new Error('bigNumberish is bigger than UINT_256_MAX');\n    return bigInt;\n  }\n\n  /**\n   * Validate if low and high can be represented as Unit256\n   */\n  static validateProps(low: BigNumberish, high: BigNumberish) {\n    const bigIntLow = BigInt(low);\n    const bigIntHigh = BigInt(high);\n    if (bigIntLow < UINT_256_LOW_MIN || bigIntLow > UINT_256_LOW_MAX) {\n      throw new Error('low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX');\n    }\n    if (bigIntHigh < UINT_256_HIGH_MIN || bigIntHigh > UINT_256_HIGH_MAX) {\n      throw new Error('high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX');\n    }\n    return { low: bigIntLow, high: bigIntHigh };\n  }\n\n  /**\n   * Check if BigNumberish can be represented as Unit256\n   */\n  static is(bigNumberish: BigNumberish) {\n    try {\n      CairoUint256.validate(bigNumberish);\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Check if provided abi type is this data type\n   */\n  static isAbiType(abiType: string) {\n    return abiType === CairoUint256.abiSelector;\n  }\n\n  /**\n   * Return bigint representation\n   */\n  toBigInt() {\n    return (this.high << 128n) + this.low;\n  }\n\n  /**\n   * Return Uint256 structure with HexString props\n   * {low: HexString, high: HexString}\n   */\n  toUint256HexString() {\n    return {\n      low: addHexPrefix(this.low.toString(16)),\n      high: addHexPrefix(this.high.toString(16)),\n    };\n  }\n\n  /**\n   * Return Uint256 structure with DecimalString props\n   * {low: DecString, high: DecString}\n   */\n  toUint256DecimalString() {\n    return {\n      low: this.low.toString(10),\n      high: this.high.toString(10),\n    };\n  }\n\n  /**\n   * Return api requests representation witch is felt array\n   */\n  toApiRequest() {\n    return [CairoFelt(this.low), CairoFelt(this.high)];\n  }\n}\n","export type CairoEnumRaw = {\n  [key: string]: any;\n};\n\n/**\n * Class to handle Cairo custom Enum\n * @param enumContent object containing the variants and its content. Example :\n *  {Success: 234, Warning: undefined, Error: undefined}.\n *  Only one variant with a value, object, array.\n * @returns an instance representing a Cairo custom Enum.\n * @example\n * ```typescript\n * const myCairoEnum = new CairoCustomEnum( {Success: undefined, Warning: \"0x7f32ea\", Error: undefined})\n * ```\n */\nexport class CairoCustomEnum {\n  /**\n   * direct readonly access to variants of the Cairo Custom Enum.\n   * @returns a value of type any\n   * @example\n   * ```typescript\n   * const successValue = myCairoEnum.variant.Success;\n   */\n  readonly variant: CairoEnumRaw;\n\n  /**\n   * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.\n   */\n  constructor(enumContent: CairoEnumRaw) {\n    const variantsList = Object.values(enumContent);\n    if (variantsList.length === 0) {\n      throw new Error('This Enum must have at least 1 variant');\n    }\n    const nbActiveVariants = variantsList.filter(\n      (content) => typeof content !== 'undefined'\n    ).length;\n    if (nbActiveVariants !== 1) {\n      throw new Error('This Enum must have exactly one active variant');\n    }\n    this.variant = enumContent;\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   */\n  public unwrap(): any {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== 'undefined');\n    if (typeof activeVariant === 'undefined') {\n      return undefined;\n    }\n    return activeVariant[1];\n  }\n\n  /**\n   *\n   * @returns the name of the valid variant of a Cairo custom Enum.\n   */\n  public activeVariant(): string {\n    const variants = Object.entries(this.variant);\n    const activeVariant = variants.find((item) => typeof item[1] !== 'undefined');\n    if (typeof activeVariant === 'undefined') {\n      return '';\n    }\n    return activeVariant[0];\n  }\n}\n","export enum CairoOptionVariant {\n  Some = 0,\n  None = 1,\n}\n\n/**\n * Class to handle Cairo Option\n * @param variant CairoOptionVariant.Some or CairoOptionVariant.None\n * @param someContent value of type T.\n * @returns an instance representing a Cairo Option.\n * @example\n * ```typescript\n * const myOption = new CairoOption<BigNumberish>(CairoOptionVariant.Some, \"0x54dda8\");\n * ```\n */\nexport class CairoOption<T> {\n  readonly Some?: T;\n\n  readonly None?: boolean;\n\n  constructor(variant: CairoOptionVariant, someContent?: T) {\n    if (!(variant in CairoOptionVariant)) {\n      throw new Error('Wrong variant : should be CairoOptionVariant.Some or .None.');\n    }\n    if (variant === CairoOptionVariant.Some) {\n      if (typeof someContent === 'undefined') {\n        throw new Error(\n          'The creation of a Cairo Option with \"Some\" variant needs a content as input.'\n        );\n      }\n      this.Some = someContent;\n      this.None = undefined;\n    } else {\n      this.Some = undefined;\n      this.None = true;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo custom Enum.\n   *  If None, returns 'undefined'.\n   */\n  public unwrap(): T | undefined {\n    if (this.None) {\n      return undefined;\n    }\n    return this.Some;\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isSome'.\n   */\n  public isSome(): boolean {\n    return !(typeof this.Some === 'undefined');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isNone'.\n   */\n  public isNone(): boolean {\n    return this.None === true;\n  }\n}\n","export enum CairoResultVariant {\n  Ok = 0,\n  Err = 1,\n}\n\n/**\n * Class to handle Cairo Result\n * @param variant CairoResultVariant.Ok or CairoResultVariant.Err\n * @param resultContent value of type T or U.\n * @returns an instance representing a Cairo Result.\n * @example\n * ```typescript\n * const myOption = new CairoResult<BigNumberish, CustomError>(CairoResultVariant.Ok, \"0x54dda8\");\n * ```\n */\nexport class CairoResult<T, U> {\n  readonly Ok?: T;\n\n  readonly Err?: U;\n\n  constructor(variant: CairoResultVariant, resultContent: T | U) {\n    if (!(variant in CairoResultVariant)) {\n      throw new Error('Wrong variant : should be CairoResultVariant.Ok or .Err.');\n    }\n    if (variant === CairoResultVariant.Ok) {\n      this.Ok = resultContent as T;\n      this.Err = undefined;\n    } else {\n      this.Ok = undefined;\n      this.Err = resultContent as U;\n    }\n  }\n\n  /**\n   *\n   * @returns the content of the valid variant of a Cairo Result.\n   */\n  public unwrap(): T | U {\n    if (typeof this.Ok !== 'undefined') {\n      return this.Ok;\n    }\n    if (typeof this.Err !== 'undefined') {\n      return this.Err;\n    }\n    throw new Error('Both Result.Ok and .Err are undefined. Not authorized.');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'Ok'.\n   */\n  public isOk(): boolean {\n    return !(typeof this.Ok === 'undefined');\n  }\n\n  /**\n   *\n   * @returns true if the valid variant is 'isErr'.\n   */\n  public isErr(): boolean {\n    return !(typeof this.Err === 'undefined');\n  }\n}\n","import { isBigInt } from '../num';\nimport { decodeShortString } from '../shortString';\n\nconst guard = {\n  isBN: (data: any, type: any, key: any) => {\n    if (!isBigInt(data[key]))\n      throw new Error(\n        `Data and formatter mismatch on ${key}:${type[key]}, expected response data ${key}:${\n          data[key]\n        } to be BN instead it is ${typeof data[key]}`\n      );\n  },\n  unknown: (data: any, type: any, key: any) => {\n    throw new Error(`Unhandled formatter type on ${key}:${type[key]} for data ${key}:${data[key]}`);\n  },\n};\n\nexport default function formatter(data: any, type: any, sameType?: any) {\n  // match data element with type element\n  return Object.entries(data).reduce((acc, [key, value]: [any, any]) => {\n    const elType = sameType ?? type[key];\n\n    if (!(key in type) && !sameType) {\n      // no type definition for element return original element\n      acc[key] = value;\n      return acc;\n    }\n\n    if (elType === 'string') {\n      if (Array.isArray(data[key])) {\n        // long string (felt*)\n        const arrayStr = formatter(\n          data[key],\n          data[key].map((_: any) => elType)\n        );\n        acc[key] = Object.values(arrayStr).join('');\n        return acc;\n      }\n      guard.isBN(data, type, key);\n      acc[key] = decodeShortString(value);\n      return acc;\n    }\n    if (elType === 'number') {\n      guard.isBN(data, type, key);\n      acc[key] = Number(value);\n      return acc;\n    }\n    if (typeof elType === 'function') {\n      acc[key] = elType(value);\n      return acc;\n    }\n    if (Array.isArray(elType)) {\n      const arrayObj = formatter(data[key], elType, elType[0]);\n      acc[key] = Object.values(arrayObj);\n      return acc;\n    }\n    if (typeof elType === 'object') {\n      acc[key] = formatter(data[key], elType);\n      return acc;\n    }\n\n    guard.unknown(data, type, key);\n    return acc;\n  }, {} as any);\n}\n","import { Abi, FunctionAbi } from '../../../types';\nimport { isLen } from '../cairo';\nimport { AbiParserInterface } from './interface';\n\nexport class AbiParser1 implements AbiParserInterface {\n  abi: Abi;\n\n  constructor(abi: Abi) {\n    this.abi = abi;\n  }\n\n  /**\n   * abi method inputs length without '_len' inputs\n   * cairo 0 reducer\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.reduce((acc, input) => (!isLen(input.name) ? acc + 1 : acc), 0);\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    return this.abi.find((it) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat() {\n    return this.abi;\n  }\n}\n","import { Abi, FunctionAbi } from '../../../types';\nimport { AbiParserInterface } from './interface';\n\nexport class AbiParser2 implements AbiParserInterface {\n  abi: Abi;\n\n  constructor(abi: Abi) {\n    this.abi = abi;\n  }\n\n  /**\n   * abi method inputs length\n   * @param abiMethod FunctionAbi\n   * @returns number\n   */\n  public methodInputsLength(abiMethod: FunctionAbi) {\n    return abiMethod.inputs.length;\n  }\n\n  /**\n   * get method definition from abi\n   * @param name string\n   * @returns FunctionAbi | undefined\n   */\n  public getMethod(name: string): FunctionAbi | undefined {\n    const intf = this.abi.find((it) => it.type === 'interface');\n    return intf.items.find((it: any) => it.name === name);\n  }\n\n  /**\n   * Get Abi in legacy format\n   * @returns Abi\n   */\n  public getLegacyFormat(): Abi {\n    return this.abi.flatMap((e) => {\n      if (e.type === 'interface') {\n        return e.items;\n      }\n      return e;\n    });\n  }\n}\n","import { Abi, FunctionAbi, RawArgs } from '../../../types';\nimport { isCairo1Abi } from '../cairo';\nimport { AbiParserInterface } from './interface';\nimport { AbiParser1 } from './parser-0-1.1.0';\nimport { AbiParser2 } from './parser-2.0.0';\n\nexport function createAbiParser(abi: Abi): AbiParserInterface {\n  const version = getAbiVersion(abi);\n  if (version === 0 || version === 1) {\n    return new AbiParser1(abi);\n  }\n  if (version === 2) {\n    return new AbiParser2(abi);\n  }\n  throw Error(`Unsupported ABI version ${version}`);\n}\n\nexport function getAbiVersion(abi: Abi) {\n  if (abi.find((it) => it.type === 'interface')) return 2;\n  if (isCairo1Abi(abi)) return 1;\n  return 0;\n}\n\nexport function isNoConstructorValid(\n  method: string,\n  argsCalldata: RawArgs,\n  abiMethod?: FunctionAbi\n) {\n  // No constructor in abi and validly empty args\n  return method === 'constructor' && !abiMethod && !argsCalldata.length;\n}\n","/* eslint-disable no-plusplus */\nimport { isCairo1Type, isTypeNamedTuple } from './cairo';\n\nfunction parseNamedTuple(namedTuple: string): any {\n  const name = namedTuple.substring(0, namedTuple.indexOf(':'));\n  const type = namedTuple.substring(name.length + ':'.length);\n  return { name, type };\n}\n\nfunction parseSubTuple(s: string) {\n  if (!s.includes('(')) return { subTuple: [], result: s };\n  const subTuple: string[] = [];\n  let result = '';\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === '(') {\n      let counter = 1;\n      const lBracket = i;\n      i++;\n      while (counter) {\n        if (s[i] === ')') counter--;\n        if (s[i] === '(') counter++;\n        i++;\n      }\n      subTuple.push(s.substring(lBracket, i));\n      result += ' ';\n      i--;\n    } else {\n      result += s[i];\n    }\n    i++;\n  }\n\n  return {\n    subTuple,\n    result,\n  };\n}\n\nfunction extractCairo0Tuple(type: string) {\n  const cleanType = type.replace(/\\s/g, '').slice(1, -1); // remove first lvl () and spaces\n\n  // Decompose subTuple\n  const { subTuple, result } = parseSubTuple(cleanType);\n\n  // Recompose subTuple\n  let recomposed = result.split(',').map((it) => {\n    return subTuple.length ? it.replace(' ', subTuple.shift() as string) : it;\n  });\n\n  // Parse named tuple\n  if (isTypeNamedTuple(type)) {\n    recomposed = recomposed.reduce((acc, it) => {\n      return acc.concat(parseNamedTuple(it));\n    }, []);\n  }\n\n  return recomposed;\n}\n\nfunction getClosureOffset(input: string, open: string, close: string): number {\n  for (let i = 0, counter = 0; i < input.length; i++) {\n    if (input[i] === open) {\n      counter++;\n    } else if (input[i] === close && --counter === 0) {\n      return i;\n    }\n  }\n  return Number.POSITIVE_INFINITY;\n}\n\nfunction extractCairo1Tuple(type: string): string[] {\n  // un-named tuples support\n  const input = type.slice(1, -1); // remove first lvl ()\n  const result: string[] = [];\n\n  let currentIndex: number = 0;\n  let limitIndex: number;\n\n  while (currentIndex < input.length) {\n    switch (true) {\n      // Tuple\n      case input[currentIndex] === '(': {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '(', ')') + 1;\n        break;\n      }\n      case input.startsWith('core::result::Result::<', currentIndex) ||\n        input.startsWith('core::array::Array::<', currentIndex) ||\n        input.startsWith('core::option::Option::<', currentIndex): {\n        limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '<', '>') + 1;\n        break;\n      }\n      default: {\n        const commaIndex = input.indexOf(',', currentIndex);\n        limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;\n      }\n    }\n\n    result.push(input.slice(currentIndex, limitIndex));\n    currentIndex = limitIndex + 2; // +2 to skip ', '\n  }\n\n  return result;\n}\n\n/**\n * Convert tuple string definition into object like definition\n * @param type tuple string definition\n * @returns object like tuple\n */\nexport default function extractTupleMemberTypes(type: string): (string | object)[] {\n  if (isCairo1Type(type)) {\n    return extractCairo1Tuple(type);\n  }\n  return extractCairo0Tuple(type);\n}\n","import { AbiEntry, AbiEnums, AbiStructs, CairoEnum, RawArgsObject } from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeByteArray,\n  isTypeEnum,\n  isTypeEthAddress,\n  isTypeOption,\n  isTypeResult,\n  isTypeStruct,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\nfunction errorU256(key: string) {\n  return Error(\n    `Your object includes the property : ${key}, containing an Uint256 object without the 'low' and 'high' keys.`\n  );\n}\nexport default function orderPropsByAbi(\n  unorderedObject: RawArgsObject,\n  abiOfObject: AbiEntry[],\n  structs: AbiStructs,\n  enums: AbiEnums\n): object {\n  const orderInput = (unorderedItem: any, abiType: string): any => {\n    if (isTypeArray(abiType)) {\n      return orderArray(unorderedItem, abiType);\n    }\n    if (isTypeEnum(abiType, enums)) {\n      const abiObj = enums[abiType];\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderEnum(unorderedItem, abiObj);\n    }\n    if (isTypeTuple(abiType)) {\n      return orderTuple(unorderedItem, abiType);\n    }\n    if (isTypeEthAddress(abiType)) {\n      return unorderedItem;\n    }\n    if (isTypeByteArray(abiType)) {\n      return unorderedItem;\n    }\n    if (CairoUint256.isAbiType(abiType)) {\n      const u256 = unorderedItem;\n      if (typeof u256 !== 'object') {\n        // BigNumberish --> just copy\n        return u256;\n      }\n      if (!('low' in u256 && 'high' in u256)) {\n        throw errorU256(abiType);\n      }\n      return { low: u256.low, high: u256.high };\n    }\n    if (isTypeStruct(abiType, structs)) {\n      const abiOfStruct = structs[abiType].members;\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return orderStruct(unorderedItem, abiOfStruct);\n    }\n    // literals\n    return unorderedItem;\n  };\n\n  const orderStruct = (unorderedObject2: RawArgsObject, abiObject: AbiEntry[]): object => {\n    const orderedObject2 = abiObject.reduce((orderedObject, abiParam) => {\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, abiParam.name, {\n          enumerable: true,\n          value: value ?? unorderedObject2[abiParam.name],\n        });\n\n      if (unorderedObject2[abiParam.name] === 'undefined') {\n        if (isCairo1Type(abiParam.type) || !isLen(abiParam.name)) {\n          throw Error(`Your object needs a property with key : ${abiParam.name} .`);\n        }\n      }\n      setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  };\n\n  function orderArray(myArray: Array<any> | string, abiParam: string): Array<any> | string {\n    const typeInArray = getArrayType(abiParam);\n    if (typeof myArray === 'string') {\n      return myArray; // longstring\n    }\n    return myArray.map((myElem) => orderInput(myElem, typeInArray));\n  }\n\n  function orderTuple(unorderedObject2: RawArgsObject, abiParam: string): object {\n    const typeList = extractTupleMemberTypes(abiParam);\n    const orderedObject2 = typeList.reduce((orderedObject: object, abiTypeCairoX: any, index) => {\n      const myObjKeys: string[] = Object.keys(unorderedObject2);\n      const setProperty = (value?: any) =>\n        Object.defineProperty(orderedObject, index.toString(), {\n          enumerable: true,\n          value: value ?? unorderedObject2[myObjKeys[index]],\n        });\n      const abiType: string = abiTypeCairoX?.type ? abiTypeCairoX.type : abiTypeCairoX; // Named tuple, or tuple\n      setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));\n      return orderedObject;\n    }, {});\n    return orderedObject2;\n  }\n\n  const orderEnum = (unorderedObject2: CairoEnum, abiObject: AbiEntry): CairoEnum => {\n    if (isTypeResult(abiObject.name)) {\n      const unorderedResult = unorderedObject2 as CairoResult<any, any>;\n      const resultOkType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf(',')\n      );\n      const resultErrType: string = abiObject.name.substring(\n        abiObject.name.indexOf(',') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedResult.isOk()) {\n        return new CairoResult<any, any>(\n          CairoResultVariant.Ok,\n          orderInput(unorderedObject2.unwrap(), resultOkType)\n        );\n      }\n      return new CairoResult<any, any>(\n        CairoResultVariant.Err,\n        orderInput(unorderedObject2.unwrap(), resultErrType)\n      );\n    }\n    if (isTypeOption(abiObject.name)) {\n      const unorderedOption = unorderedObject2 as CairoOption<any>;\n      const resultSomeType: string = abiObject.name.substring(\n        abiObject.name.indexOf('<') + 1,\n        abiObject.name.lastIndexOf('>')\n      );\n      if (unorderedOption.isSome()) {\n        return new CairoOption<any>(\n          CairoOptionVariant.Some,\n          orderInput(unorderedOption.unwrap(), resultSomeType)\n        );\n      }\n      // none(())\n      return new CairoOption<any>(CairoOptionVariant.None, {});\n    }\n    // custom Enum\n    const unorderedCustomEnum = unorderedObject2 as CairoCustomEnum;\n    const variants = Object.entries(unorderedCustomEnum.variant);\n    const newEntries = variants.map((variant) => {\n      if (typeof variant[1] === 'undefined') {\n        return variant;\n      }\n      const variantType: string = abiObject.type.substring(\n        abiObject.type.lastIndexOf('<') + 1,\n        abiObject.type.lastIndexOf('>')\n      );\n      if (variantType === '()') {\n        return variant;\n      }\n      return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];\n    });\n    return new CairoCustomEnum(Object.fromEntries(newEntries));\n  };\n\n  // Order Call Parameters\n  const finalOrderedObject = abiOfObject.reduce((orderedObject, abiParam) => {\n    const setProperty = (value: any) =>\n      Object.defineProperty(orderedObject, abiParam.name, {\n        enumerable: true,\n        value,\n      });\n    if (isLen(abiParam.name) && !isCairo1Type(abiParam.type)) {\n      return orderedObject;\n    }\n    setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));\n    return orderedObject;\n  }, {});\n  return finalOrderedObject;\n}\n","import {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  ByteArray,\n  CairoEnum,\n  ParsedStruct,\n  Tupled,\n} from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { encodeShortString, isText, splitLongString } from '../shortString';\nimport { byteArrayFromString } from './byteArray';\nimport {\n  felt,\n  getArrayType,\n  isTypeArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeOption,\n  isTypeResult,\n  isTypeStruct,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * parse base types\n * @param type type from abi\n * @param val value provided\n * @returns string | string[]\n */\nfunction parseBaseTypes(type: string, val: BigNumberish) {\n  switch (true) {\n    case CairoUint256.isAbiType(type):\n      return new CairoUint256(val).toApiRequest();\n    case isTypeBytes31(type):\n      return encodeShortString(val.toString());\n    default:\n      return felt(val);\n  }\n}\n\n/**\n * Parse tuple type string to array of known objects\n * @param element request element\n * @param typeStr tuple type string\n * @returns Tupled[]\n */\nfunction parseTuple(element: object, typeStr: string): Tupled[] {\n  const memberTypes = extractTupleMemberTypes(typeStr);\n  const elements = Object.values(element);\n\n  if (elements.length !== memberTypes.length) {\n    throw Error(\n      `ParseTuple: provided and expected abi tuple size do not match.\n      provided: ${elements} \n      expected: ${memberTypes}`\n    );\n  }\n\n  return memberTypes.map((it: any, dx: number) => {\n    return {\n      element: elements[dx],\n      type: it.type ?? it,\n    };\n  });\n}\n\nfunction parseByteArray(element: string): string[] {\n  const myByteArray: ByteArray = byteArrayFromString(element);\n  return [\n    myByteArray.data.length.toString(),\n    ...myByteArray.data.map((bn) => bn.toString()),\n    myByteArray.pending_word.toString(),\n    myByteArray.pending_word_len.toString(),\n  ];\n}\n\n/**\n * Deep parse of the object that has been passed to the method\n *\n * @param element - element that needs to be parsed\n * @param type  - name of the method\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n */\nfunction parseCalldataValue(\n  element:\n    | ParsedStruct\n    | BigNumberish\n    | BigNumberish[]\n    | CairoOption<any>\n    | CairoResult<any, any>\n    | CairoEnum,\n  type: string,\n  structs: AbiStructs,\n  enums: AbiEnums\n): string | string[] {\n  if (element === undefined) {\n    throw Error(`Missing parameter for type ${type}`);\n  }\n\n  // value is Array\n  if (Array.isArray(element)) {\n    const result: string[] = [];\n    result.push(felt(element.length)); // Add length to array\n    const arrayType = getArrayType(type);\n\n    return element.reduce((acc, it) => {\n      return acc.concat(parseCalldataValue(it, arrayType, structs, enums));\n    }, result);\n  }\n\n  // checking if the passed element is struct\n  if (structs[type] && structs[type].members.length) {\n    if (CairoUint256.isAbiType(type)) {\n      return new CairoUint256(element as any).toApiRequest();\n    }\n\n    if (type === 'core::starknet::eth_address::EthAddress')\n      return parseBaseTypes(type, element as BigNumberish);\n\n    if (type === 'core::byte_array::ByteArray') return parseByteArray(element as string);\n\n    const { members } = structs[type];\n    const subElement = element as any;\n\n    return members.reduce((acc, it: AbiEntry) => {\n      return acc.concat(parseCalldataValue(subElement[it.name], it.type, structs, enums));\n    }, [] as string[]);\n  }\n  // check if abi element is tuple\n  if (isTypeTuple(type)) {\n    const tupled = parseTuple(element as object, type);\n\n    return tupled.reduce((acc, it: Tupled) => {\n      const parsedData = parseCalldataValue(it.element, it.type, structs, enums);\n      return acc.concat(parsedData);\n    }, [] as string[]);\n  }\n  // check if u256 C1v0\n  if (CairoUint256.isAbiType(type)) {\n    return new CairoUint256(element as any).toApiRequest();\n  }\n  // check if Enum\n  if (isTypeEnum(type, enums)) {\n    const { variants } = enums[type];\n    // Option Enum\n    if (isTypeOption(type)) {\n      const myOption = element as CairoOption<any>;\n      if (myOption.isSome()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Some');\n        if (typeof listTypeVariant === 'undefined') {\n          throw Error(`Error in abi : Option has no 'Some' variant.`);\n        }\n        const typeVariantSome = listTypeVariant.type;\n        if (typeVariantSome === '()') {\n          return CairoOptionVariant.Some.toString();\n        }\n        const parsedParameter = parseCalldataValue(\n          myOption.unwrap(),\n          typeVariantSome,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter)) {\n          return [CairoOptionVariant.Some.toString(), ...parsedParameter];\n        }\n        return [CairoOptionVariant.Some.toString(), parsedParameter];\n      }\n      return CairoOptionVariant.None.toString();\n    }\n    // Result Enum\n    if (isTypeResult(type)) {\n      const myResult = element as CairoResult<any, any>;\n      if (myResult.isOk()) {\n        const listTypeVariant = variants.find((variant) => variant.name === 'Ok');\n        if (typeof listTypeVariant === 'undefined') {\n          throw Error(`Error in abi : Result has no 'Ok' variant.`);\n        }\n        const typeVariantOk = listTypeVariant.type;\n        if (typeVariantOk === '()') {\n          return CairoResultVariant.Ok.toString();\n        }\n        const parsedParameter = parseCalldataValue(\n          myResult.unwrap(),\n          typeVariantOk,\n          structs,\n          enums\n        );\n        if (Array.isArray(parsedParameter)) {\n          return [CairoResultVariant.Ok.toString(), ...parsedParameter];\n        }\n        return [CairoResultVariant.Ok.toString(), parsedParameter];\n      }\n      // is Result::Err\n      const listTypeVariant = variants.find((variant) => variant.name === 'Err');\n      if (typeof listTypeVariant === 'undefined') {\n        throw Error(`Error in abi : Result has no 'Err' variant.`);\n      }\n      const typeVariantErr = listTypeVariant.type;\n      if (typeVariantErr === '()') {\n        return CairoResultVariant.Err.toString();\n      }\n      const parsedParameter = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);\n      if (Array.isArray(parsedParameter)) {\n        return [CairoResultVariant.Err.toString(), ...parsedParameter];\n      }\n      return [CairoResultVariant.Err.toString(), parsedParameter];\n    }\n    // Custom Enum\n    const myEnum = element as CairoCustomEnum;\n    const activeVariant: string = myEnum.activeVariant();\n    const listTypeVariant = variants.find((variant) => variant.name === activeVariant);\n    if (typeof listTypeVariant === 'undefined') {\n      throw Error(`Not find in abi : Enum has no '${activeVariant}' variant.`);\n    }\n    const typeActiveVariant = listTypeVariant.type;\n    const numActiveVariant = variants.findIndex((variant) => variant.name === activeVariant); // can not fail due to check of listTypeVariant\n    if (typeActiveVariant === '()') {\n      return numActiveVariant.toString();\n    }\n    const parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);\n    if (Array.isArray(parsedParameter)) {\n      return [numActiveVariant.toString(), ...parsedParameter];\n    }\n    return [numActiveVariant.toString(), parsedParameter];\n  }\n\n  if (typeof element === 'object') {\n    throw Error(`Parameter ${element} do not align with abi parameter ${type}`);\n  }\n  return parseBaseTypes(type, element);\n}\n\n/**\n * Parse one field of the calldata by using input field from the abi for that method\n *\n * @param argsIterator - Iterator<any> for value of the field\n * @param input  - input(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param enums - enums from abi\n * @return {string | string[]} - parsed arguments in format that contract is expecting\n */\nexport function parseCalldataField(\n  argsIterator: Iterator<any>,\n  input: AbiEntry,\n  structs: AbiStructs,\n  enums: AbiEnums\n): string | string[] {\n  const { name, type } = input;\n  let { value } = argsIterator.next();\n\n  switch (true) {\n    // Array\n    case isTypeArray(type):\n      if (!Array.isArray(value) && !isText(value)) {\n        throw Error(`ABI expected parameter ${name} to be array or long string, got ${value}`);\n      }\n      if (typeof value === 'string') {\n        // long string match cairo felt*\n        value = splitLongString(value);\n      }\n      return parseCalldataValue(value, input.type, structs, enums);\n\n    case type === 'core::starknet::eth_address::EthAddress':\n      return parseBaseTypes(type, value);\n    // Struct or Tuple\n    case isTypeStruct(type, structs) || isTypeTuple(type) || CairoUint256.isAbiType(type):\n      return parseCalldataValue(value as ParsedStruct | BigNumberish[], type, structs, enums);\n\n    // Enums\n    case isTypeEnum(type, enums):\n      return parseCalldataValue(\n        value as CairoOption<any> | CairoResult<any, any> | CairoEnum,\n        type,\n        structs,\n        enums\n      );\n\n    // Felt or unhandled\n    default:\n      return parseBaseTypes(type, value);\n  }\n}\n","/* eslint-disable no-case-declarations */\nimport {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  Args,\n  BigNumberish,\n  ByteArray,\n  CairoEnum,\n  EventEntry,\n  ParsedStruct,\n} from '../../types';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { toHex } from '../num';\nimport { decodeShortString } from '../shortString';\nimport { stringFromByteArray } from './byteArray';\nimport {\n  getArrayType,\n  isCairo1Type,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeByteArray,\n  isTypeEnum,\n  isTypeTuple,\n} from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoEnumRaw,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport extractTupleMemberTypes from './tuple';\n\n/**\n * Parse base types\n * @param type type of element\n * @param it iterator\n * @returns bigint | boolean\n */\nfunction parseBaseTypes(type: string, it: Iterator<string>) {\n  let temp;\n  switch (true) {\n    case isTypeBool(type):\n      temp = it.next().value;\n      return Boolean(BigInt(temp));\n    case CairoUint256.isAbiType(type):\n      const low = it.next().value;\n      const high = it.next().value;\n      return new CairoUint256(low, high).toBigInt();\n    case type === 'core::starknet::eth_address::EthAddress':\n      temp = it.next().value;\n      return BigInt(temp);\n    case type === 'core::bytes_31::bytes31':\n      temp = it.next().value;\n      return decodeShortString(temp);\n    default:\n      temp = it.next().value;\n      return BigInt(temp);\n  }\n}\n\n/**\n * Parse of the response elements that are converted to Object (Struct) by using the abi\n *\n * @param responseIterator - iterator of the response\n * @param element - element of the field {name: string, type: string}\n * @param structs - structs from abi\n * @return {any} - parsed arguments in format that contract is expecting\n */\nfunction parseResponseValue(\n  responseIterator: Iterator<string>,\n  element: { name: string; type: string },\n  structs?: AbiStructs,\n  enums?: AbiEnums\n): BigNumberish | ParsedStruct | boolean | any[] | CairoEnum {\n  if (element.type === '()') {\n    return {};\n  }\n  // type uint256 struct (c1v2)\n  if (CairoUint256.isAbiType(element.type)) {\n    const low = responseIterator.next().value;\n    const high = responseIterator.next().value;\n    return new CairoUint256(low, high).toBigInt();\n  }\n\n  // type C1 ByteArray struct, representing a LongString\n  if (isTypeByteArray(element.type)) {\n    const parsedBytes31Arr: BigNumberish[] = [];\n    const bytes31ArrLen = BigInt(responseIterator.next().value);\n    while (parsedBytes31Arr.length < bytes31ArrLen) {\n      parsedBytes31Arr.push(toHex(responseIterator.next().value));\n    }\n    const pending_word = toHex(responseIterator.next().value);\n    const pending_word_len = BigInt(responseIterator.next().value);\n    const myByteArray: ByteArray = {\n      data: parsedBytes31Arr,\n      pending_word,\n      pending_word_len,\n    };\n    return stringFromByteArray(myByteArray);\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el: AbiEntry = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // type struct\n  if (structs && element.type in structs && structs[element.type]) {\n    if (element.type === 'core::starknet::eth_address::EthAddress') {\n      return parseBaseTypes(element.type, responseIterator);\n    }\n    return structs[element.type].members.reduce((acc, el) => {\n      acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type Enum (only CustomEnum)\n  if (enums && element.type in enums && enums[element.type]) {\n    const variantNum: number = Number(responseIterator.next().value); // get variant number\n    const rawEnum = enums[element.type].variants.reduce((acc, variant, num) => {\n      if (num === variantNum) {\n        acc[variant.name] = parseResponseValue(\n          responseIterator,\n          { name: '', type: variant.type },\n          structs,\n          enums\n        );\n        return acc;\n      }\n      acc[variant.name] = undefined;\n      return acc;\n    }, {} as CairoEnumRaw);\n    // Option\n    if (element.type.startsWith('core::option::Option')) {\n      const content = variantNum === CairoOptionVariant.Some ? rawEnum.Some : undefined;\n      return new CairoOption<Object>(variantNum, content);\n    }\n    // Result\n    if (element.type.startsWith('core::result::Result')) {\n      let content: Object;\n      if (variantNum === CairoResultVariant.Ok) {\n        content = rawEnum.Ok;\n      } else {\n        content = rawEnum.Err;\n      }\n      return new CairoResult<Object, Object>(variantNum, content);\n    }\n    // Cairo custom Enum\n    const customEnum = new CairoCustomEnum(rawEnum);\n    return customEnum;\n  }\n\n  // type tuple\n  if (isTypeTuple(element.type)) {\n    const memberTypes = extractTupleMemberTypes(element.type);\n    return memberTypes.reduce((acc, it: any, idx) => {\n      const name = it?.name ? it.name : idx;\n      const type = it?.type ? it.type : it;\n      const el = { name, type };\n      acc[name] = parseResponseValue(responseIterator, el, structs, enums);\n      return acc;\n    }, {} as any);\n  }\n\n  // type c1 array\n  if (isTypeArray(element.type)) {\n    // eslint-disable-next-line no-case-declarations\n    const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n    const el = { name: '', type: getArrayType(element.type) };\n    const len = BigInt(responseIterator.next().value); // get length\n    while (parsedDataArr.length < len) {\n      parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));\n    }\n    return parsedDataArr;\n  }\n\n  // base type\n  return parseBaseTypes(element.type, responseIterator);\n}\n\n/**\n * Parse elements of the response and structuring them into one field by using output property from the abi for that method\n *\n * @param responseIterator - iterator of the response\n * @param output - output(field) information from the abi that will be used to parse the data\n * @param structs - structs from abi\n * @param parsedResult\n * @return - parsed response corresponding to the abi structure of the field\n */\nexport default function responseParser(\n  responseIterator: Iterator<string>,\n  output: AbiEntry | EventEntry,\n  structs?: AbiStructs,\n  enums?: AbiEnums,\n  parsedResult?: Args | ParsedStruct\n): any {\n  const { name, type } = output;\n  let temp;\n\n  switch (true) {\n    case isLen(name):\n      temp = responseIterator.next().value;\n      return BigInt(temp);\n\n    case (structs && type in structs) || isTypeTuple(type):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case enums && isTypeEnum(type, enums):\n      return parseResponseValue(responseIterator, output, structs, enums);\n\n    case isTypeArray(type):\n      // C1 Array\n      if (isCairo1Type(type)) {\n        return parseResponseValue(responseIterator, output, structs, enums);\n      }\n      // C0 Array\n      // eslint-disable-next-line no-case-declarations\n      const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];\n      if (parsedResult && parsedResult[`${name}_len`]) {\n        const arrLen = parsedResult[`${name}_len`] as number;\n        while (parsedDataArr.length < arrLen) {\n          parsedDataArr.push(\n            parseResponseValue(\n              responseIterator,\n              { name, type: output.type.replace('*', '') },\n              structs,\n              enums\n            )\n          );\n        }\n      }\n      return parsedDataArr;\n\n    default:\n      return parseBaseTypes(type, responseIterator);\n  }\n}\n","/**\n * Validate cairo contract method arguments\n * Flow: Determine type from abi and than validate against parameter\n */\nimport {\n  AbiEntry,\n  AbiEnums,\n  AbiStructs,\n  BigNumberish,\n  FunctionAbi,\n  Literal,\n  Uint,\n} from '../../types';\nimport assert from '../assert';\nimport { CairoUint256 } from '../cairoDataTypes/uint256';\nimport { isHex, toBigInt } from '../num';\nimport { isLongText } from '../shortString';\nimport {\n  getArrayType,\n  isLen,\n  isTypeArray,\n  isTypeBool,\n  isTypeByteArray,\n  isTypeBytes31,\n  isTypeEnum,\n  isTypeFelt,\n  isTypeLiteral,\n  isTypeOption,\n  isTypeResult,\n  isTypeStruct,\n  isTypeTuple,\n  isTypeUint,\n} from './cairo';\n\nconst validateFelt = (parameter: any, input: AbiEntry) => {\n  assert(\n    typeof parameter === 'string' || typeof parameter === 'number' || typeof parameter === 'bigint',\n    `Validate: arg ${input.name} should be a felt typed as (String, Number or BigInt)`\n  );\n  if (typeof parameter === 'string' && !isHex(parameter)) return; // shortstring\n  const param = BigInt(parameter.toString(10));\n  assert(\n    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266\n    param >= 0n && param <= 2n ** 252n - 1n,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n  );\n};\n\nconst validateBytes31 = (parameter: any, input: AbiEntry) => {\n  assert(typeof parameter === 'string', `Validate: arg ${input.name} should be a string.`);\n  assert(\n    parameter.length < 32,\n    `Validate: arg ${input.name} cairo typed ${input.type} should be a string of less than 32 characters.`\n  );\n};\n\nconst validateByteArray = (parameter: any, input: AbiEntry) => {\n  assert(typeof parameter === 'string', `Validate: arg ${input.name} should be a string.`);\n};\n\nconst validateUint = (parameter: any, input: AbiEntry) => {\n  if (typeof parameter === 'number') {\n    assert(\n      parameter <= Number.MAX_SAFE_INTEGER,\n      `Validation: Parameter is to large to be typed as Number use (BigInt or String)`\n    );\n  }\n  assert(\n    typeof parameter === 'string' ||\n      typeof parameter === 'number' ||\n      typeof parameter === 'bigint' ||\n      (typeof parameter === 'object' && 'low' in parameter && 'high' in parameter),\n    `Validate: arg ${input.name} of cairo type ${\n      input.type\n    } should be type (String, Number or BigInt), but is ${typeof parameter} ${parameter}.`\n  );\n  const param =\n    typeof parameter === 'object' ? new CairoUint256(parameter).toBigInt() : toBigInt(parameter);\n\n  switch (input.type) {\n    case Uint.u8:\n      assert(\n        param >= 0n && param <= 255n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0 - 255]`\n      );\n      break;\n\n    case Uint.u16:\n      assert(\n        param >= 0n && param <= 65535n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 65535]`\n      );\n      break;\n\n    case Uint.u32:\n      assert(\n        param >= 0n && param <= 4294967295n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 4294967295]`\n      );\n      break;\n\n    case Uint.u64:\n      assert(\n        param >= 0n && param <= 2n ** 64n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^64-1]`\n      );\n      break;\n\n    case Uint.u128:\n      assert(\n        param >= 0n && param <= 2n ** 128n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^128-1]`\n      );\n      break;\n\n    case Uint.u256:\n      assert(\n        param >= 0n && param <= 2n ** 256n - 1n,\n        `Validate: arg ${input.name} is ${input.type} 0 - 2^256-1`\n      );\n      break;\n\n    case Literal.ClassHash:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n\n    case Literal.ContractAddress:\n      assert(\n        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245\n        param >= 0n && param <= 2n ** 252n - 1n,\n        `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^252-1]`\n      );\n      break;\n    default:\n      break;\n  }\n};\n\nconst validateBool = (parameter: any, input: AbiEntry) => {\n  assert(\n    typeof parameter === 'boolean',\n    `Validate: arg ${input.name} of cairo type ${input.type} should be type (Boolean)`\n  );\n};\n\nconst validateStruct = (parameter: any, input: AbiEntry, structs: AbiStructs) => {\n  // c1v2 uint256 in struct\n  if (input.type === Uint.u256) {\n    validateUint(parameter, input);\n    return;\n  }\n\n  if (input.type === 'core::starknet::eth_address::EthAddress') {\n    assert(\n      typeof parameter !== 'object',\n      `EthAddress type is waiting a BigNumberish. Got ${parameter}`\n    );\n    const param = BigInt(parameter.toString(10));\n    assert(\n      // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259\n      param >= 0n && param <= 2n ** 160n - 1n,\n      `Validate: arg ${input.name} cairo typed ${input.type} should be in range [0, 2^160-1]`\n    );\n    return;\n  }\n\n  assert(\n    typeof parameter === 'object' && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type struct (${input.type}), and should be defined as js object (not array)`\n  );\n\n  // shallow struct validation, only first depth level\n  structs[input.type].members.forEach(({ name }) => {\n    assert(\n      Object.keys(parameter).includes(name),\n      `Validate: arg ${input.name} should have a property ${name}`\n    );\n  });\n};\n\nconst validateEnum = (parameter: any, input: AbiEntry) => {\n  assert(\n    typeof parameter === 'object' && !Array.isArray(parameter),\n    `Validate: arg ${input.name} is cairo type Enum (${input.type}), and should be defined as js object (not array)`\n  );\n  const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));\n  const keys = [...Object.getOwnPropertyNames(parameter), ...methodsKeys];\n  if (isTypeOption(input.type) && keys.includes('isSome') && keys.includes('isNone')) {\n    return; // Option Enum\n  }\n  if (isTypeResult(input.type) && keys.includes('isOk') && keys.includes('isErr')) {\n    return; // Result Enum\n  }\n  if (keys.includes('variant') && keys.includes('activeVariant')) {\n    return; // Custom Enum\n  }\n  throw new Error(\n    `Validate Enum: argument ${input.name}, type ${input.type}, value received ${parameter}, is not an Enum.`\n  );\n};\n\nconst validateTuple = (parameter: any, input: AbiEntry) => {\n  assert(\n    typeof parameter === 'object' && !Array.isArray(parameter),\n    `Validate: arg ${input.name} should be a tuple (defined as object)`\n  );\n  // todo: skip tuple structural validation for now\n};\n\nconst validateArray = (parameter: any, input: AbiEntry, structs: AbiStructs, enums: AbiEnums) => {\n  const baseType = getArrayType(input.type);\n\n  // Long text (special case when parameter is not an array but long text)\n  // console.log(\n  //   'validate array = ',\n  //   isTypeFelt(baseType),\n  //   isLongText(parameter),\n  //   baseType,\n  //   parameter\n  // );\n  if (isTypeFelt(baseType) && isLongText(parameter)) {\n    // console.log('long text.');\n    return;\n  }\n\n  assert(Array.isArray(parameter), `Validate: arg ${input.name} should be an Array`);\n\n  switch (true) {\n    case isTypeFelt(baseType):\n      parameter.forEach((param: BigNumberish) => validateFelt(param, input));\n      break;\n    case isTypeTuple(baseType):\n      parameter.forEach((it: any) => validateTuple(it, { name: input.name, type: baseType }));\n      break;\n\n    case isTypeArray(baseType):\n      parameter.forEach((param: BigNumberish) =>\n        validateArray(param, { name: '', type: baseType }, structs, enums)\n      );\n      break;\n    case isTypeStruct(baseType, structs):\n      parameter.forEach((it: any) =>\n        validateStruct(it, { name: input.name, type: baseType }, structs)\n      );\n      break;\n    case isTypeEnum(baseType, enums):\n      parameter.forEach((it: any) => validateEnum(it, { name: input.name, type: baseType }));\n      break;\n    case isTypeUint(baseType) || isTypeLiteral(baseType):\n      parameter.forEach((param: BigNumberish) => validateUint(param, input));\n      break;\n    case isTypeBool(baseType):\n      parameter.forEach((param: BigNumberish) => validateBool(param, input));\n      break;\n    default:\n      throw new Error(\n        `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n      );\n  }\n};\n\nexport default function validateFields(\n  abiMethod: FunctionAbi,\n  args: Array<any>,\n  structs: AbiStructs,\n  enums: AbiEnums\n) {\n  abiMethod.inputs.reduce((acc, input) => {\n    const parameter = args[acc];\n\n    switch (true) {\n      case isLen(input.name):\n        return acc;\n      case isTypeFelt(input.type):\n        validateFelt(parameter, input);\n        break;\n      case isTypeBytes31(input.type):\n        validateBytes31(parameter, input);\n        break;\n      case isTypeUint(input.type) || isTypeLiteral(input.type):\n        validateUint(parameter, input);\n        break;\n      case isTypeBool(input.type):\n        validateBool(parameter, input);\n        break;\n      case isTypeByteArray(input.type):\n        validateByteArray(parameter, input);\n        break;\n      case isTypeArray(input.type):\n        validateArray(parameter, input, structs, enums);\n        break;\n      case isTypeStruct(input.type, structs):\n        validateStruct(parameter, input, structs);\n        break;\n      case isTypeEnum(input.type, enums):\n        validateEnum(parameter, input);\n        break;\n      case isTypeTuple(input.type):\n        validateTuple(parameter, input);\n        break;\n      default:\n        throw new Error(\n          `Validate Unhandled: argument ${input.name}, type ${input.type}, value ${parameter}`\n        );\n    }\n\n    return acc + 1;\n  }, 0);\n}\n","/* eslint-disable no-plusplus */\nimport {\n  Abi,\n  AbiEnums,\n  AbiStructs,\n  AllowArray,\n  Args,\n  ArgsOrCalldata,\n  Calldata,\n  FunctionAbi,\n  HexCalldata,\n  RawArgs,\n  RawArgsArray,\n  Result,\n  ValidateType,\n} from '../../types';\nimport assert from '../assert';\nimport { isBigInt, toHex } from '../num';\nimport { getSelectorFromName } from '../selector';\nimport { isLongText } from '../shortString';\nimport { byteArrayFromString } from './byteArray';\nimport { felt, isCairo1Type, isLen } from './cairo';\nimport {\n  CairoCustomEnum,\n  CairoOption,\n  CairoOptionVariant,\n  CairoResult,\n  CairoResultVariant,\n} from './enum';\nimport formatter from './formatter';\nimport { createAbiParser, isNoConstructorValid } from './parser';\nimport { AbiParserInterface } from './parser/interface';\nimport orderPropsByAbi from './propertyOrder';\nimport { parseCalldataField } from './requestParser';\nimport responseParser from './responseParser';\nimport validateFields from './validate';\n\nexport * as cairo from './cairo';\nexport * as byteArray from './byteArray';\n\nexport class CallData {\n  abi: Abi;\n\n  parser: AbiParserInterface;\n\n  protected readonly structs: AbiStructs;\n\n  protected readonly enums: AbiEnums;\n\n  constructor(abi: Abi) {\n    this.structs = CallData.getAbiStruct(abi);\n    this.enums = CallData.getAbiEnum(abi);\n    this.parser = createAbiParser(abi);\n    this.abi = this.parser.getLegacyFormat();\n  }\n\n  /**\n   * Validate arguments passed to the method as corresponding to the ones in the abi\n   * @param type ValidateType - type of the method\n   * @param method string - name of the method\n   * @param args ArgsOrCalldata - arguments that are passed to the method\n   */\n  public validate(type: ValidateType, method: string, args: ArgsOrCalldata = []) {\n    // ensure provided method of type exists\n    if (type !== ValidateType.DEPLOY) {\n      const invocableFunctionNames = this.abi\n        .filter((abi) => {\n          if (abi.type !== 'function') return false;\n          const isView = abi.stateMutability === 'view' || abi.state_mutability === 'view';\n          return type === ValidateType.INVOKE ? !isView : isView;\n        })\n        .map((abi) => abi.name);\n      assert(\n        invocableFunctionNames.includes(method),\n        `${type === ValidateType.INVOKE ? 'invocable' : 'viewable'} method not found in abi`\n      );\n    }\n\n    // get requested method from abi\n    const abiMethod = this.abi.find((abi) =>\n      type === ValidateType.DEPLOY\n        ? abi.name === method && abi.type === 'constructor'\n        : abi.name === method && abi.type === 'function'\n    ) as FunctionAbi;\n\n    if (isNoConstructorValid(method, args, abiMethod)) {\n      return;\n    }\n\n    // validate arguments length\n    const inputsLength = this.parser.methodInputsLength(abiMethod);\n    if (args.length !== inputsLength) {\n      throw Error(\n        `Invalid number of arguments, expected ${inputsLength} arguments, but got ${args.length}`\n      );\n    }\n\n    // validate parameters\n    validateFields(abiMethod, args, this.structs, this.enums);\n  }\n\n  /**\n   * Compile contract callData with abi\n   * Parse the calldata by using input fields from the abi for that method\n   * @param method string - method name\n   * @param args RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).\n   * @return Calldata - parsed arguments in format that contract is expecting\n   * @example\n   * ```typescript\n   * const calldata = myCallData.compile(\"constructor\", [\"0x34a\", [1, 3n]]);\n   * ```\n   * ```typescript\n   * const calldata2 = myCallData.compile(\"constructor\", {list:[1, 3n], balance:\"0x34\"}); // wrong order is valid\n   * ```\n   */\n  public compile(method: string, argsCalldata: RawArgs): Calldata {\n    const abiMethod = this.abi.find((abiFunction) => abiFunction.name === method) as FunctionAbi;\n\n    if (isNoConstructorValid(method, argsCalldata, abiMethod)) {\n      return [];\n    }\n\n    let args: RawArgsArray;\n    if (Array.isArray(argsCalldata)) {\n      args = argsCalldata;\n    } else {\n      // order the object\n      const orderedObject = orderPropsByAbi(\n        argsCalldata,\n        abiMethod.inputs,\n        this.structs,\n        this.enums\n      );\n      // console.log('ordered =', orderedObject);\n      args = Object.values(orderedObject);\n      //   // validate array elements to abi\n      validateFields(abiMethod, args, this.structs, this.enums);\n    }\n\n    const argsIterator = args[Symbol.iterator]();\n\n    const callArray = abiMethod.inputs.reduce(\n      (acc, input) =>\n        isLen(input.name) && !isCairo1Type(input.type)\n          ? acc\n          : acc.concat(parseCalldataField(argsIterator, input, this.structs, this.enums)),\n      [] as Calldata\n    );\n\n    // add compiled property to array object\n    Object.defineProperty(callArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callArray;\n  }\n\n  /**\n   * Compile contract callData without abi\n   * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data\n   * @returns Calldata\n   */\n  static compile(rawArgs: RawArgs): Calldata {\n    const createTree = (obj: object) => {\n      const getEntries = (o: object, prefix = '.'): any => {\n        const oe = Array.isArray(o) ? [o.length.toString(), ...o] : o;\n        return Object.entries(oe).flatMap(([k, v]) => {\n          let value = v;\n          if (k === 'entrypoint') value = getSelectorFromName(value);\n          else if (isLongText(value)) value = byteArrayFromString(value);\n          const kk = Array.isArray(oe) && k === '0' ? '$$len' : k;\n          if (isBigInt(value)) return [[`${prefix}${kk}`, felt(value)]];\n          if (Object(value) === value) {\n            const methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));\n            const keys = [...Object.getOwnPropertyNames(value), ...methodsKeys];\n            if (keys.includes('isSome') && keys.includes('isNone')) {\n              // Option\n              const myOption = value as CairoOption<any>;\n              const variantNb = myOption.isSome()\n                ? CairoOptionVariant.Some\n                : CairoOptionVariant.None;\n              if (myOption.isSome())\n                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, `${prefix}${kk}.`);\n              return [[`${prefix}${kk}`, felt(variantNb)]];\n            }\n            if (keys.includes('isOk') && keys.includes('isErr')) {\n              // Result\n              const myResult = value as CairoResult<any, any>;\n              const variantNb = myResult.isOk() ? CairoResultVariant.Ok : CairoResultVariant.Err;\n              return getEntries({ 0: variantNb, 1: myResult.unwrap() }, `${prefix}${kk}.`);\n            }\n            if (keys.includes('variant') && keys.includes('activeVariant')) {\n              // CustomEnum\n              const myEnum = value as CairoCustomEnum;\n              const activeVariant: string = myEnum.activeVariant();\n              const listVariants = Object.keys(myEnum.variant);\n              const activeVariantNb = listVariants.findIndex(\n                (variant: any) => variant === activeVariant\n              );\n              if (\n                typeof myEnum.unwrap() === 'object' &&\n                Object.keys(myEnum.unwrap()).length === 0 // empty object : {}\n              ) {\n                return [[`${prefix}${kk}`, felt(activeVariantNb)]];\n              }\n              return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, `${prefix}${kk}.`);\n            }\n            // normal object\n            return getEntries(value, `${prefix}${kk}.`);\n          }\n          return [[`${prefix}${kk}`, felt(value)]];\n        });\n      };\n      const result = Object.fromEntries(getEntries(obj));\n      return result;\n    };\n\n    let callTreeArray;\n    if (!Array.isArray(rawArgs)) {\n      // flatten structs, tuples, add array length. Process leafs as Felt\n      const callTree = createTree(rawArgs);\n      // convert to array\n      callTreeArray = Object.values(callTree);\n    } else {\n      // already compiled data but modified or raw args provided as array, recompile it\n      // recreate tree\n      const callObj = { ...rawArgs };\n      const callTree = createTree(callObj);\n      callTreeArray = Object.values(callTree);\n    }\n\n    // add compiled property to array object\n    Object.defineProperty(callTreeArray, '__compiled__', {\n      enumerable: false,\n      writable: false,\n      value: true,\n    });\n    return callTreeArray;\n  }\n\n  /**\n   * Parse elements of the response array and structuring them into response object\n   * @param method string - method name\n   * @param response string[] - response from the method\n   * @return Result - parsed response corresponding to the abi\n   */\n  public parse(method: string, response: string[]): Result {\n    const { outputs } = this.abi.find((abi) => abi.name === method) as FunctionAbi;\n    const responseIterator = response.flat()[Symbol.iterator]();\n\n    const parsed = outputs.flat().reduce((acc, output, idx) => {\n      const propName = output.name ?? idx;\n      acc[propName] = responseParser(responseIterator, output, this.structs, this.enums, acc);\n      if (acc[propName] && acc[`${propName}_len`]) {\n        delete acc[`${propName}_len`];\n      }\n      return acc;\n    }, {} as Args);\n\n    // Cairo1 avoid object.0 structure\n    return Object.keys(parsed).length === 1 && 0 in parsed ? (parsed[0] as Result) : parsed;\n  }\n\n  /**\n   * Format cairo method response data to native js values based on provided format schema\n   * @param method string - cairo method name\n   * @param response string[] - cairo method response\n   * @param format object - formatter object schema\n   * @returns Result - parsed and formatted response object\n   */\n  public format(method: string, response: string[], format: object): Result {\n    const parsed = this.parse(method, response);\n    return formatter(parsed, format);\n  }\n\n  /**\n   * Helper to extract structs from abi\n   * @param abi Abi\n   * @returns AbiStructs - structs from abi\n   */\n  static getAbiStruct(abi: Abi): AbiStructs {\n    return abi\n      .filter((abiEntry) => abiEntry.type === 'struct')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n  }\n\n  /**\n   * Helper to extract enums from abi\n   * @param abi Abi\n   * @returns AbiEnums - enums from abi\n   */\n  static getAbiEnum(abi: Abi): AbiEnums {\n    const fullEnumList = abi\n      .filter((abiEntry) => abiEntry.type === 'enum')\n      .reduce(\n        (acc, abiEntry) => ({\n          ...acc,\n          [abiEntry.name]: abiEntry,\n        }),\n        {}\n      );\n    delete fullEnumList['core::bool'];\n    return fullEnumList;\n  }\n\n  /**\n   * Helper: Compile HexCalldata | RawCalldata | RawArgs\n   * @param rawCalldata HexCalldata | RawCalldata | RawArgs\n   * @returns Calldata\n   */\n  static toCalldata(rawCalldata: RawArgs = []): Calldata {\n    return CallData.compile(rawCalldata);\n  }\n\n  /**\n   * Helper: Convert raw to HexCalldata\n   * @param raw HexCalldata | RawCalldata | RawArgs\n   * @returns HexCalldata\n   */\n  static toHex(raw: RawArgs = []): HexCalldata {\n    const calldata = CallData.compile(raw);\n    return calldata.map((it) => toHex(it));\n  }\n\n  /**\n   * Parse the elements of a contract response and structure them into one or several Result.\n   * In Cairo 0, arrays are not supported.\n   * @param typeCairo string or string[] - Cairo type name, ex : \"hello::hello::UserData\"\n   * @param response string[] - serialized data corresponding to typeCairo.\n   * @return Result or Result[] - parsed response corresponding to typeData.\n   * @example\n   * const res2=helloCallData.decodeParameters(\"hello::hello::UserData\",[\"0x123456\",\"0x1\"]);\n   * result = { address: 1193046n, is_claimed: true }\n   */\n  public decodeParameters(typeCairo: AllowArray<string>, response: string[]): AllowArray<Result> {\n    const typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];\n    const responseIterator = response.flat()[Symbol.iterator]();\n    const decodedArray = typeCairoArray.map(\n      (typeParam) =>\n        responseParser(\n          responseIterator,\n          { name: '', type: typeParam },\n          this.structs,\n          this.enums\n        ) as Result\n    );\n    return decodedArray.length === 1 ? decodedArray[0] : decodedArray;\n  }\n}\n","/**\n * Hashes Exports\n */\nexport * as poseidon from '@noble/curves/abstract/poseidon';\nexport * from '../selector'; // Preserve legacy export structure\n\nexport * from './transactionHash';\nexport * from './classHash';\n","/**\n * Calculate Hashes for v0 - v2 transactions\n */\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable import/extensions */\nimport { StarknetChainId, TransactionHashPrefix } from '../../../constants';\nimport { BigNumberish, RawCalldata } from '../../../types';\nimport { starkCurve } from '../../ec';\nimport { toBigInt } from '../../num';\n\n/**\n * Compute pedersen hash from data\n * @returns format: hex-string - pedersen hash\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(toBigInt(x), toBigInt(y)), 0)\n    .toString();\n}\n\n/**\n * Calculate transaction pedersen hash for common properties\n *\n * Following implementation is based on this python [implementation #](https://github.com/starkware-libs/cairo-lang/blob/b614d1867c64f3fb2cf4a4879348cfcf87c3a5a7/src/starkware/starknet/core/os/transaction_hash/transaction_hash.py)\n * @returns format: hex-string\n */\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  contractAddress: BigNumberish,\n  entryPointSelector: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  additionalData: BigNumberish[] = []\n): string {\n  const calldataHash = computeHashOnElements(calldata);\n  const dataToHash = [\n    txHashPrefix,\n    version,\n    contractAddress,\n    entryPointSelector,\n    calldataHash,\n    maxFee,\n    chainId,\n    ...additionalData,\n  ];\n  return computeHashOnElements(dataToHash);\n}\n\n/**\n * Calculate declare transaction hash\n * @param classHash hex-string\n * @param compiledClassHash hex-string\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  compiledClassHash?: string\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    0,\n    [classHash],\n    maxFee,\n    chainId,\n    [nonce, ...(compiledClassHash ? [compiledClassHash] : [])]\n  );\n}\n\n/**\n * Calculate deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawCalldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n) {\n  const calldata = [classHash, salt, ...constructorCalldata];\n\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n\n/**\n * Calculate invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateTransactionHash(\n  contractAddress: BigNumberish,\n  version: BigNumberish,\n  calldata: RawCalldata,\n  maxFee: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    contractAddress,\n    0,\n    calldata,\n    maxFee,\n    chainId,\n    [nonce]\n  );\n}\n","// TODO rename\nexport * as starkCurve from '@scure/starknet';\nexport * as weierstrass from '@noble/curves/abstract/weierstrass';\n","/**\n * Calculate Hashes for v3 transactions\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { StarknetChainId, TransactionHashPrefix } from '../../../constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport { EDAMode, ResourceBounds } from '../../../types/api';\nimport { toHex } from '../../num';\nimport { encodeShortString } from '../../shortString';\n\nconst AToBI = (array: BigNumberish[]) => array.map((it: BigNumberish) => BigInt(it));\n\n/* eslint-disable no-bitwise */\nconst DATA_AVAILABILITY_MODE_BITS = 32n;\nconst MAX_AMOUNT_BITS = 64n;\nconst MAX_PRICE_PER_UNIT_BITS = 128n;\nconst RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;\nconst L1_GAS_NAME = BigInt(encodeShortString('L1_GAS'));\nconst L2_GAS_NAME = BigInt(encodeShortString('L2_GAS'));\n\nexport function hashDAMode(nonceDAMode: BigNumberish, feeDAMode: BigNumberish) {\n  return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);\n}\n\nexport function hashFeeField(tip: BigNumberish, bounds: ResourceBounds) {\n  const L1Bound =\n    (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +\n    BigInt(bounds.l1_gas.max_price_per_unit);\n\n  const L2Bound =\n    (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) +\n    (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +\n    BigInt(bounds.l2_gas.max_price_per_unit);\n\n  return poseidonHashMany([BigInt(tip), L1Bound, L2Bound]);\n}\n\nexport function calculateTransactionHashCommon(\n  txHashPrefix: TransactionHashPrefix,\n  version: BigNumberish,\n  senderAddress: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  additionalData: BigNumberish[] = []\n): string {\n  const feeFieldHash = hashFeeField(tip, resourceBounds);\n  const dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);\n  const dataToHash = AToBI([\n    txHashPrefix,\n    version,\n    senderAddress,\n    feeFieldHash,\n    poseidonHashMany(AToBI(paymasterData)),\n    chainId,\n    nonce,\n    dAModeHash,\n    ...AToBI(additionalData),\n  ]);\n  return toHex(poseidonHashMany(dataToHash));\n}\n\n/**\n * Calculate v3 deploy_account transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeployAccountTransactionHash(\n  contractAddress: BigNumberish,\n  classHash: BigNumberish,\n  compiledConstructorCalldata: Calldata,\n  salt: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n) {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DEPLOY_ACCOUNT,\n    version,\n    contractAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(compiledConstructorCalldata)), classHash, salt]\n  );\n}\n\n/**\n * Calculate v3 declare transaction hash\n * @returns format: hex-string\n */\nexport function calculateDeclareTransactionHash(\n  classHash: string,\n  compiledClassHash: string,\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.DECLARE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    AToBI(paymasterData),\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), classHash, compiledClassHash]\n  );\n}\n\n/**\n * Calculate v3 invoke transaction hash\n * @returns format: hex-string\n */\nexport function calculateInvokeTransactionHash(\n  senderAddress: BigNumberish,\n  version: BigNumberish,\n  compiledCalldata: Calldata,\n  chainId: StarknetChainId,\n  nonce: BigNumberish,\n  accountDeploymentData: BigNumberish[],\n  nonceDataAvailabilityMode: EDAMode,\n  feeDataAvailabilityMode: EDAMode,\n  resourceBounds: ResourceBounds,\n  tip: BigNumberish,\n  paymasterData: BigNumberish[]\n): string {\n  return calculateTransactionHashCommon(\n    TransactionHashPrefix.INVOKE,\n    version,\n    senderAddress,\n    chainId,\n    nonce,\n    tip,\n    paymasterData,\n    nonceDataAvailabilityMode,\n    feeDataAvailabilityMode,\n    resourceBounds,\n    [poseidonHashMany(AToBI(accountDeploymentData)), poseidonHashMany(AToBI(compiledCalldata))]\n  );\n}\n","/**\n * Transaction Hash based on Transaction Version\n */\n\nimport { StarknetChainId } from '../../../constants';\nimport { BigNumberish, Calldata } from '../../../types';\nimport {\n  EDAMode,\n  ETransactionVersion,\n  ETransactionVersion2,\n  ETransactionVersion3,\n  ResourceBounds,\n} from '../../../types/api';\nimport {\n  calculateDeclareTransactionHash as v2calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v2calculateDeployAccountTransactionHash,\n  calculateTransactionHash as v2calculateInvokeTransactionHash,\n} from './v2';\nimport {\n  calculateDeclareTransactionHash as v3calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash as v3calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash as v3calculateInvokeTransactionHash,\n} from './v3';\n\n/*\n * INVOKE TX HASH\n */\n\nfunction isV3InvokeTx(args: CalcInvokeTxHashArgs): args is CalcV3InvokeTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(\n    args.version as ETransactionVersion\n  );\n}\n\ntype CalcV2InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  compiledCalldata: Calldata;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n};\n\ntype CalcV3InvokeTxHashArgs = {\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  compiledCalldata: Calldata;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcInvokeTxHashArgs = CalcV2InvokeTxHashArgs | CalcV3InvokeTxHashArgs;\n\nexport function calculateInvokeTransactionHash(args: CalcInvokeTxHashArgs) {\n  if (isV3InvokeTx(args)) {\n    return v3calculateInvokeTransactionHash(\n      args.senderAddress,\n      args.version,\n      args.compiledCalldata,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n  return v2calculateInvokeTransactionHash(\n    args.senderAddress,\n    args.version,\n    args.compiledCalldata,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n\n/*\n * DECLARE TX HASH\n */\nfunction isV3DeclareTx(args: CalcDeclareTxHashArgs): args is CalcV3DeclareTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(\n    args.version as ETransactionVersion\n  );\n}\n\ntype CalcV2DeclareTxHashArgs = {\n  classHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  compiledClassHash?: string;\n};\n\ntype CalcV3DeclareTxHashArgs = {\n  classHash: string;\n  compiledClassHash: string;\n  senderAddress: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  accountDeploymentData: BigNumberish[];\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeclareTxHashArgs = CalcV2DeclareTxHashArgs | CalcV3DeclareTxHashArgs;\n\nexport function calculateDeclareTransactionHash(args: CalcDeclareTxHashArgs) {\n  if (isV3DeclareTx(args)) {\n    return v3calculateDeclareTransactionHash(\n      args.classHash,\n      args.compiledClassHash,\n      args.senderAddress,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.accountDeploymentData,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  return v2calculateDeclareTransactionHash(\n    args.classHash,\n    args.senderAddress,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce,\n    args.compiledClassHash\n  );\n}\n\n/*\n * DEPLOY ACCOUNT TX HASH\n */\n\nfunction isV3DeployAccountTx(\n  args: CalcDeployAccountTxHashArgs\n): args is CalcV3DeployAccountTxHashArgs {\n  return [ETransactionVersion.V3, ETransactionVersion.F3].includes(\n    args.version as ETransactionVersion\n  );\n}\n\ntype CalcV2DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  constructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion2}`;\n  maxFee: BigNumberish;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n};\n\ntype CalcV3DeployAccountTxHashArgs = {\n  contractAddress: BigNumberish;\n  classHash: BigNumberish;\n  compiledConstructorCalldata: Calldata;\n  salt: BigNumberish;\n  version: `${ETransactionVersion3}`;\n  chainId: StarknetChainId;\n  nonce: BigNumberish;\n  nonceDataAvailabilityMode: EDAMode;\n  feeDataAvailabilityMode: EDAMode;\n  resourceBounds: ResourceBounds;\n  tip: BigNumberish;\n  paymasterData: BigNumberish[];\n};\n\ntype CalcDeployAccountTxHashArgs = CalcV2DeployAccountTxHashArgs | CalcV3DeployAccountTxHashArgs;\n\nexport function calculateDeployAccountTransactionHash(args: CalcDeployAccountTxHashArgs) {\n  if (isV3DeployAccountTx(args)) {\n    return v3calculateDeployAccountTransactionHash(\n      args.contractAddress,\n      args.classHash,\n      args.compiledConstructorCalldata,\n      args.salt,\n      args.version,\n      args.chainId,\n      args.nonce,\n      args.nonceDataAvailabilityMode,\n      args.feeDataAvailabilityMode,\n      args.resourceBounds,\n      args.tip,\n      args.paymasterData\n    );\n  }\n\n  return v2calculateDeployAccountTransactionHash(\n    args.contractAddress,\n    args.classHash,\n    args.constructorCalldata,\n    args.salt,\n    args.version,\n    args.maxFee,\n    args.chainId,\n    args.nonce\n  );\n}\n","/**\n * Class Hash\n */\n\nimport { poseidonHashMany } from '@scure/starknet';\n\nimport { ADDR_BOUND, API_VERSION } from '../../constants';\nimport {\n  BigNumberish,\n  Builtins,\n  CompiledContract,\n  CompiledSierra,\n  CompiledSierraCasm,\n  ContractEntryPointFields,\n  LegacyCompiledContract,\n  RawArgs,\n  SierraContractEntryPointFields,\n} from '../../types';\nimport { CallData } from '../calldata';\nimport { felt } from '../calldata/cairo';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\nimport { parse, stringify } from '../json';\nimport { toHex } from '../num';\nimport { encodeShortString } from '../shortString';\n\nexport function computePedersenHash(a: BigNumberish, b: BigNumberish): string {\n  return starkCurve.pedersen(BigInt(a), BigInt(b));\n}\n\nexport function computePoseidonHash(a: BigNumberish, b: BigNumberish): string {\n  return toHex(starkCurve.poseidonHash(BigInt(a), BigInt(b)));\n}\n\n/**\n * Compute pedersen hash from data\n * @returns format: hex-string - pedersen hash\n */\nexport function computeHashOnElements(data: BigNumberish[]): string {\n  return [...data, data.length]\n    .reduce((x: BigNumberish, y: BigNumberish) => starkCurve.pedersen(BigInt(x), BigInt(y)), 0)\n    .toString();\n}\n\nexport const computePedersenHashOnElements = computeHashOnElements;\n\nexport function computePoseidonHashOnElements(data: BigNumberish[]) {\n  return toHex(poseidonHashMany(data.map((x) => BigInt(x))));\n}\n\n/**\n * Calculate contract address from class hash\n * @returns format: hex-string\n */\nexport function calculateContractAddressFromHash(\n  salt: BigNumberish,\n  classHash: BigNumberish,\n  constructorCalldata: RawArgs,\n  deployerAddress: BigNumberish\n) {\n  const compiledCalldata = CallData.compile(constructorCalldata);\n  const constructorCalldataHash = computeHashOnElements(compiledCalldata);\n\n  const CONTRACT_ADDRESS_PREFIX = felt('0x535441524b4e45545f434f4e54524143545f41444452455353'); // Equivalent to 'STARKNET_CONTRACT_ADDRESS'\n\n  const hash = computeHashOnElements([\n    CONTRACT_ADDRESS_PREFIX,\n    deployerAddress,\n    salt,\n    classHash,\n    constructorCalldataHash,\n  ]);\n  return toHex(BigInt(hash) % ADDR_BOUND);\n}\n\nfunction nullSkipReplacer(key: string, value: any) {\n  if (key === 'attributes' || key === 'accessible_scopes') {\n    return Array.isArray(value) && value.length === 0 ? undefined : value;\n  }\n\n  if (key === 'debug_info') {\n    return null;\n  }\n\n  return value === null ? undefined : value;\n}\n\n/**\n * Format json-string to conform starknet json-string\n * @param json json-string\n * @returns format: json-string\n */\nexport function formatSpaces(json: string) {\n  let insideQuotes = false;\n  const newString = [];\n  // eslint-disable-next-line no-restricted-syntax\n  for (const char of json) {\n    if (char === '\"' && (newString.length > 0 && newString.slice(-1)[0] === '\\\\') === false) {\n      insideQuotes = !insideQuotes;\n    }\n    if (insideQuotes) {\n      newString.push(char);\n    } else {\n      // eslint-disable-next-line no-nested-ternary\n      newString.push(char === ':' ? ': ' : char === ',' ? ', ' : char);\n    }\n  }\n  return newString.join('');\n}\n\n/**\n * Compute hinted class hash for legacy compiled contract (Cairo 0)\n * @returns format: hex-string\n */\nexport default function computeHintedClassHash(compiledContract: LegacyCompiledContract) {\n  const { abi, program } = compiledContract;\n  const contractClass = { abi, program };\n  const serializedJson = formatSpaces(stringify(contractClass, nullSkipReplacer));\n\n  return addHexPrefix(starkCurve.keccak(utf8ToArray(serializedJson)).toString(16));\n}\n\n/**\n * Computes the class hash for legacy compiled contract (Cairo 0)\n * @returns format: hex-string\n */\nexport function computeLegacyContractClassHash(contract: LegacyCompiledContract | string) {\n  const compiledContract =\n    typeof contract === 'string' ? (parse(contract) as LegacyCompiledContract) : contract;\n\n  const apiVersion = toHex(API_VERSION);\n\n  const externalEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.EXTERNAL.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const l1HandlerEntryPointsHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.L1_HANDLER.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const constructorEntryPointHash = computeHashOnElements(\n    compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap((e) => [e.selector, e.offset])\n  );\n\n  const builtinsHash = computeHashOnElements(\n    compiledContract.program.builtins.map((s) => encodeShortString(s))\n  );\n\n  const hintedClassHash = computeHintedClassHash(compiledContract);\n\n  const dataHash = computeHashOnElements(compiledContract.program.data);\n\n  return computeHashOnElements([\n    apiVersion,\n    externalEntryPointsHash,\n    l1HandlerEntryPointsHash,\n    constructorEntryPointHash,\n    builtinsHash,\n    hintedClassHash,\n    dataHash,\n  ]);\n}\n\n// Cairo 1 Contract Hashes\n\nfunction hashBuiltins(builtins: Builtins) {\n  return poseidonHashMany(\n    builtins.flatMap((it: any) => {\n      return BigInt(encodeShortString(it));\n    })\n  );\n}\n\nfunction hashEntryPoint(data: ContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];\n  });\n  return poseidonHashMany(base);\n}\n\n/**\n * Compute hash of the bytecode for Sierra v1.5.0 onwards (Cairo 2.6.0)\n * Each segment is Poseidon hashed.\n * The global hash is : 1 + PoseidonHash(len0, h0, len1, h1, ...)\n * @param casm compiled Sierra CASM file content.\n * @returns the bytecode hash as bigint.\n */\nexport function hashByteCodeSegments(casm: CompiledSierraCasm): bigint {\n  const byteCode: bigint[] = casm.bytecode.map((n) => BigInt(n));\n  const bytecodeSegmentLengths: number[] = casm.bytecode_segment_lengths ?? [];\n\n  let segmentStart = 0;\n  const hashLeaves = bytecodeSegmentLengths.flatMap((len) => {\n    const segment = byteCode.slice(segmentStart, (segmentStart += len));\n\n    return [BigInt(len), poseidonHashMany(segment)];\n  });\n  return 1n + poseidonHashMany(hashLeaves);\n}\n\n/**\n * Compute compiled class hash for contract (Cairo 1)\n * @returns format: hex-string\n */\nexport function computeCompiledClassHash(casm: CompiledSierraCasm) {\n  const COMPILED_CLASS_VERSION = 'COMPILED_CLASS_V1';\n\n  // Hash compiled class version\n  const compiledClassVersion = BigInt(encodeShortString(COMPILED_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash bytecode.\n  const bytecode = casm.bytecode_segment_lengths\n    ? hashByteCodeSegments(casm)\n    : poseidonHashMany(casm.bytecode.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      bytecode,\n    ])\n  );\n}\n\nfunction hashEntryPointSierra(data: SierraContractEntryPointFields[]) {\n  const base = data.flatMap((it: any) => {\n    return [BigInt(it.selector), BigInt(it.function_idx)];\n  });\n  return poseidonHashMany(base);\n}\n\nfunction hashAbi(sierra: CompiledSierra) {\n  const indentString = formatSpaces(stringify(sierra.abi, null));\n  return BigInt(addHexPrefix(starkCurve.keccak(utf8ToArray(indentString)).toString(16)));\n}\n\n/**\n * Compute sierra contract class hash (Cairo 1)\n * @returns format: hex-string\n */\nexport function computeSierraContractClassHash(sierra: CompiledSierra) {\n  const CONTRACT_CLASS_VERSION = 'CONTRACT_CLASS_V0.1.0';\n\n  // Hash class version\n  const compiledClassVersion = BigInt(encodeShortString(CONTRACT_CLASS_VERSION));\n\n  // Hash external entry points.\n  const externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);\n\n  // Hash L1 handler entry points.\n  const l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);\n\n  // Hash constructor entry points.\n  const constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);\n\n  // Hash abi_hash.\n  const abiHash = hashAbi(sierra);\n\n  // Hash Sierra program.\n  const sierraProgram = poseidonHashMany(sierra.sierra_program.map((it: string) => BigInt(it)));\n\n  return toHex(\n    poseidonHashMany([\n      compiledClassVersion,\n      externalEntryPointsHash,\n      l1Handlers,\n      constructor,\n      abiHash,\n      sierraProgram,\n    ])\n  );\n}\n\n/**\n * Compute ClassHash (sierra or legacy) based on provided contract\n * @returns format: hex-string\n */\nexport function computeContractClassHash(contract: CompiledContract | string) {\n  const compiledContract = typeof contract === 'string' ? parse(contract) : contract;\n\n  if ('sierra_program' in compiledContract) {\n    return computeSierraContractClassHash(compiledContract as CompiledSierra);\n  }\n\n  return computeLegacyContractClassHash(compiledContract as LegacyCompiledContract);\n}\n","import * as json from 'lossless-json';\n\n/**\n * Convert string to number or bigint based on size\n */\nconst parseIntAsNumberOrBigInt = (x: string) => {\n  if (!json.isInteger(x)) return parseFloat(x);\n  const v = parseInt(x, 10);\n  return Number.isSafeInteger(v) ? v : BigInt(x);\n};\n\n/**\n * Convert JSON string to JSON object\n *\n * NOTE: the String() wrapping is used so the behavior conforms to JSON.parse()\n * which can accept simple data types but is not represented in the default typing\n * @param x JSON string\n */\nexport const parse = (x: string): any => json.parse(String(x), undefined, parseIntAsNumberOrBigInt);\n\n/**\n * Convert JSON string to JSON object with all numbers as bigint\n * @param x JSON string\n */\nexport const parseAlwaysAsBig = (x: string): any =>\n  json.parse(String(x), undefined, json.parseNumberAndBigInt);\n\n/**\n * Convert JSON object to JSON string\n *\n * NOTE: the not-null assertion is used so the return type conforms to JSON.stringify()\n * which can also return undefined but is not represented in the default typing\n * @returns JSON string\n */\nexport const stringify = (\n  value: unknown,\n  replacer?: any,\n  space?: string | number | undefined,\n  numberStringifiers?: json.NumberStringifier[] | undefined\n): string => json.stringify(value, replacer, space, numberStringifiers)!;\n\n/** @deprecated equivalent to 'stringify', alias will be removed */\nexport const stringifyAlwaysAsBig = stringify;\n","import { getStarkKey, utils } from '@scure/starknet';\nimport { gzip, ungzip } from 'pako';\n\nimport { ZERO, feeMarginPercentage } from '../constants';\nimport {\n  ArraySignatureType,\n  BigNumberish,\n  CompressedProgram,\n  Program,\n  Signature,\n  UniversalDetails,\n} from '../types';\nimport { EDAMode, EDataAvailabilityMode, ETransactionVersion, ResourceBounds } from '../types/api';\nimport { FeeEstimate } from '../types/provider';\nimport { addHexPrefix, arrayBufferToString, atobUniversal, btoaUniversal } from './encode';\nimport { parse, stringify } from './json';\nimport {\n  addPercent,\n  bigNumberishArrayToDecimalStringArray,\n  bigNumberishArrayToHexadecimalStringArray,\n  toHex,\n} from './num';\n\n/**\n * Compress compiled Cairo program\n *\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)\n * @param jsonProgram Representing the compiled cairo program\n */\nexport function compressProgram(jsonProgram: Program | string): CompressedProgram {\n  const stringified = typeof jsonProgram === 'string' ? jsonProgram : stringify(jsonProgram);\n  const compressedProgram = gzip(stringified);\n  return btoaUniversal(compressedProgram);\n}\n\n/**\n * Decompress compressed compiled Cairo program\n * @param base64 Compressed program\n * @returns Parsed decompressed compiled Cairo program\n */\nexport function decompressProgram(base64: CompressedProgram) {\n  if (Array.isArray(base64)) return base64;\n  const decompressed = arrayBufferToString(ungzip(atobUniversal(base64)));\n  return parse(decompressed);\n}\n\n/**\n * Random Address based on random keyPair\n */\nexport function randomAddress(): string {\n  const randomKeyPair = utils.randomPrivateKey();\n  return getStarkKey(randomKeyPair);\n}\n\n/**\n * Lowercase and hex prefix string\n *\n * @deprecated Not used internally, naming is confusing based on functionality\n */\nexport function makeAddress(input: string): string {\n  return addHexPrefix(input).toLowerCase();\n}\n\n/**\n * Format Signature to standard type (hex array)\n * @returns Custom hex array or weierstrass.SignatureType hex array\n */\nexport function formatSignature(sig?: Signature): ArraySignatureType {\n  if (!sig) throw Error('formatSignature: provided signature is undefined');\n  if (Array.isArray(sig)) {\n    return sig.map((it) => toHex(it));\n  }\n  try {\n    const { r, s } = sig;\n    return [toHex(r), toHex(s)];\n  } catch (e) {\n    throw new Error('Signature need to be weierstrass.SignatureType or an array for custom');\n  }\n}\n\n/**\n * Format Signature to decimal string array\n */\nexport function signatureToDecimalArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Format Signature to hex string array\n */\nexport function signatureToHexArray(sig?: Signature): ArraySignatureType {\n  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));\n}\n\n/**\n * Convert estimated fee to max fee with overhead\n */\nexport function estimatedFeeToMaxFee(\n  estimatedFee: BigNumberish,\n  overhead: number = feeMarginPercentage.MAX_FEE\n): bigint {\n  return addPercent(estimatedFee, overhead);\n}\n\nexport function estimateFeeToBounds(\n  estimate: FeeEstimate | 0n,\n  amountOverhead: number = feeMarginPercentage.L1_BOUND_MAX_AMOUNT,\n  priceOverhead: number = feeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT\n): ResourceBounds {\n  if (typeof estimate === 'bigint') {\n    return {\n      l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n      l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n    };\n  }\n\n  if (typeof estimate.gas_consumed === 'undefined' || typeof estimate.gas_price === 'undefined') {\n    throw Error('estimateFeeToBounds: estimate is undefined');\n  }\n\n  const maxUnits =\n    estimate.data_gas_consumed !== undefined && estimate.data_gas_price !== undefined // RPC v0.7\n      ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead))\n      : toHex(addPercent(estimate.gas_consumed, amountOverhead));\n  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));\n  return {\n    l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },\n    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice },\n  };\n}\n\nexport function intDAM(dam: EDataAvailabilityMode) {\n  if (dam === EDataAvailabilityMode.L1) return EDAMode.L1;\n  if (dam === EDataAvailabilityMode.L2) return EDAMode.L2;\n  throw Error('EDAM conversion');\n}\n\n/**\n * Convert to ETransactionVersion or throw an error.\n * Return providedVersion is specified else return defaultVersion\n * @param defaultVersion BigNumberish\n * @param providedVersion BigNumberish | undefined\n * @returns ETransactionVersion\n */\nexport function toTransactionVersion(defaultVersion: BigNumberish, providedVersion?: BigNumberish) {\n  const providedVersion0xs = providedVersion ? toHex(providedVersion) : undefined;\n  const defaultVersion0xs = toHex(defaultVersion);\n\n  if (providedVersion && !Object.values(ETransactionVersion).includes(providedVersion0xs as any)) {\n    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);\n  }\n  if (!Object.values(ETransactionVersion).includes(defaultVersion0xs as any)) {\n    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);\n  }\n\n  return (providedVersion ? providedVersion0xs : defaultVersion0xs) as ETransactionVersion;\n}\n\n/**\n * Convert Transaction version to Fee version or throw an error\n * @param providedVersion BigNumberish | undefined\n */\nexport function toFeeVersion(providedVersion?: BigNumberish) {\n  if (!providedVersion) return undefined;\n  const version = toHex(providedVersion);\n\n  if (version === ETransactionVersion.V0) return ETransactionVersion.F0;\n  if (version === ETransactionVersion.V1) return ETransactionVersion.F1;\n  if (version === ETransactionVersion.V2) return ETransactionVersion.F2;\n  if (version === ETransactionVersion.V3) return ETransactionVersion.F3;\n\n  throw Error(`toFeeVersion: ${version} is not supported`);\n}\n\n/**\n * Return provided or default v3 tx details\n */\nexport function v3Details(details: UniversalDetails) {\n  return {\n    tip: details.tip || 0,\n    paymasterData: details.paymasterData || [],\n    accountDeploymentData: details.accountDeploymentData || [],\n    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || EDataAvailabilityMode.L1,\n    feeDataAvailabilityMode: details.feeDataAvailabilityMode || EDataAvailabilityMode.L1,\n    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO),\n  };\n}\n\n/**\n * It will reduce V2 to V1, else (V3) stay the same\n * F2 -> F1\n * V2 -> V1\n * F3 -> F3\n * V3 -> V3\n */\nexport function reduceV2(providedVersion: ETransactionVersion) {\n  if (providedVersion === ETransactionVersion.F2) return ETransactionVersion.F1;\n  if (providedVersion === ETransactionVersion.V2) return ETransactionVersion.V1;\n  return providedVersion;\n}\n","import { ContractClassResponse } from '../types';\nimport {\n  CairoContract,\n  CompiledSierra,\n  LegacyCompiledContract,\n  LegacyContractClass,\n  SierraContractClass,\n} from '../types/lib/contract/index';\nimport { CompleteDeclareContractPayload, DeclareContractPayload } from '../types/lib/index';\nimport { computeCompiledClassHash, computeContractClassHash } from './hash';\nimport { parse } from './json';\nimport { decompressProgram } from './stark';\n\nexport function isSierra(\n  contract: CairoContract | string\n): contract is SierraContractClass | CompiledSierra {\n  const compiledContract = typeof contract === 'string' ? parse(contract) : contract;\n  return 'sierra_program' in compiledContract;\n}\n\nexport function extractContractHashes(\n  payload: DeclareContractPayload\n): CompleteDeclareContractPayload {\n  const response = { ...payload } as CompleteDeclareContractPayload;\n\n  if (isSierra(payload.contract)) {\n    if (!payload.compiledClassHash && payload.casm) {\n      response.compiledClassHash = computeCompiledClassHash(payload.casm);\n    }\n    if (!response.compiledClassHash)\n      throw new Error(\n        'Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash'\n      );\n  }\n\n  response.classHash = payload.classHash ?? computeContractClassHash(payload.contract);\n  if (!response.classHash)\n    throw new Error('Extract classHash failed, provide (CompiledContract).json file or classHash');\n\n  return response;\n}\n\n/**\n * Helper to redeclare response Cairo0 contract\n */\nexport function contractClassResponseToLegacyCompiledContract(ccr: ContractClassResponse) {\n  if (isSierra(ccr)) {\n    throw Error('ContractClassResponse need to be LegacyContractClass (cairo0 response class)');\n  }\n  const contract = ccr as LegacyContractClass;\n  return { ...contract, program: decompressProgram(contract.program) } as LegacyCompiledContract;\n}\n","// the ts-ignore suppresses an esm to cjs import error that is resolved with entry point resolution\n// @ts-ignore\nimport makeFetchCookie from 'fetch-cookie';\nimport isomorphicFetch from 'isomorphic-fetch';\n\nexport default (typeof window !== 'undefined' && window.fetch) || // use buildin fetch in browser if available\n  (typeof global !== 'undefined' && makeFetchCookie(global.fetch)) || // use buildin fetch in node, react-native and service worker if available\n  isomorphicFetch; // ponyfill fetch in node and browsers that don't have it\n","import { NetworkName, RPC_NODES } from '../constants';\nimport {\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  CompiledContract,\n  CompiledSierra,\n  ContractClass,\n  GetBlockResponse,\n  GetTransactionReceiptResponse,\n  InvocationsDetailsWithNonce,\n  LegacyContractClass,\n  PendingBlock,\n  PendingStateUpdate,\n  RPC,\n  SierraContractClass,\n  StateUpdateResponse,\n  V3TransactionDetails,\n} from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { isSierra } from './contract';\nimport { formatSpaces } from './hash';\nimport { parse, stringify } from './json';\nimport { isHex, toHex } from './num';\nimport { compressProgram } from './stark';\n\n/**\n * Helper - Async Sleep for 'delay' time\n */\nexport function wait(delay: number) {\n  return new Promise((res) => {\n    setTimeout(res, delay);\n  });\n}\n\n/**\n * Create Sierra Contract Class from a given Compiled Sierra\n *\n * CompiledSierra -> SierraContractClass\n */\nexport function createSierraContractClass(contract: CompiledSierra): SierraContractClass {\n  const result = { ...contract } as any;\n  delete result.sierra_program_debug_info;\n  result.abi = formatSpaces(stringify(contract.abi));\n  result.sierra_program = formatSpaces(stringify(contract.sierra_program));\n  result.sierra_program = compressProgram(result.sierra_program);\n  return result;\n}\n\n/**\n * Create Contract Class from a given CompiledContract or string\n *\n * (CompiledContract or string) -> ContractClass\n */\nexport function parseContract(contract: CompiledContract | string): ContractClass {\n  const parsedContract =\n    typeof contract === 'string' ? (parse(contract) as CompiledContract) : contract;\n\n  if (!isSierra(contract)) {\n    return {\n      ...parsedContract,\n      ...('program' in parsedContract && { program: compressProgram(parsedContract.program) }),\n    } as LegacyContractClass;\n  }\n\n  return createSierraContractClass(parsedContract as CompiledSierra);\n}\n\n/**\n * Return randomly select available public node\n * @param networkName NetworkName\n * @param mute mute public node warning\n * @returns default node url\n */\nexport const getDefaultNodeUrl = (networkName?: NetworkName, mute: boolean = false): string => {\n  if (!mute)\n    // eslint-disable-next-line no-console\n    console.warn('Using default public node url, please provide nodeUrl in provider options!');\n  const nodes = RPC_NODES[networkName ?? NetworkName.SN_GOERLI]; // TODO: when goerli deprecated switch default to sepolia\n  const randIdx = Math.floor(Math.random() * nodes.length);\n  return nodes[randIdx];\n};\n\n/**\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/fc97bdd8322a7df043c87c371634b26c15ed6cee/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L148-L153)\n */\nexport function formatHash(hashValue: BigNumberish): string {\n  if (typeof hashValue === 'string') return hashValue;\n  return toHex(hashValue);\n}\n\n/**\n * [Reference](https://github.com/starkware-libs/cairo-lang/blob/fc97bdd8322a7df043c87c371634b26c15ed6cee/src/starkware/starknet/services/api/feeder_gateway/feeder_gateway_client.py#L156-L161)\n */\nexport function txIdentifier(txHash?: BigNumberish, txId?: BigNumberish): string {\n  if (!txHash) {\n    return `transactionId=${JSON.stringify(txId)}`;\n  }\n  const hashString = formatHash(txHash);\n\n  return `transactionHash=${hashString}`;\n}\n\nexport const validBlockTags = Object.values(BlockTag);\n\nexport class Block {\n  hash: BlockIdentifier = null;\n\n  number: BlockIdentifier = null;\n\n  tag: BlockIdentifier = null;\n\n  private setIdentifier(__identifier: BlockIdentifier) {\n    if (typeof __identifier === 'string' && isHex(__identifier)) {\n      this.hash = __identifier;\n    } else if (typeof __identifier === 'bigint') {\n      this.hash = toHex(__identifier);\n    } else if (typeof __identifier === 'number') {\n      this.number = __identifier;\n    } else if (\n      typeof __identifier === 'string' &&\n      validBlockTags.includes(__identifier as BlockTag)\n    ) {\n      this.tag = __identifier;\n    } else {\n      // default\n      this.tag = BlockTag.pending;\n    }\n  }\n\n  constructor(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  // TODO: fix any\n  get queryIdentifier(): any {\n    if (this.number !== null) {\n      return `blockNumber=${this.number}`;\n    }\n\n    if (this.hash !== null) {\n      return `blockHash=${this.hash}`;\n    }\n\n    return `blockNumber=${this.tag}`;\n  }\n\n  // TODO: fix any\n  get identifier(): any {\n    if (this.number !== null) {\n      return { block_number: this.number };\n    }\n\n    if (this.hash !== null) {\n      return { block_hash: this.hash };\n    }\n\n    return this.tag;\n  }\n\n  set identifier(_identifier: BlockIdentifier) {\n    this.setIdentifier(_identifier);\n  }\n\n  valueOf = () => this.number;\n\n  toString = () => this.hash;\n\n  /*   get sequencerIdentifier(): SequencerIdentifier {\n    return this.hash !== null\n      ? { blockHash: this.hash as string }\n      : { blockNumber: (this.number ?? this.tag) as BlockNumber };\n  } */\n}\n\nexport function isV3Tx(details: InvocationsDetailsWithNonce): details is V3TransactionDetails {\n  const version = details.version ? toHex(details.version) : ETransactionVersion.V3;\n  return version === ETransactionVersion.V3 || version === ETransactionVersion.F3;\n}\n\nexport function isVersion(version: '0.5' | '0.6' | '0.7', response: string) {\n  const [majorS, minorS] = version.split('.');\n  const [majorR, minorR] = response.split('.');\n\n  return majorS === majorR && minorS === minorR;\n}\n\n/**\n * Guard Pending Block\n */\nexport function isPendingBlock(response: GetBlockResponse): response is PendingBlock {\n  return response.status === 'PENDING';\n}\n\n/**\n * Guard Pending Transaction\n */\nexport function isPendingTransaction(\n  response: GetTransactionReceiptResponse\n): response is RPC.PendingReceipt {\n  return !('block_hash' in response);\n}\n\n/**\n * Guard Pending State Update\n * ex. if(isPendingStateUpdate(stateUpdate)) throw Error('Update must be final')\n */\nexport function isPendingStateUpdate(\n  response: StateUpdateResponse\n): response is PendingStateUpdate {\n  return !('block_hash' in response);\n}\n","import {\n  BigNumberish,\n  CairoVersion,\n  Call,\n  CallStruct,\n  Calldata,\n  ParsedStruct,\n  RawArgs,\n} from '../types';\nimport { ETransactionVersion } from '../types/api';\nimport { CallData } from './calldata';\nimport { getSelectorFromName } from './hash';\nimport { toBigInt } from './num';\n\n/**\n * Transforms a list of Calls, each with their own calldata, into\n * two arrays: one with the entry points, and one with the concatenated calldata\n */\nexport const transformCallsToMulticallArrays = (calls: Call[]) => {\n  const callArray: ParsedStruct[] = [];\n  const calldata: BigNumberish[] = [];\n  calls.forEach((call) => {\n    const data = CallData.compile(call.calldata || []);\n    callArray.push({\n      to: toBigInt(call.contractAddress).toString(10),\n      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n      data_offset: calldata.length.toString(),\n      data_len: data.length.toString(),\n    });\n    calldata.push(...data);\n  });\n  return {\n    callArray,\n    calldata: CallData.compile({ calldata }),\n  };\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata.\n */\nexport const fromCallsToExecuteCalldata = (calls: Call[]) => {\n  const { callArray, calldata } = transformCallsToMulticallArrays(calls);\n  const compiledCalls = CallData.compile({ callArray });\n  return [...compiledCalls, ...calldata] as Calldata;\n};\n\n/**\n * Transforms a list of calls into the Cairo 0 `__execute__` calldata including nonce.\n *\n * @deprecated\n */\nexport const fromCallsToExecuteCalldataWithNonce = (calls: Call[], nonce: BigNumberish) => {\n  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()] as Calldata;\n};\n\n/**\n * Format Data inside Calls\n *\n * @deprecated Not required for getting execute Calldata\n */\nexport const transformCallsToMulticallArrays_cairo1 = (calls: Call[]) => {\n  const callArray = calls.map<CallStruct>((call) => ({\n    to: toBigInt(call.contractAddress).toString(10),\n    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),\n    calldata: CallData.compile(call.calldata || []),\n  }));\n  return callArray;\n};\n\n/**\n * Transforms a list of calls into the Cairo 1 `__execute__` calldata.\n */\nexport const fromCallsToExecuteCalldata_cairo1 = (calls: Call[]) => {\n  // ensure property order\n  const orderCalls = calls.map((call) => ({\n    contractAddress: call.contractAddress,\n    entrypoint: call.entrypoint,\n    calldata:\n      Array.isArray(call.calldata) && '__compiled__' in call.calldata\n        ? call.calldata // Calldata type\n        : CallData.compile(call.calldata as RawArgs), // RawArgsObject | RawArgsArray type\n  }));\n\n  return CallData.compile({ orderCalls });\n};\n\n/**\n * Create `__execute__` Calldata from Calls based on Cairo versions\n */\nexport const getExecuteCalldata = (calls: Call[], cairoVersion: CairoVersion = '0') => {\n  if (cairoVersion === '1') {\n    return fromCallsToExecuteCalldata_cairo1(calls);\n  }\n  return fromCallsToExecuteCalldata(calls);\n};\n\n/**\n * Return transaction versions based on version type, default version type is 'transaction'\n */\nexport function getVersionsByType(versionType?: 'fee' | 'transaction') {\n  return versionType === 'fee'\n    ? {\n        v1: ETransactionVersion.F1,\n        v2: ETransactionVersion.F2,\n        v3: ETransactionVersion.F3,\n      }\n    : { v1: ETransactionVersion.V1, v2: ETransactionVersion.V2, v3: ETransactionVersion.V3 };\n}\n","import { NetworkName, StarknetChainId } from '../constants';\nimport { LibraryError } from '../provider/errors';\nimport {\n  AccountInvocationItem,\n  AccountInvocations,\n  BigNumberish,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  RpcProviderOptions,\n  TransactionType,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { JRPC, RPCSPEC07 as RPC } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { isSierra } from '../utils/contract';\nimport fetch from '../utils/fetchPonyfill';\nimport { getSelector, getSelectorFromName } from '../utils/hash';\nimport { stringify } from '../utils/json';\nimport { getHexStringArray, toHex, toStorageKey } from '../utils/num';\nimport { Block, getDefaultNodeUrl, isV3Tx, isVersion, wait } from '../utils/provider';\nimport { decompressProgram, signatureToHexArray } from '../utils/stark';\nimport { getVersionsByType } from '../utils/transaction';\n\nconst defaultOptions = {\n  headers: { 'Content-Type': 'application/json' },\n  blockIdentifier: BlockTag.pending,\n  retries: 200,\n};\n\nexport class RpcChannel {\n  public nodeUrl: string;\n\n  public headers: object;\n\n  readonly retries: number;\n\n  public requestId: number;\n\n  readonly blockIdentifier: BlockIdentifier;\n\n  private chainId?: StarknetChainId;\n\n  private speckVersion?: string;\n\n  readonly waitMode: Boolean; // behave like web2 rpc and return when tx is processed\n\n  constructor(optionsOrProvider?: RpcProviderOptions) {\n    const { nodeUrl, retries, headers, blockIdentifier, chainId, waitMode } =\n      optionsOrProvider || {};\n    if (Object.values(NetworkName).includes(nodeUrl as NetworkName)) {\n      this.nodeUrl = getDefaultNodeUrl(nodeUrl as NetworkName, optionsOrProvider?.default);\n    } else if (nodeUrl) {\n      this.nodeUrl = nodeUrl;\n    } else {\n      this.nodeUrl = getDefaultNodeUrl(undefined, optionsOrProvider?.default);\n    }\n    this.retries = retries || defaultOptions.retries;\n    this.headers = { ...defaultOptions.headers, ...headers };\n    this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;\n    this.chainId = chainId;\n    this.waitMode = waitMode || false;\n    this.requestId = 0;\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    const rpcRequestBody: JRPC.RequestBody = {\n      id,\n      jsonrpc: '2.0',\n      method,\n      ...(params && { params }),\n    };\n    return fetch(this.nodeUrl, {\n      method: 'POST',\n      body: stringify(rpcRequestBody),\n      headers: this.headers as Record<string, string>,\n    });\n  }\n\n  protected errorHandler(method: string, params: any, rpcError?: JRPC.Error, otherError?: any) {\n    if (rpcError) {\n      const { code, message, data } = rpcError;\n      throw new LibraryError(\n        `RPC: ${method} with params ${stringify(params, null, 2)}\\n \n        ${code}: ${message}: ${stringify(data)}`\n      );\n    }\n    if (otherError instanceof LibraryError) {\n      throw otherError;\n    }\n    if (otherError) {\n      throw Error(otherError.message);\n    }\n  }\n\n  protected async fetchEndpoint<T extends keyof RPC.Methods>(\n    method: T,\n    params?: RPC.Methods[T]['params']\n  ): Promise<RPC.Methods[T]['result']> {\n    try {\n      const rawResult = await this.fetch(method, params, (this.requestId += 1));\n      const { error, result } = await rawResult.json();\n      this.errorHandler(method, params, error);\n      return result as RPC.Methods[T]['result'];\n    } catch (error: any) {\n      this.errorHandler(method, params, error?.response?.data, error);\n      throw error;\n    }\n  }\n\n  public async getChainId() {\n    this.chainId ??= (await this.fetchEndpoint('starknet_chainId')) as StarknetChainId;\n    return this.chainId;\n  }\n\n  public async getSpecVersion() {\n    this.speckVersion ??= (await this.fetchEndpoint('starknet_specVersion')) as StarknetChainId;\n    return this.speckVersion;\n  }\n\n  public getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getNonce', {\n      contract_address,\n      block_id,\n    });\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public getBlockLatestAccepted() {\n    return this.fetchEndpoint('starknet_blockHashAndNumber');\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public getBlockNumber() {\n    return this.fetchEndpoint('starknet_blockNumber');\n  }\n\n  public getBlockWithTxHashes(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id });\n  }\n\n  public getBlockWithTxs(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id });\n  }\n\n  public getBlockWithReceipts(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockWithReceipts', { block_id });\n  }\n\n  public getBlockStateUpdate(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStateUpdate', { block_id });\n  }\n\n  public getBlockTransactionsTraces(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id });\n  }\n\n  public getBlockTransactionCount(blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id });\n  }\n\n  public getTransactionByHash(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionByHash', {\n      transaction_hash,\n    });\n  }\n\n  public getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id, index });\n  }\n\n  public getTransactionReceipt(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash });\n  }\n\n  public getTransactionTrace(txHash: BigNumberish) {\n    const transaction_hash = toHex(txHash);\n    return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash });\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public getTransactionStatus(transactionHash: BigNumberish) {\n    const transaction_hash = toHex(transactionHash);\n    return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash });\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public simulateTransaction(\n    invocations: AccountInvocations,\n    {\n      blockIdentifier = this.blockIdentifier,\n      skipValidate = true,\n      skipFeeCharge = true,\n    }: getSimulateTransactionOptions = {}\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    const simulationFlags: RPC.ESimulationFlag[] = [];\n    if (skipValidate) simulationFlags.push(RPC.ESimulationFlag.SKIP_VALIDATE);\n    if (skipFeeCharge) simulationFlags.push(RPC.ESimulationFlag.SKIP_FEE_CHARGE);\n\n    return this.fetchEndpoint('starknet_simulateTransactions', {\n      block_id,\n      transactions: invocations.map((it) => this.buildTransaction(it)),\n      simulation_flags: simulationFlags,\n    });\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    const transactionHash = toHex(txHash);\n    let { retries } = this;\n    let onchain = false;\n    let isErrorState = false;\n    const retryInterval = options?.retryInterval ?? 5000;\n    const errorStates: any = options?.errorStates ?? [\n      RPC.ETransactionStatus.REJECTED,\n      // TODO: commented out to preserve the long-standing behavior of \"reverted\" not being treated as an error by default\n      // should decide which behavior to keep in the future\n      // RPC.ETransactionExecutionStatus.REVERTED,\n    ];\n    const successStates: any = options?.successStates ?? [\n      RPC.ETransactionExecutionStatus.SUCCEEDED,\n      RPC.ETransactionStatus.ACCEPTED_ON_L2,\n      RPC.ETransactionStatus.ACCEPTED_ON_L1,\n    ];\n\n    let txStatus: RPC.TransactionStatus;\n    while (!onchain) {\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txStatus = await this.getTransactionStatus(transactionHash);\n\n        const executionStatus = txStatus.execution_status;\n        const finalityStatus = txStatus.finality_status;\n\n        if (!finalityStatus) {\n          // Transaction is potentially NOT_RECEIVED or RPC not Synced yet\n          // so we will retry '{ retries }' times\n          const error = new Error('waiting for transaction status');\n          throw error;\n        }\n\n        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {\n          const message = `${executionStatus}: ${finalityStatus}`;\n          const error = new Error(message) as Error & { response: RPC.TransactionStatus };\n          error.response = txStatus;\n          isErrorState = true;\n          throw error;\n        } else if (\n          successStates.includes(executionStatus) ||\n          successStates.includes(finalityStatus)\n        ) {\n          onchain = true;\n        }\n      } catch (error) {\n        if (error instanceof Error && isErrorState) {\n          throw error;\n        }\n\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n\n      retries -= 1;\n    }\n\n    /**\n     * For some nodes even though the transaction has executionStatus SUCCEEDED finalityStatus ACCEPTED_ON_L2, getTransactionReceipt returns \"Transaction hash not found\"\n     * Retry until rpc is actually ready to work with txHash\n     */\n    let txReceipt = null;\n    while (txReceipt === null) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        txReceipt = await this.getTransactionReceipt(transactionHash);\n      } catch (error) {\n        if (retries <= 0) {\n          throw new Error(`waitForTransaction timed-out with retries ${this.retries}`);\n        }\n      }\n      retries -= 1;\n      // eslint-disable-next-line no-await-in-loop\n      await wait(retryInterval);\n    }\n    return txReceipt as RPC.SPEC.TXN_RECEIPT;\n  }\n\n  public getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const parsedKey = toStorageKey(key);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getStorageAt', {\n      contract_address,\n      key: parsedKey,\n      block_id,\n    });\n  }\n\n  public getClassHashAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassHashAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public getClass(\n    classHash: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const class_hash = toHex(classHash);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClass', {\n      class_hash,\n      block_id,\n    });\n  }\n\n  public getClassAt(\n    contractAddress: BigNumberish,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const contract_address = toHex(contractAddress);\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_getClassAt', {\n      block_id,\n      contract_address,\n    });\n  }\n\n  public async getEstimateFee(\n    invocations: AccountInvocations,\n    { blockIdentifier = this.blockIdentifier, skipValidate = true }: getEstimateFeeBulkOptions\n  ) {\n    const block_id = new Block(blockIdentifier).identifier;\n    let flags = {};\n    if (!isVersion('0.5', await this.getSpecVersion())) {\n      flags = {\n        simulation_flags: skipValidate ? [RPC.ESimulationFlag.SKIP_VALIDATE] : [],\n      };\n    } // else v(0.5) no flags\n\n    return this.fetchEndpoint('starknet_estimateFee', {\n      request: invocations.map((it) => this.buildTransaction(it, 'fee')),\n      block_id,\n      ...flags,\n    });\n  }\n\n  public async invoke(functionInvocation: Invocation, details: InvocationsDetailsWithNonce) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // V1\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          type: RPC.ETransactionType.INVOKE,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // V3\n      promise = this.fetchEndpoint('starknet_addInvokeTransaction', {\n        invoke_transaction: {\n          type: RPC.ETransactionType.INVOKE,\n          sender_address: functionInvocation.contractAddress,\n          calldata: CallData.toHex(functionInvocation.calldata),\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(functionInvocation.signature),\n          nonce: toHex(details.nonce),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async declare(\n    { contract, signature, senderAddress, compiledClassHash }: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isSierra(contract) && !isV3Tx(details)) {\n      // V1 Cairo 0\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            program: contract.program,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          version: RPC.ETransactionVersion.V1,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && !isV3Tx(details)) {\n      // V2 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V2,\n          max_fee: toHex(details.maxFee || 0),\n          signature: signatureToHexArray(signature),\n          sender_address: senderAddress,\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else if (isSierra(contract) && isV3Tx(details)) {\n      // V3 Cairo1\n      promise = this.fetchEndpoint('starknet_addDeclareTransaction', {\n        declare_transaction: {\n          type: RPC.ETransactionType.DECLARE,\n          sender_address: senderAddress,\n          compiled_class_hash: compiledClassHash || '',\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_class: {\n            sierra_program: decompressProgram(contract.sierra_program),\n            contract_class_version: contract.contract_class_version,\n            entry_points_by_type: contract.entry_points_by_type,\n            abi: contract.abi,\n          },\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          account_deployment_data: details.accountDeploymentData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    } else {\n      throw Error('declare unspotted parameters');\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public async deployAccount(\n    { classHash, constructorCalldata, addressSalt, signature }: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    let promise;\n    if (!isV3Tx(details)) {\n      // v1\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          contract_address_salt: toHex(addressSalt || 0),\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          max_fee: toHex(details.maxFee || 0),\n          version: RPC.ETransactionVersion.V1,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n        },\n      });\n    } else {\n      // v3\n      promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {\n        deploy_account_transaction: {\n          type: RPC.ETransactionType.DEPLOY_ACCOUNT,\n          version: RPC.ETransactionVersion.V3,\n          signature: signatureToHexArray(signature),\n          nonce: toHex(details.nonce),\n          contract_address_salt: toHex(addressSalt || 0),\n          constructor_calldata: CallData.toHex(constructorCalldata || []),\n          class_hash: toHex(classHash),\n          resource_bounds: details.resourceBounds,\n          tip: toHex(details.tip),\n          paymaster_data: details.paymasterData.map((it) => toHex(it)),\n          nonce_data_availability_mode: details.nonceDataAvailabilityMode,\n          fee_data_availability_mode: details.feeDataAvailabilityMode,\n        },\n      });\n    }\n\n    return this.waitMode ? this.waitForTransaction((await promise).transaction_hash) : promise;\n  }\n\n  public callContract(call: Call, blockIdentifier: BlockIdentifier = this.blockIdentifier) {\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_call', {\n      request: {\n        contract_address: call.contractAddress,\n        entry_point_selector: getSelectorFromName(call.entrypoint),\n        calldata: CallData.toHex(call.calldata),\n      },\n      block_id,\n    });\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public estimateMessageFee(\n    message: RPC.L1Message,\n    blockIdentifier: BlockIdentifier = this.blockIdentifier\n  ) {\n    const { from_address, to_address, entry_point_selector, payload } = message;\n    const formattedMessage = {\n      from_address: toHex(from_address),\n      to_address: toHex(to_address),\n      entry_point_selector: getSelector(entry_point_selector),\n      payload: getHexStringArray(payload),\n    };\n\n    const block_id = new Block(blockIdentifier).identifier;\n    return this.fetchEndpoint('starknet_estimateMessageFee', {\n      message: formattedMessage,\n      block_id,\n    });\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public getSyncingStats() {\n    return this.fetchEndpoint('starknet_syncing');\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public getEvents(eventFilter: RPC.EventFilter) {\n    return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });\n  }\n\n  public buildTransaction(\n    invocation: AccountInvocationItem,\n    versionType?: 'fee' | 'transaction'\n  ): RPC.BaseTransaction {\n    const defaultVersions = getVersionsByType(versionType);\n    let details;\n\n    if (!isV3Tx(invocation)) {\n      // V0,V1,V2\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        max_fee: toHex(invocation.maxFee || 0),\n      };\n    } else {\n      // V3\n      details = {\n        signature: signatureToHexArray(invocation.signature),\n        nonce: toHex(invocation.nonce),\n        resource_bounds: invocation.resourceBounds,\n        tip: toHex(invocation.tip),\n        paymaster_data: invocation.paymasterData.map((it) => toHex(it)),\n        nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,\n        fee_data_availability_mode: invocation.feeDataAvailabilityMode,\n        account_deployment_data: invocation.accountDeploymentData.map((it) => toHex(it)),\n      };\n    }\n\n    if (invocation.type === TransactionType.INVOKE) {\n      return {\n        // v0 v1 v3\n        type: RPC.ETransactionType.INVOKE, // TODO: Diff between sequencer and rpc invoke type\n        sender_address: invocation.contractAddress,\n        calldata: CallData.toHex(invocation.calldata),\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_INVOKE_TXN;\n    }\n    if (invocation.type === TransactionType.DECLARE) {\n      if (!isSierra(invocation.contract)) {\n        // Cairo 0 - v1\n        return {\n          type: invocation.type,\n          contract_class: invocation.contract,\n          sender_address: invocation.senderAddress,\n          version: toHex(invocation.version || defaultVersions.v1),\n          ...details,\n        } as RPC.SPEC.BROADCASTED_DECLARE_TXN_V1;\n      }\n      return {\n        // Cairo 1 - v2 v3\n        type: invocation.type,\n        contract_class: {\n          ...invocation.contract,\n          sierra_program: decompressProgram(invocation.contract.sierra_program),\n        },\n        compiled_class_hash: invocation.compiledClassHash || '',\n        sender_address: invocation.senderAddress,\n        version: toHex(invocation.version || defaultVersions.v3),\n        ...details,\n      } as RPC.SPEC.BROADCASTED_DECLARE_TXN;\n    }\n    if (invocation.type === TransactionType.DEPLOY_ACCOUNT) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { account_deployment_data, ...restDetails } = details;\n      // v1 v3\n      return {\n        type: invocation.type,\n        constructor_calldata: CallData.toHex(invocation.constructorCalldata || []),\n        class_hash: toHex(invocation.classHash),\n        contract_address_salt: toHex(invocation.addressSalt || 0),\n        version: toHex(invocation.version || defaultVersions.v3) as RPC.SPEC.INVOKE_TXN['version'],\n        ...restDetails,\n      } as RPC.SPEC.BROADCASTED_DEPLOY_ACCOUNT_TXN;\n    }\n    throw Error('RPC buildTransaction received unknown TransactionType');\n  }\n}\n","/**\n * Map RPC Response to common interface response\n * Intersection (sequencer response ∩ (∪ rpc responses))\n */\nimport {\n  BlockWithTxHashes,\n  ContractClassPayload,\n  ContractClassResponse,\n  TransactionReceipt,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  GetBlockResponse,\n  GetTransactionReceiptResponse,\n  FeeEstimate,\n  SimulateTransactionResponse,\n  SimulatedTransaction,\n  RpcProviderOptions,\n} from '../../types/provider';\nimport { toBigInt } from '../num';\nimport { estimateFeeToBounds, estimatedFeeToMaxFee } from '../stark';\nimport { ResponseParser } from '.';\n\nexport class RPCResponseParser\n  implements\n    Omit<\n      ResponseParser,\n      | 'parseDeclareContractResponse'\n      | 'parseDeployContractResponse'\n      | 'parseInvokeFunctionResponse'\n      | 'parseGetTransactionReceiptResponse'\n      | 'parseGetTransactionResponse'\n      | 'parseCallContractResponse'\n    >\n{\n  private margin: RpcProviderOptions['feeMarginPercentage'];\n\n  constructor(margin?: RpcProviderOptions['feeMarginPercentage']) {\n    this.margin = margin;\n  }\n\n  private estimatedFeeToMaxFee(estimatedFee: Parameters<typeof estimatedFeeToMaxFee>[0]) {\n    return estimatedFeeToMaxFee(estimatedFee, this.margin?.maxFee);\n  }\n\n  private estimateFeeToBounds(estimate: Parameters<typeof estimateFeeToBounds>[0]) {\n    return estimateFeeToBounds(\n      estimate,\n      this.margin?.l1BoundMaxAmount,\n      this.margin?.l1BoundMaxPricePerUnit\n    );\n  }\n\n  public parseGetBlockResponse(res: BlockWithTxHashes): GetBlockResponse {\n    return { status: 'PENDING', ...res } as GetBlockResponse;\n  }\n\n  public parseTransactionReceipt(res: TransactionReceipt): GetTransactionReceiptResponse {\n    // HOTFIX RPC 0.5 to align with RPC 0.6\n    // This case is RPC 0.5. It can be only v2 thx with FRI units\n    if ('actual_fee' in res && typeof res.actual_fee === 'string') {\n      return {\n        ...(res as GetTransactionReceiptResponse),\n        actual_fee: {\n          amount: res.actual_fee,\n          unit: 'FRI',\n        },\n      };\n    }\n\n    return res as GetTransactionReceiptResponse;\n  }\n\n  public parseFeeEstimateResponse(res: FeeEstimate[]): EstimateFeeResponse {\n    const val = res[0];\n    return {\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n    };\n  }\n\n  public parseFeeEstimateBulkResponse(res: FeeEstimate[]): EstimateFeeResponseBulk {\n    return res.map((val) => ({\n      overall_fee: toBigInt(val.overall_fee),\n      gas_consumed: toBigInt(val.gas_consumed),\n      gas_price: toBigInt(val.gas_price),\n      unit: val.unit,\n      suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),\n      resourceBounds: this.estimateFeeToBounds(val),\n    }));\n  }\n\n  public parseSimulateTransactionResponse(\n    // TODO: revisit\n    // set as 'any' to avoid a mapped type circular recursion error stemming from\n    // merging src/types/api/rpcspec*/components/FUNCTION_INVOCATION.calls\n    //\n    // res: SimulateTransactionResponse\n    res: any\n  ): SimulateTransactionResponse {\n    return res.map((it: SimulatedTransaction) => {\n      return {\n        ...it,\n        suggestedMaxFee: this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee),\n        resourceBounds: this.estimateFeeToBounds(it.fee_estimation),\n      };\n    });\n  }\n\n  public parseContractClassResponse(res: ContractClassPayload): ContractClassResponse {\n    return {\n      ...(res as ContractClassResponse),\n      abi: typeof res.abi === 'string' ? JSON.parse(res.abi) : res.abi,\n    };\n  }\n}\n","import { ProviderInterface } from './interface';\nimport { LibraryError } from './errors';\nimport { RpcChannel, RPC06, RPC07 } from '../channel';\nimport {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  BlockTag,\n  Call,\n  ContractVersion,\n  DeclareContractTransaction,\n  DeployAccountContractTransaction,\n  GetBlockResponse,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  PendingBlock,\n  PendingStateUpdate,\n  RPC,\n  RpcProviderOptions,\n  StateUpdate,\n  StateUpdateResponse,\n  TransactionType,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\nimport { getAbiContractVersion } from '../utils/calldata/cairo';\nimport { isSierra } from '../utils/contract';\nimport { RPCResponseParser } from '../utils/responseParser/rpc';\n\nexport class RpcProvider implements ProviderInterface {\n  private responseParser: RPCResponseParser;\n\n  public channel: RPC07.RpcChannel | RPC06.RpcChannel;\n\n  constructor(optionsOrProvider?: RpcProviderOptions | ProviderInterface | RpcProvider) {\n    if (optionsOrProvider && 'channel' in optionsOrProvider) {\n      this.channel = optionsOrProvider.channel;\n      this.responseParser = (optionsOrProvider as any).responseParser;\n    } else {\n      this.channel = new RpcChannel({ ...optionsOrProvider, waitMode: false });\n      this.responseParser = new RPCResponseParser(optionsOrProvider?.feeMarginPercentage);\n    }\n  }\n\n  public fetch(method: string, params?: object, id: string | number = 0) {\n    return this.channel.fetch(method, params, id);\n  }\n\n  public async getChainId() {\n    return this.channel.getChainId();\n  }\n\n  public async getSpecVersion() {\n    return this.channel.getSpecVersion();\n  }\n\n  public async getNonceForAddress(\n    contractAddress: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getNonceForAddress(contractAddress, blockIdentifier);\n  }\n\n  public async getBlock(): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'pending'): Promise<PendingBlock>;\n  public async getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public async getBlock(blockIdentifier?: BlockIdentifier): Promise<GetBlockResponse>;\n  public async getBlock(blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getBlockWithTxHashes(blockIdentifier)\n      .then(this.responseParser.parseGetBlockResponse);\n  }\n\n  /**\n   * Get the most recent accepted block hash and number\n   */\n  public async getBlockLatestAccepted() {\n    return this.channel.getBlockLatestAccepted();\n  }\n\n  /**\n   * Get the most recent accepted block number\n   * redundant use getBlockLatestAccepted();\n   * @returns Number of the latest block\n   */\n  public async getBlockNumber() {\n    return this.channel.getBlockNumber();\n  }\n\n  public async getBlockWithTxHashes(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxHashes(blockIdentifier);\n  }\n\n  public async getBlockWithTxs(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockWithTxs(blockIdentifier);\n  }\n\n  public async getBlockWithReceipts(blockIdentifier?: BlockIdentifier) {\n    if (this.channel instanceof RPC06.RpcChannel)\n      throw new LibraryError('Unsupported method for RPC version');\n\n    return this.channel.getBlockWithReceipts(blockIdentifier);\n  }\n\n  public getStateUpdate = this.getBlockStateUpdate;\n\n  public async getBlockStateUpdate(): Promise<PendingStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'pending'): Promise<PendingStateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier: 'latest'): Promise<StateUpdate>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n  public async getBlockStateUpdate(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockStateUpdate(blockIdentifier);\n  }\n\n  public async getBlockTransactionsTraces(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionsTraces(blockIdentifier);\n  }\n\n  public async getBlockTransactionCount(blockIdentifier?: BlockIdentifier) {\n    return this.channel.getBlockTransactionCount(blockIdentifier);\n  }\n\n  /**\n   * Return transactions from pending block\n   * @deprecated Instead use getBlock(BlockTag.pending); (will be removed in next minor version)\n   * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);\n   */\n  public async getPendingTransactions() {\n    const { transactions } = await this.getBlockWithTxHashes(BlockTag.pending).then(\n      this.responseParser.parseGetBlockResponse\n    );\n    return Promise.all(transactions.map((it: any) => this.getTransactionByHash(it)));\n  }\n\n  public async getTransaction(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByHash(txHash: BigNumberish) {\n    return this.channel.getTransactionByHash(txHash);\n  }\n\n  public async getTransactionByBlockIdAndIndex(blockIdentifier: BlockIdentifier, index: number) {\n    return this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index);\n  }\n\n  public async getTransactionReceipt(txHash: BigNumberish) {\n    return this.channel\n      .getTransactionReceipt(txHash)\n      .then(this.responseParser.parseTransactionReceipt);\n  }\n\n  public async getTransactionTrace(txHash: BigNumberish) {\n    return this.channel.getTransactionTrace(txHash);\n  }\n\n  /**\n   * Get the status of a transaction\n   */\n  public async getTransactionStatus(transactionHash: BigNumberish) {\n    return this.channel.getTransactionStatus(transactionHash);\n  }\n\n  /**\n   * @param invocations AccountInvocations\n   * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>\n   * - blockIdentifier<br/>\n   * - skipValidate (default false)<br/>\n   * - skipFeeCharge (default true)<br/>\n   */\n  public async getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ) {\n    // can't be named simulateTransaction because of argument conflict with account\n    return this.channel\n      .simulateTransaction(invocations, options)\n      .then((r) => this.responseParser.parseSimulateTransactionResponse(r));\n  }\n\n  public async waitForTransaction(txHash: BigNumberish, options?: waitForTransactionOptions) {\n    return this.channel.waitForTransaction(txHash, options);\n  }\n\n  public async getStorageAt(\n    contractAddress: BigNumberish,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ) {\n    return this.channel.getStorageAt(contractAddress, key, blockIdentifier);\n  }\n\n  public async getClassHashAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel.getClassHashAt(contractAddress, blockIdentifier);\n  }\n\n  public async getClassByHash(classHash: BigNumberish) {\n    return this.getClass(classHash);\n  }\n\n  public async getClass(classHash: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClass(classHash, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getClassAt(contractAddress: BigNumberish, blockIdentifier?: BlockIdentifier) {\n    return this.channel\n      .getClassAt(contractAddress, blockIdentifier)\n      .then(this.responseParser.parseContractClassResponse);\n  }\n\n  public async getContractVersion(\n    contractAddress: BigNumberish,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n  public async getContractVersion(\n    contractAddress: undefined,\n    classHash: BigNumberish,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  public async getContractVersion(\n    contractAddress?: BigNumberish,\n    classHash?: BigNumberish,\n    {\n      blockIdentifier = this.channel.blockIdentifier,\n      compiler = true,\n    }: getContractVersionOptions = {}\n  ): Promise<ContractVersion> {\n    let contractClass;\n    if (contractAddress) {\n      contractClass = await this.getClassAt(contractAddress, blockIdentifier);\n    } else if (classHash) {\n      contractClass = await this.getClass(classHash, blockIdentifier);\n    } else {\n      throw Error('getContractVersion require contractAddress or classHash');\n    }\n\n    if (isSierra(contractClass)) {\n      if (compiler) {\n        const abiTest = getAbiContractVersion(contractClass.abi);\n        return { cairo: '1', compiler: abiTest.compiler };\n      }\n      return { cairo: '1', compiler: undefined };\n    }\n    return { cairo: '0', compiler: '0' };\n  }\n\n  /**\n   * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)\n   */\n  public async getEstimateFee(\n    invocation: Invocation,\n    invocationDetails: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate);\n  }\n\n  public async getInvokeEstimateFee(\n    invocation: Invocation,\n    invocationDetails: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.INVOKE,\n            ...invocation,\n            ...invocationDetails,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getDeclareEstimateFee(\n    invocation: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.DECLARE,\n            ...invocation,\n            ...details,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getDeployAccountEstimateFee(\n    invocation: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ) {\n    return this.channel\n      .getEstimateFee(\n        [\n          {\n            type: TransactionType.DEPLOY_ACCOUNT,\n            ...invocation,\n            ...details,\n          },\n        ],\n        { blockIdentifier, skipValidate }\n      )\n      .then((r) => this.responseParser.parseFeeEstimateResponse(r));\n  }\n\n  public async getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options: getEstimateFeeBulkOptions\n  ) {\n    return this.channel\n      .getEstimateFee(invocations, options)\n      .then((r) => this.responseParser.parseFeeEstimateBulkResponse(r));\n  }\n\n  public async invokeFunction(\n    functionInvocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.invoke(functionInvocation, details) as Promise<RPC.InvokedTransaction>;\n  }\n\n  public async declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.declare(transaction, details) as Promise<RPC.DeclaredTransaction>;\n  }\n\n  public async deployAccountContract(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ) {\n    return this.channel.deployAccount(\n      transaction,\n      details\n    ) as Promise<RPC.DeployedAccountTransaction>;\n  }\n\n  public async callContract(call: Call, blockIdentifier?: BlockIdentifier) {\n    return this.channel.callContract(call, blockIdentifier);\n  }\n\n  /**\n   * NEW: Estimate the fee for a message from L1\n   * @param message Message From L1\n   */\n  public async estimateMessageFee(message: RPC.L1Message, blockIdentifier?: BlockIdentifier) {\n    return this.channel.estimateMessageFee(message, blockIdentifier);\n  }\n\n  /**\n   * Returns an object about the sync status, or false if the node is not synching\n   * @returns Object with the stats data\n   */\n  public async getSyncingStats() {\n    return this.channel.getSyncingStats();\n  }\n\n  /**\n   * Returns all events matching the given filter\n   * @returns events and the pagination of the events\n   */\n  public async getEvents(eventFilter: RPC.EventFilter) {\n    return this.channel.getEvents(eventFilter);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { Mixin } from 'ts-mixer';\n\nimport { RpcProvider as BaseRpcProvider } from '../rpc';\nimport { StarknetId } from './starknetId';\n\nexport class RpcProvider extends Mixin(BaseRpcProvider, StarknetId) {}\n","import { StarknetChainId, ZERO } from '../constants';\nimport { BigNumberish } from '../types';\nimport { tuple } from './calldata/cairo';\nimport { CairoCustomEnum } from './calldata/enum/CairoCustomEnum';\n/* eslint-disable no-param-reassign */\n\nconst basicAlphabet = 'abcdefghijklmnopqrstuvwxyz0123456789-';\nconst basicSizePlusOne = BigInt(basicAlphabet.length + 1);\nconst bigAlphabet = '这来';\nconst basicAlphabetSize = BigInt(basicAlphabet.length);\nconst bigAlphabetSize = BigInt(bigAlphabet.length);\nconst bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);\n\nfunction extractStars(str: string): [string, number] {\n  let k = 0;\n  while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {\n    str = str.substring(0, str.length - 1);\n    k += 1;\n  }\n  return [str, k];\n}\n\nexport function useDecoded(encoded: bigint[]): string {\n  let decoded = '';\n\n  encoded.forEach((subdomain) => {\n    while (subdomain !== ZERO) {\n      const code = subdomain % basicSizePlusOne;\n      subdomain /= basicSizePlusOne;\n      if (code === BigInt(basicAlphabet.length)) {\n        const nextSubdomain = subdomain / bigAlphabetSizePlusOne;\n        if (nextSubdomain === ZERO) {\n          const code2 = subdomain % bigAlphabetSizePlusOne;\n          subdomain = nextSubdomain;\n          if (code2 === ZERO) decoded += basicAlphabet[0];\n          else decoded += bigAlphabet[Number(code2) - 1];\n        } else {\n          const code2 = subdomain % bigAlphabetSize;\n          decoded += bigAlphabet[Number(code2)];\n          subdomain /= bigAlphabetSize;\n        }\n      } else decoded += basicAlphabet[Number(code)];\n    }\n\n    const [str, k] = extractStars(decoded);\n    if (k)\n      decoded =\n        str +\n        (k % 2 === 0\n          ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) +\n            bigAlphabet[0] +\n            basicAlphabet[1]\n          : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));\n    decoded += '.';\n  });\n\n  if (!decoded) {\n    return decoded;\n  }\n\n  return decoded.concat('stark');\n}\n\nexport function useEncoded(decoded: string): bigint {\n  let encoded = BigInt(0);\n  let multiplier = BigInt(1);\n\n  if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {\n    const [str, k] = extractStars(decoded.substring(0, decoded.length - 2));\n    decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));\n  } else {\n    const [str, k] = extractStars(decoded);\n    if (k) decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));\n  }\n\n  for (let i = 0; i < decoded.length; i += 1) {\n    const char = decoded[i];\n    const index = basicAlphabet.indexOf(char);\n    const bnIndex = BigInt(basicAlphabet.indexOf(char));\n\n    if (index !== -1) {\n      // add encoded + multiplier * index\n      if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {\n        encoded += multiplier * basicAlphabetSize;\n        multiplier *= basicSizePlusOne;\n        // add 0\n        multiplier *= basicSizePlusOne;\n      } else {\n        encoded += multiplier * bnIndex;\n        multiplier *= basicSizePlusOne;\n      }\n    } else if (bigAlphabet.indexOf(char) !== -1) {\n      // add encoded + multiplier * (basicAlphabetSize)\n      encoded += multiplier * basicAlphabetSize;\n      multiplier *= basicSizePlusOne;\n      // add encoded + multiplier * index\n      const newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);\n      encoded += multiplier * BigInt(newid);\n      multiplier *= bigAlphabetSize;\n    }\n  }\n\n  return encoded;\n}\n\nexport const enum StarknetIdContract {\n  MAINNET = '0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678',\n  TESTNET = '0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce',\n  TESTNET_SEPOLIA = '0x0707f09bc576bd7cfee59694846291047e965f4184fe13dac62c56759b3b6fa7',\n}\n\nexport function getStarknetIdContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdContract.MAINNET;\n\n    case StarknetChainId.SN_GOERLI:\n      return StarknetIdContract.TESTNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id is not yet deployed on this network');\n  }\n}\n\nexport const enum StarknetIdIdentityContract {\n  MAINNET = '0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af',\n  TESTNET = '0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d',\n  TESTNET_SEPOLIA = '0x070DF8B4F5cb2879f8592849fA8f3134da39d25326B8558cc9C8FE8D47EA3A90',\n}\n\nexport function getStarknetIdIdentityContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdIdentityContract.MAINNET;\n\n    case StarknetChainId.SN_GOERLI:\n      return StarknetIdIdentityContract.TESTNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdIdentityContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const StarknetIdMulticallContract =\n  '0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970';\n\nexport function getStarknetIdMulticallContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdMulticallContract;\n\n    case StarknetChainId.SN_GOERLI:\n      return StarknetIdMulticallContract;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdMulticallContract;\n\n    default:\n      throw new Error('Starknet.id multicall contract is not yet deployed on this network');\n  }\n}\n\nexport const enum StarknetIdVerifierContract {\n  MAINNET = '0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf',\n  TESTNET = '0x057c942544063c3aea6ea6c37009cc9d1beacd750cb6801549a129c7265f0f11',\n  TESTNET_SEPOLIA = '0x0182EcE8173C216A395f4828e1523541b7e3600bf190CB252E1a1A0cE219d184',\n}\n\nexport function getStarknetIdVerifierContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdVerifierContract.MAINNET;\n\n    case StarknetChainId.SN_GOERLI:\n      return StarknetIdVerifierContract.TESTNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdVerifierContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error('Starknet.id verifier contract is not yet deployed on this network');\n  }\n}\n\nexport const enum StarknetIdPfpContract {\n  MAINNET = '0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7',\n  TESTNET = '0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698',\n  TESTNET_SEPOLIA = '0x058061bb6bdc501eE215172c9f87d557C1E0f466dC498cA81b18f998Bf1362b2',\n}\n\nexport function getStarknetIdPfpContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPfpContract.MAINNET;\n\n    case StarknetChainId.SN_GOERLI:\n      return StarknetIdPfpContract.TESTNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPfpContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id profile picture verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\nexport const enum StarknetIdPopContract {\n  MAINNET = '0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4',\n  TESTNET = '0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106',\n  TESTNET_SEPOLIA = '0x0023FE3b845ed5665a9eb3792bbB17347B490EE4090f855C1298d03BB5F49B49',\n}\n\nexport function getStarknetIdPopContract(chainId: StarknetChainId): string {\n  switch (chainId) {\n    case StarknetChainId.SN_MAIN:\n      return StarknetIdPopContract.MAINNET;\n\n    case StarknetChainId.SN_GOERLI:\n      return StarknetIdPopContract.TESTNET;\n\n    case StarknetChainId.SN_SEPOLIA:\n      return StarknetIdPopContract.TESTNET_SEPOLIA;\n\n    default:\n      throw new Error(\n        'Starknet.id proof of personhood verifier contract is not yet deployed on this network'\n      );\n  }\n}\n\n// Functions to build CairoCustomEnum for multicall contracts\nexport function execution(\n  staticEx: {} | undefined,\n  ifEqual: number[] | undefined = undefined,\n  ifNotEqual: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Static: staticEx,\n    IfEqual: ifEqual ? tuple(ifEqual[0], ifEqual[1], ifEqual[2]) : undefined,\n    IfNotEqual: ifNotEqual ? tuple(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : undefined,\n  });\n}\n\nexport function dynamicFelt(\n  hardcoded: BigNumberish | undefined,\n  reference: number[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n  });\n}\n\nexport function dynamicCallData(\n  hardcoded: BigNumberish | undefined,\n  reference: BigNumberish[] | undefined = undefined,\n  arrayReference: BigNumberish[] | undefined = undefined\n): CairoCustomEnum {\n  return new CairoCustomEnum({\n    Hardcoded: hardcoded,\n    Reference: reference ? tuple(reference[0], reference[1]) : undefined,\n    ArrayReference: arrayReference ? tuple(arrayReference[0], arrayReference[1]) : undefined,\n  });\n}\n","import { BigNumberish, StarkProfile } from '../../types';\nimport { CallData } from '../../utils/calldata';\nimport { getSelectorFromName } from '../../utils/hash';\nimport { decodeShortString, encodeShortString } from '../../utils/shortString';\nimport {\n  dynamicCallData,\n  dynamicFelt,\n  execution,\n  getStarknetIdContract,\n  getStarknetIdIdentityContract,\n  getStarknetIdMulticallContract,\n  getStarknetIdPfpContract,\n  getStarknetIdPopContract,\n  getStarknetIdVerifierContract,\n  useDecoded,\n  useEncoded,\n} from '../../utils/starknetId';\nimport type { ProviderInterface } from '..';\n\nexport class StarknetId {\n  async getStarkName(address: BigNumberish, StarknetIdContract?: string) {\n    return StarknetId.getStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract\n    );\n  }\n\n  public async getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise<string> {\n    return StarknetId.getAddressFromStarkName(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      name,\n      StarknetIdContract\n    );\n  }\n\n  async getStarkProfile(\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ) {\n    return StarknetId.getStarkProfile(\n      // After Mixin, this is ProviderInterface\n      (<unknown>this) as ProviderInterface,\n      address,\n      StarknetIdContract,\n      StarknetIdIdentityContract,\n      StarknetIdVerifierContract,\n      StarknetIdPfpContract,\n      StarknetIdPopContract,\n      StarknetIdMulticallContract\n    );\n  }\n\n  static async getStarkName(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const hexDomain = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'address_to_domain',\n        calldata: CallData.compile({\n          address,\n        }),\n      });\n      const decimalDomain = hexDomain.map((element) => BigInt(element)).slice(1);\n\n      const stringDomain = useDecoded(decimalDomain);\n\n      if (!stringDomain) {\n        throw Error('Starkname not found');\n      }\n\n      return stringDomain;\n    } catch (e) {\n      if (e instanceof Error && e.message === 'Starkname not found') {\n        throw e;\n      }\n      throw Error('Could not get stark name');\n    }\n  }\n\n  static async getAddressFromStarkName(\n    provider: ProviderInterface,\n    name: string,\n    StarknetIdContract?: string\n  ): Promise<string> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n\n    try {\n      const encodedDomain = name\n        .replace('.stark', '')\n        .split('.')\n        .map((part) => useEncoded(part).toString(10));\n\n      const addressData = await provider.callContract({\n        contractAddress: contract,\n        entrypoint: 'domain_to_address',\n        calldata: CallData.compile({ domain: encodedDomain, hint: [] }),\n      });\n\n      return addressData[0];\n    } catch {\n      throw Error('Could not get address from stark name');\n    }\n  }\n\n  static async getStarkProfile(\n    provider: ProviderInterface,\n    address: BigNumberish,\n    StarknetIdContract?: string,\n    StarknetIdIdentityContract?: string,\n    StarknetIdVerifierContract?: string,\n    StarknetIdPfpContract?: string,\n    StarknetIdPopContract?: string,\n    StarknetIdMulticallContract?: string\n  ): Promise<StarkProfile> {\n    const chainId = await provider.getChainId();\n    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);\n    const identityContract = StarknetIdIdentityContract ?? getStarknetIdIdentityContract(chainId);\n    const verifierContract = StarknetIdVerifierContract ?? getStarknetIdVerifierContract(chainId);\n    const pfpContract = StarknetIdPfpContract ?? getStarknetIdPfpContract(chainId);\n    const popContract = StarknetIdPopContract ?? getStarknetIdPopContract(chainId);\n    const multicallAddress = StarknetIdMulticallContract ?? getStarknetIdMulticallContract(chainId);\n\n    try {\n      const data = await provider.callContract({\n        contractAddress: multicallAddress,\n        entrypoint: 'aggregate',\n        calldata: CallData.compile({\n          calls: [\n            {\n              execution: execution({}),\n              to: dynamicFelt(contract),\n              selector: dynamicFelt(getSelectorFromName('address_to_domain')),\n              calldata: [dynamicCallData(address)],\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(contract),\n              selector: dynamicFelt(getSelectorFromName('domain_to_id')),\n              calldata: [dynamicCallData(undefined, undefined, [0, 0])],\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n              calldata: [\n                dynamicCallData(undefined, [1, 0]),\n                dynamicCallData(encodeShortString('twitter')),\n                dynamicCallData(verifierContract),\n                dynamicCallData('0'),\n              ],\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n              calldata: [\n                dynamicCallData(undefined, [1, 0]),\n                dynamicCallData(encodeShortString('github')),\n                dynamicCallData(verifierContract),\n                dynamicCallData('0'),\n              ],\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n              calldata: [\n                dynamicCallData(undefined, [1, 0]),\n                dynamicCallData(encodeShortString('discord')),\n                dynamicCallData(verifierContract),\n                dynamicCallData('0'),\n              ],\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n              calldata: [\n                dynamicCallData(undefined, [1, 0]),\n                dynamicCallData(encodeShortString('proof_of_personhood')),\n                dynamicCallData(popContract),\n                dynamicCallData('0'),\n              ],\n            },\n            // PFP\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName('get_verifier_data')),\n              calldata: [\n                dynamicCallData(undefined, [1, 0]),\n                dynamicCallData(encodeShortString('nft_pp_contract')),\n                dynamicCallData(pfpContract),\n                dynamicCallData('0'),\n              ],\n            },\n            {\n              execution: execution({}),\n              to: dynamicFelt(identityContract),\n              selector: dynamicFelt(getSelectorFromName('get_extended_verifier_data')),\n              calldata: [\n                dynamicCallData(undefined, [1, 0]),\n                dynamicCallData(encodeShortString('nft_pp_id')),\n                dynamicCallData('2'),\n                dynamicCallData(pfpContract),\n                dynamicCallData('0'),\n              ],\n            },\n            {\n              execution: execution(undefined, undefined, [6, 0, 0]),\n              to: dynamicFelt(undefined, [6, 0]),\n              selector: dynamicFelt(getSelectorFromName('tokenURI')),\n              calldata: [dynamicCallData(undefined, [7, 1]), dynamicCallData(undefined, [7, 2])],\n            },\n          ],\n        }),\n      });\n\n      if (Array.isArray(data)) {\n        // Format data\n        const size = parseInt(data[0], 16);\n        const finalArray: string[][] = [];\n        let index = 1;\n        for (let i = 0; i < size; i += 1) {\n          if (index < data.length) {\n            const subArraySize = parseInt(data[index], 16);\n            index += 1;\n\n            const subArray = data.slice(index, index + subArraySize);\n            finalArray.push(subArray);\n\n            index += subArraySize;\n          } else {\n            break;\n          }\n        }\n\n        const name = useDecoded(finalArray[0].slice(1).map((hexString) => BigInt(hexString)));\n\n        const twitter =\n          finalArray[2][0] !== '0x0' ? BigInt(finalArray[2][0]).toString() : undefined;\n        const github = finalArray[3][0] !== '0x0' ? BigInt(finalArray[3][0]).toString() : undefined;\n        const discord =\n          finalArray[4][0] !== '0x0' ? BigInt(finalArray[4][0]).toString() : undefined;\n        const proofOfPersonhood = finalArray[5][0] === '0x1'; // 10\n\n        const profilePictureMetadata =\n          data[0] === '0x9'\n            ? finalArray[8]\n                .slice(1)\n                .map((val: string) => decodeShortString(val))\n                .join('')\n            : undefined;\n\n        const profilePicture =\n          profilePictureMetadata ||\n          `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;\n\n        return {\n          name,\n          twitter,\n          github,\n          discord,\n          proofOfPersonhood,\n          profilePicture,\n        };\n      }\n      throw Error('Error while calling aggregate function');\n    } catch (e) {\n      if (e instanceof Error) {\n        throw e;\n      }\n      throw Error('Could not get user stark profile data from address');\n    }\n  }\n}\n","import { RPC06, RPC07 } from '../channel';\nimport { StarknetChainId } from '../constants';\nimport type {\n  AccountInvocations,\n  BigNumberish,\n  Block,\n  BlockIdentifier,\n  Call,\n  CallContractResponse,\n  ContractClassResponse,\n  ContractVersion,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  GetBlockResponse,\n  GetTransactionReceiptResponse,\n  GetTransactionResponse,\n  Invocation,\n  InvocationsDetailsWithNonce,\n  InvokeFunctionResponse,\n  Nonce,\n  PendingBlock,\n  SimulateTransactionResponse,\n  StateUpdateResponse,\n  Storage,\n  getContractVersionOptions,\n  getEstimateFeeBulkOptions,\n  getSimulateTransactionOptions,\n  waitForTransactionOptions,\n} from '../types';\n\nexport abstract class ProviderInterface {\n  public abstract channel: RPC07.RpcChannel | RPC06.RpcChannel;\n\n  /**\n   * Gets the Starknet chain Id\n   *\n   * @returns the chain Id\n   */\n  public abstract getChainId(): Promise<StarknetChainId>;\n\n  /**\n   * Calls a function on the Starknet contract.\n   *\n   * @param call transaction to be called\n   * @param blockIdentifier block identifier\n   * @returns the result of the function on the smart contract.\n   */\n  public abstract callContract(\n    call: Call,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<CallContractResponse>;\n\n  /**\n   * Gets the block information\n   *\n   * @param blockIdentifier block identifier\n   * @returns the block object\n   */\n  public abstract getBlock(): Promise<PendingBlock>;\n  public abstract getBlock(blockIdentifier: 'pending'): Promise<PendingBlock>;\n  public abstract getBlock(blockIdentifier: 'latest'): Promise<Block>;\n  public abstract getBlock(blockIdentifier: BlockIdentifier): Promise<GetBlockResponse>;\n\n  /**\n   * Gets the contract class of the deployed contract.\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassAt(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<ContractClassResponse>;\n\n  /**\n   * Returns the contract class hash in the given block for the contract deployed at the given address\n   *\n   * @param contractAddress - contract address\n   * @param blockIdentifier - block identifier\n   * @returns Class hash\n   */\n  public abstract getClassHashAt(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<string>;\n\n  /**\n   * Returns the contract class deployed under the given class hash.\n   *\n   * @param classHash - class hash\n   * @returns Contract class of compiled contract\n   */\n  public abstract getClassByHash(classHash: string): Promise<ContractClassResponse>;\n\n  /**\n   * Returns the nonce associated with the given address in the given block\n   *\n   * @param contractAddress - contract address\n   * @returns the hex nonce\n   */\n  public abstract getNonceForAddress(\n    contractAddress: string,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Nonce>;\n\n  /**\n   * Get the value of the storage (contract's variable) at the given address and key\n   *\n   * @param contractAddress\n   * @param key - from getStorageVarAddress('<STORAGE_VARIABLE_NAME>') (WIP)\n   * @param blockIdentifier - block identifier\n   * @returns the value of the storage variable\n   */\n  public abstract getStorageAt(\n    contractAddress: string,\n    key: BigNumberish,\n    blockIdentifier?: BlockIdentifier\n  ): Promise<Storage>;\n\n  /**\n   * Gets the transaction information from a tx id.\n   *\n   * @param txHash\n   * @returns the transaction object \\{ transaction_id, status, transaction, block_number?, block_number?, transaction_index?, transaction_failure_reason? \\}\n   */\n  public abstract getTransaction(transactionHash: BigNumberish): Promise<GetTransactionResponse>;\n\n  /**\n   * Gets the transaction receipt from a tx hash.\n   *\n   * @param txHash\n   * @returns the transaction receipt object\n   */\n  public abstract getTransactionReceipt(\n    transactionHash: BigNumberish\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Deploys a given compiled Account contract (json) to starknet\n   *\n   * @param payload payload to be deployed containing:\n   * - compiled contract code\n   * - constructor calldata\n   * - address salt\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccountContract(\n    payload: DeployAccountContractPayload,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Invokes a function on starknet\n   * @deprecated This method won't be supported as soon as fees are mandatory. Should not be used outside of Account class\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * - maxFee - optional maxFee\n   * @returns response from addTransaction\n   */\n  public abstract invokeFunction(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   * @param transaction transaction payload to be deployed containing:\n   * - compiled contract code\n   * - sender address\n   * - signature\n   * @param details Invocation Details containing:\n   * - nonce\n   * - optional version\n   * - optional maxFee\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declareContract(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   * @deprecated Please use getInvokeEstimateFee or getDeclareEstimateFee instead. Should not be used outside of Account class\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given INVOKE transaction\n   *\n   * @param invocation the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce - optional nonce\n   * - version - optional version\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getInvokeEstimateFee(\n    invocation: Invocation,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given DECLARE transaction\n   *\n   * @param transaction transaction payload to be declared containing:\n   * - compiled contract code\n   * - sender address\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getDeclareEstimateFee(\n    transaction: DeclareContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a given DEPLOY_ACCOUNT transaction\n   *\n   * @param transaction transaction payload to be deployed containing:\n   * - classHash\n   * - constructorCalldata\n   * - addressSalt\n   * - signature - (defaults to []) the signature\n   * @param details - optional details containing:\n   * - nonce\n   * - version - optional version\n   * - optional maxFee\n   * @param blockIdentifier - (optional) block identifier\n   * @param skipValidate - (optional) skip cairo __validate__ method\n   * @returns the estimated fee\n   */\n  public abstract getDeployAccountEstimateFee(\n    transaction: DeployAccountContractTransaction,\n    details: InvocationsDetailsWithNonce,\n    blockIdentifier?: BlockIdentifier,\n    skipValidate?: boolean\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimates the fee for a list of INVOKE transaction\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options getEstimateFeeBulkOptions\n   * - (optional) blockIdentifier - BlockIdentifier\n   * @returns the estimated fee\n   */\n  public abstract getEstimateFeeBulk(\n    invocations: AccountInvocations,\n    options?: getEstimateFeeBulkOptions\n  ): Promise<EstimateFeeResponseBulk>;\n\n  /**\n   * Wait for the transaction to be accepted\n   * @param txHash - transaction hash\n   * @param options waitForTransactionOptions\n   * - (optional) retryInterval: number | undefined;\n   * - (optional) successStates: TransactionStatus[] | undefined;\n   * @return GetTransactionReceiptResponse\n   */\n  public abstract waitForTransaction(\n    txHash: BigNumberish,\n    options?: waitForTransactionOptions\n  ): Promise<GetTransactionReceiptResponse>;\n\n  /**\n   * Simulates the transaction and returns the transaction trace and estimated fee.\n   *\n   * @param invocations AccountInvocations - Complete invocations array with account details\n   * @param options - getSimulateTransactionOptions\n   *  - (optional) blockIdentifier - block identifier\n   *  - (optional) skipValidate - skip cairo __validate__ method\n   *  - (optional) skipExecute - skip cairo __execute__ method\n   * @returns an array of transaction trace and estimated fee\n   */\n  public abstract getSimulateTransaction(\n    invocations: AccountInvocations,\n    options?: getSimulateTransactionOptions\n  ): Promise<SimulateTransactionResponse>;\n\n  /**\n   * Gets the state changes in a specific block (result of executing the requested block)\n   *\n   * @param blockIdentifier - block identifier\n   * @returns StateUpdateResponse\n   */\n  public abstract getStateUpdate(blockIdentifier?: BlockIdentifier): Promise<StateUpdateResponse>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress string\n   * @param classHash undefined\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: string,\n    classHash?: undefined,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n\n  /**\n   * Gets the contract version from the provided address\n   * @param contractAddress undefined\n   * @param classHash\n   * @param options - getContractVersionOptions\n   *   - (optional) compiler - (default true) extract compiler version using type tactic from abi\n   *   - (optional) blockIdentifier - block identifier\n   */\n  public abstract getContractVersion(\n    contractAddress: undefined,\n    classHash: string,\n    options?: getContractVersionOptions\n  ): Promise<ContractVersion>;\n}\n","import { RpcProvider } from './rpc';\n\nexport { RpcProvider as Provider } from './extensions/default'; // backward-compatibility\nexport * from './errors';\nexport * from './interface';\nexport * from './extensions/default';\n\nexport const defaultProvider = new RpcProvider({ default: true });\n","import {\n  Abi,\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n} from '../types';\n\nexport abstract class SignerInterface {\n  /**\n   * Method to get the public key of the signer\n   *\n   * @returns format: hex-string\n   */\n  public abstract getPubKey(): Promise<string>;\n\n  /**\n   * Signs a JSON object for off-chain usage with the Starknet private key and returns the signature\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param typedData - JSON object to be signed\n   * @param accountAddress\n   */\n  public abstract signMessage(typedData: TypedData, accountAddress: string): Promise<Signature>;\n\n  /**\n   * Signs transactions with the Starknet private key and returns the signature\n   *\n   * @param transactions - Array of Call objects, each including:<br/>\n   *  - contractAddress<br/>\n   *  - entrypoint<br/>\n   *  - calldata<br/>\n   * @param transactionsDetail - InvocationsSignerDetails object with:<br/>\n   *  - walletAddress<br/>\n   *  - chainId<br/>\n   *  - cairoVersion<br/>\n   *  - maxFee<br/>\n   *  - version<br/>\n   *  - nonce<br/>\n   * @param abis - (optional) An array of Abi objects for displaying decoded data\n   */\n  public abstract signTransaction(\n    transactions: Call[],\n    transactionsDetail: InvocationsSignerDetails,\n    abis?: Abi[]\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DEPLOY_ACCOUNT transaction with the Starknet private key and returns the signature\n   *\n   * @param transaction<br/>\n   * - contractAddress<br/>\n   * - chainId<br/>\n   * - classHash<br/>\n   * - constructorCalldata<br/>\n   * - addressSalt<br/>\n   * - maxFee<br/>\n   * - version<br/>\n   * - nonce<br/>\n   */\n  public abstract signDeployAccountTransaction(\n    transaction: DeployAccountSignerDetails\n  ): Promise<Signature>;\n\n  /**\n   * Signs a DECLARE transaction with the Starknet private key and returns the signature\n   *\n   * @param transaction<br/>\n   * - classHash<br/>\n   * - compiledClassHash? - used for Cairo1<br/>\n   * - senderAddress<br/>\n   * - chainId<br/>\n   * - maxFee<br/>\n   * - version<br/>\n   * - nonce<br/>\n   */\n  public abstract signDeclareTransaction(transaction: DeclareSignerDetails): Promise<Signature>;\n}\n","/* eslint-disable no-param-reassign */\nimport {\n  BigNumberish,\n  TypedDataRevision as Revision,\n  StarkNetEnumType,\n  StarkNetMerkleType,\n  StarkNetType,\n  TypedData,\n} from '../types';\nimport { byteArrayFromString } from './calldata/byteArray';\nimport {\n  computePedersenHash,\n  computePedersenHashOnElements,\n  computePoseidonHash,\n  computePoseidonHashOnElements,\n  getSelectorFromName,\n} from './hash';\nimport { MerkleTree } from './merkle';\nimport { isHex, toHex } from './num';\nimport { encodeShortString } from './shortString';\n\n/** @deprecated prefer importing from 'types' over 'typedData' */\nexport * from '../types/typedData';\n\ninterface Context {\n  parent?: string;\n  key?: string;\n}\n\ninterface Configuration {\n  domain: string;\n  hashMethod: (data: BigNumberish[]) => string;\n  hashMerkleMethod: (a: BigNumberish, b: BigNumberish) => string;\n  escapeTypeString: (s: string) => string;\n  presetTypes: TypedData['types'];\n}\n\nconst presetTypes: TypedData['types'] = {\n  u256: JSON.parse('[{ \"name\": \"low\", \"type\": \"u128\" }, { \"name\": \"high\", \"type\": \"u128\" }]'),\n  TokenAmount: JSON.parse(\n    '[{ \"name\": \"token_address\", \"type\": \"ContractAddress\" }, { \"name\": \"amount\", \"type\": \"u256\" }]'\n  ),\n  NftId: JSON.parse(\n    '[{ \"name\": \"collection_address\", \"type\": \"ContractAddress\" }, { \"name\": \"token_id\", \"type\": \"u256\" }]'\n  ),\n};\n\nconst revisionConfiguration: Record<Revision, Configuration> = {\n  [Revision.Active]: {\n    domain: 'StarknetDomain',\n    hashMethod: computePoseidonHashOnElements,\n    hashMerkleMethod: computePoseidonHash,\n    escapeTypeString: (s) => `\"${s}\"`,\n    presetTypes,\n  },\n  [Revision.Legacy]: {\n    domain: 'StarkNetDomain',\n    hashMethod: computePedersenHashOnElements,\n    hashMerkleMethod: computePedersenHash,\n    escapeTypeString: (s) => s,\n    presetTypes: {},\n  },\n};\n\nfunction identifyRevision({ types, domain }: TypedData) {\n  if (revisionConfiguration[Revision.Active].domain in types && domain.revision === Revision.Active)\n    return Revision.Active;\n\n  if (\n    revisionConfiguration[Revision.Legacy].domain in types &&\n    (domain.revision ?? Revision.Legacy) === Revision.Legacy\n  )\n    return Revision.Legacy;\n\n  return undefined;\n}\n\nfunction getHex(value: BigNumberish): string {\n  try {\n    return toHex(value);\n  } catch (e) {\n    if (typeof value === 'string') {\n      return toHex(encodeShortString(value));\n    }\n    throw new Error(`Invalid BigNumberish: ${value}`);\n  }\n}\n\n/**\n * Validates that `data` matches the EIP-712 JSON schema.\n */\nfunction validateTypedData(data: unknown): data is TypedData {\n  const typedData = data as TypedData;\n  return Boolean(\n    typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData)\n  );\n}\n\nexport function prepareSelector(selector: string): string {\n  return isHex(selector) ? selector : getSelectorFromName(selector);\n}\n\nexport function isMerkleTreeType(type: StarkNetType): type is StarkNetMerkleType {\n  return type.type === 'merkletree';\n}\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nexport function getDependencies(\n  types: TypedData['types'],\n  type: string,\n  dependencies: string[] = [],\n  contains: string = '',\n  revision: Revision = Revision.Legacy\n): string[] {\n  // Include pointers (struct arrays)\n  if (type[type.length - 1] === '*') {\n    type = type.slice(0, -1);\n  } else if (revision === Revision.Active) {\n    // enum base\n    if (type === 'enum') {\n      type = contains;\n    }\n    // enum element types\n    else if (type.match(/^\\(.*\\)$/)) {\n      type = type.slice(1, -1);\n    }\n  }\n\n  if (dependencies.includes(type) || !types[type]) {\n    return dependencies;\n  }\n\n  return [\n    type,\n    ...(types[type] as StarkNetEnumType[]).reduce<string[]>(\n      (previous, t) => [\n        ...previous,\n        ...getDependencies(types, t.type, previous, t.contains, revision).filter(\n          (dependency) => !previous.includes(dependency)\n        ),\n      ],\n      []\n    ),\n  ];\n}\n\nfunction getMerkleTreeType(types: TypedData['types'], ctx: Context) {\n  if (ctx.parent && ctx.key) {\n    const parentType = types[ctx.parent];\n    const merkleType = parentType.find((t) => t.name === ctx.key)!;\n    const isMerkleTree = isMerkleTreeType(merkleType);\n    if (!isMerkleTree) {\n      throw new Error(`${ctx.key} is not a merkle tree`);\n    }\n    if (merkleType.contains.endsWith('*')) {\n      throw new Error(`Merkle tree contain property must not be an array but was given ${ctx.key}`);\n    }\n    return merkleType.contains;\n  }\n  return 'raw';\n}\n\n/**\n * Encode a type to a string. All dependent types are alphabetically sorted.\n */\nexport function encodeType(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.Legacy\n): string {\n  const allTypes =\n    revision === Revision.Active\n      ? { ...types, ...revisionConfiguration[revision].presetTypes }\n      : types;\n  const [primary, ...dependencies] = getDependencies(\n    allTypes,\n    type,\n    undefined,\n    undefined,\n    revision\n  );\n  const newTypes = !primary ? [] : [primary, ...dependencies.sort()];\n\n  const esc = revisionConfiguration[revision].escapeTypeString;\n\n  return newTypes\n    .map((dependency) => {\n      const dependencyElements = allTypes[dependency].map((t) => {\n        const targetType =\n          t.type === 'enum' && revision === Revision.Active\n            ? (t as StarkNetEnumType).contains\n            : t.type;\n        // parentheses handling for enum variant types\n        const typeString = targetType.match(/^\\(.*\\)$/)\n          ? `(${targetType\n              .slice(1, -1)\n              .split(',')\n              .map((e) => (e ? esc(e) : e))\n              .join(',')})`\n          : esc(targetType);\n        return `${esc(t.name)}:${typeString}`;\n      });\n      return `${esc(dependency)}(${dependencyElements})`;\n    })\n    .join('');\n}\n\n/**\n * Get a type string as hash.\n */\nexport function getTypeHash(\n  types: TypedData['types'],\n  type: string,\n  revision: Revision = Revision.Legacy\n): string {\n  return getSelectorFromName(encodeType(types, type, revision));\n}\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nexport function encodeValue(\n  types: TypedData['types'],\n  type: string,\n  data: unknown,\n  ctx: Context = {},\n  revision: Revision = Revision.Legacy\n): [string, string] {\n  if (types[type]) {\n    return [type, getStructHash(types, type, data as TypedData['message'], revision)];\n  }\n\n  if (revisionConfiguration[revision].presetTypes[type]) {\n    return [\n      type,\n      getStructHash(\n        revisionConfiguration[revision].presetTypes,\n        type,\n        data as TypedData['message'],\n        revision\n      ),\n    ];\n  }\n\n  if (type.endsWith('*')) {\n    const hashes: string[] = (data as Array<TypedData['message']>).map(\n      (entry) => encodeValue(types, type.slice(0, -1), entry, undefined, revision)[1]\n    );\n    return [type, revisionConfiguration[revision].hashMethod(hashes)];\n  }\n\n  switch (type) {\n    case 'enum': {\n      if (revision === Revision.Active) {\n        const [variantKey, variantData] = Object.entries(data as TypedData['message'])[0];\n\n        const parentType = types[ctx.parent as string][0] as StarkNetEnumType;\n        const enumType = types[parentType.contains];\n        const variantType = enumType.find((t) => t.name === variantKey) as StarkNetType;\n        const variantIndex = enumType.indexOf(variantType);\n\n        const encodedSubtypes = variantType.type\n          .slice(1, -1)\n          .split(',')\n          .map((subtype, index) => {\n            if (!subtype) return subtype;\n            const subtypeData = (variantData as unknown[])[index];\n            return encodeValue(types, subtype, subtypeData, undefined, revision)[1];\n          });\n        return [\n          type,\n          revisionConfiguration[revision].hashMethod([variantIndex, ...encodedSubtypes]),\n        ];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'merkletree': {\n      const merkleTreeType = getMerkleTreeType(types, ctx);\n      const structHashes: string[] = (data as Array<TypedData['message']>).map((struct) => {\n        return encodeValue(types, merkleTreeType, struct, undefined, revision)[1];\n      });\n      const { root } = new MerkleTree(\n        structHashes as string[],\n        revisionConfiguration[revision].hashMerkleMethod\n      );\n      return ['felt', root];\n    }\n    case 'selector': {\n      return ['felt', prepareSelector(data as string)];\n    }\n    case 'string': {\n      if (revision === Revision.Active) {\n        const byteArray = byteArrayFromString(data as string);\n        const elements = [\n          byteArray.data.length,\n          ...byteArray.data,\n          byteArray.pending_word,\n          byteArray.pending_word_len,\n        ];\n        return [type, revisionConfiguration[revision].hashMethod(elements)];\n      } // else fall through to default\n      return [type, getHex(data as string)];\n    }\n    case 'felt':\n    case 'bool':\n    case 'u128':\n    case 'i128':\n    case 'ContractAddress':\n    case 'ClassHash':\n    case 'timestamp':\n    case 'shortstring':\n      return [type, getHex(data as string)];\n    default: {\n      if (revision === Revision.Active) {\n        throw new Error(`Unsupported type: ${type}`);\n      }\n      return [type, getHex(data as string)];\n    }\n  }\n}\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n */\nexport function encodeData<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.Legacy\n) {\n  const targetType = types[type] ?? revisionConfiguration[revision].presetTypes[type];\n  const [returnTypes, values] = targetType.reduce<[string[], string[]]>(\n    ([ts, vs], field) => {\n      if (data[field.name] === undefined || (data[field.name] === null && field.type !== 'enum')) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name];\n      const ctx = { parent: type, key: field.name };\n      const [t, encodedValue] = encodeValue(types, field.type, value, ctx, revision);\n\n      return [\n        [...ts, t],\n        [...vs, encodedValue],\n      ];\n    },\n    [['felt'], [getTypeHash(types, type, revision)]]\n  );\n\n  return [returnTypes, values];\n}\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values.\n * All dependent types are automatically encoded.\n */\nexport function getStructHash<T extends TypedData>(\n  types: T['types'],\n  type: string,\n  data: T['message'],\n  revision: Revision = Revision.Legacy\n) {\n  return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);\n}\n\n/**\n * Get the SNIP-12 encoded message to sign, from the typedData object.\n */\nexport function getMessageHash(typedData: TypedData, account: BigNumberish): string {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const revision = identifyRevision(typedData) as Revision;\n  const { domain, hashMethod } = revisionConfiguration[revision];\n\n  const message = [\n    encodeShortString('StarkNet Message'),\n    getStructHash(typedData.types, domain, typedData.domain, revision),\n    account,\n    getStructHash(typedData.types, typedData.primaryType, typedData.message, revision),\n  ];\n\n  return hashMethod(message);\n}\n","import { BigNumberish } from '../types';\nimport { computePedersenHash } from './hash';\n\nexport class MerkleTree {\n  public leaves: string[];\n\n  public branches: string[][] = [];\n\n  public root: string;\n\n  public hashMethod: (a: BigNumberish, b: BigNumberish) => string;\n\n  constructor(\n    leafHashes: string[],\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    this.hashMethod = hashMethod;\n    this.leaves = leafHashes;\n    this.root = this.build(leafHashes);\n  }\n\n  /**\n   * Create Merkle tree\n   * @param leaves hex-string array\n   * @returns format: hex-string; Merkle tree root\n   */\n  private build(leaves: string[]): string {\n    if (leaves.length === 1) {\n      return leaves[0];\n    }\n    if (leaves.length !== this.leaves.length) {\n      this.branches.push(leaves);\n    }\n    const newLeaves: string[] = [];\n    for (let i = 0; i < leaves.length; i += 2) {\n      if (i + 1 === leaves.length) {\n        newLeaves.push(MerkleTree.hash(leaves[i], '0x0', this.hashMethod));\n      } else {\n        newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));\n      }\n    }\n    return this.build(newLeaves);\n  }\n\n  /**\n   * Create hash from ordered a and b, Pedersen hash default\n   * @returns format: hex-string\n   */\n  static hash(\n    a: BigNumberish,\n    b: BigNumberish,\n    hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n  ) {\n    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) => (x >= y ? 1 : -1));\n    return hashMethod(aSorted, bSorted);\n  }\n\n  /**\n   * Return path to leaf\n   * @param leaf hex-string\n   * @param branch hex-string array\n   * @param hashPath hex-string array\n   * @returns format: hex-string array\n   */\n  public getProof(leaf: string, branch = this.leaves, hashPath: string[] = []): string[] {\n    const index = branch.indexOf(leaf);\n    if (index === -1) {\n      throw new Error('leaf not found');\n    }\n    if (branch.length === 1) {\n      return hashPath;\n    }\n    const isLeft = index % 2 === 0;\n    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? '0x0';\n    const newHashPath = [...hashPath, neededBranch];\n    const currentBranchLevelIndex =\n      this.leaves.length === branch.length\n        ? -1\n        : this.branches.findIndex((b) => b.length === branch.length);\n    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];\n    return this.getProof(\n      MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),\n      nextBranch,\n      newHashPath\n    );\n  }\n}\n\n/**\n * Test Merkle tree path\n * @param root hex-string\n * @param leaf hex-string\n * @param path hex-string array\n * @param hashMethod hash method override, Pedersen default\n */\nexport function proofMerklePath(\n  root: string,\n  leaf: string,\n  path: string[],\n  hashMethod: (a: BigNumberish, b: BigNumberish) => string = computePedersenHash\n): boolean {\n  if (path.length === 0) {\n    return root === leaf;\n  }\n  const [next, ...rest] = path;\n  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);\n}\n","import {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  V2DeclareSignerDetails,\n  V2DeployAccountSignerDetails,\n  V2InvocationsSignerDetails,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion2, ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { starkCurve } from '../utils/ec';\nimport { buf2hex } from '../utils/encode';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { SignerInterface } from './interface';\n\nexport class Signer implements SignerInterface {\n  protected pk: Uint8Array | string;\n\n  constructor(pk: Uint8Array | string = starkCurve.utils.randomPrivateKey()) {\n    this.pk = pk instanceof Uint8Array ? buf2hex(pk) : toHex(pk);\n  }\n\n  public async getPubKey(): Promise<string> {\n    return starkCurve.getStarkKey(this.pk);\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return this.signRaw(msgHash);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    return this.signRaw(msgHash as string);\n  }\n\n  protected async signRaw(msgHash: string): Promise<Signature> {\n    return starkCurve.sign(msgHash, this.pk);\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\n\nimport {\n  Call,\n  DeclareSignerDetails,\n  DeployAccountSignerDetails,\n  InvocationsSignerDetails,\n  Signature,\n  TypedData,\n  V2DeclareSignerDetails,\n  V2DeployAccountSignerDetails,\n  V2InvocationsSignerDetails,\n  V3DeclareSignerDetails,\n  V3DeployAccountSignerDetails,\n  V3InvocationsSignerDetails,\n} from '../types';\nimport { ETransactionVersion2, ETransactionVersion3 } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from '../utils/encode';\nimport { ethRandomPrivateKey } from '../utils/eth';\nimport {\n  calculateDeclareTransactionHash,\n  calculateDeployAccountTransactionHash,\n  calculateInvokeTransactionHash,\n} from '../utils/hash';\nimport { toHex } from '../utils/num';\nimport { intDAM } from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { SignerInterface } from './interface';\n\n/**\n * Signer for accounts using Ethereum signature\n */\nexport class EthSigner implements SignerInterface {\n  protected pk: string; // hex string without 0x and odd number of characters\n\n  constructor(pk: Uint8Array | string = ethRandomPrivateKey()) {\n    this.pk =\n      pk instanceof Uint8Array\n        ? removeHexPrefix(sanitizeHex(buf2hex(pk)))\n        : removeHexPrefix(sanitizeHex(toHex(pk)));\n  }\n\n  public async getPubKey(): Promise<string> {\n    return addHexPrefix(buf2hex(secp256k1.getPublicKey(this.pk)));\n  }\n\n  public async signMessage(typedData: TypedData, accountAddress: string): Promise<Signature> {\n    const msgHash = getMessageHash(typedData, accountAddress);\n    return secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n  }\n\n  public async signTransaction(\n    transactions: Call[],\n    details: InvocationsSignerDetails\n  ): Promise<Signature> {\n    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);\n    let msgHash;\n\n    // TODO: How to do generic union discriminator for all like this\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3InvocationsSignerDetails;\n      msgHash = calculateInvokeTransactionHash({\n        ...det,\n        senderAddress: det.walletAddress,\n        compiledCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signTransaction version');\n    }\n\n    return secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n  }\n\n  public async signDeployAccountTransaction(\n    details: DeployAccountSignerDetails\n  ): Promise<Signature> {\n    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);\n    /*     const version = BigInt(details.version).toString(); */\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        constructorCalldata: compiledConstructorCalldata,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeployAccountSignerDetails;\n      msgHash = calculateDeployAccountTransactionHash({\n        ...det,\n        salt: det.addressSalt,\n        compiledConstructorCalldata,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeployAccountTransaction version');\n    }\n\n    return secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n  }\n\n  public async signDeclareTransaction(\n    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass\n    details: DeclareSignerDetails\n  ): Promise<Signature> {\n    let msgHash;\n\n    if (Object.values(ETransactionVersion2).includes(details.version as any)) {\n      const det = details as V2DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n      });\n    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {\n      const det = details as V3DeclareSignerDetails;\n      msgHash = calculateDeclareTransactionHash({\n        ...det,\n        version: det.version,\n        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),\n        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),\n      });\n    } else {\n      throw Error('unsupported signDeclareTransaction version');\n    }\n\n    return secp256k1.sign(removeHexPrefix(sanitizeHex(msgHash)), this.pk);\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1';\n\nimport { buf2hex, sanitizeHex } from './encode';\n\n/**\n * Get random Ethereum private Key.\n * @returns an Hex string\n * @example\n * const myPK: string = randomAddress()\n * // result = \"0xf04e69ac152fba37c02929c2ae78c9a481461dda42dbc6c6e286be6eb2a8ab83\"\n */\nexport function ethRandomPrivateKey(): string {\n  return sanitizeHex(buf2hex(secp256k1.utils.randomPrivateKey()));\n}\n","import { UDC } from '../constants';\nimport { InvokeTransactionReceiptResponse } from '../types/provider';\nimport { cleanHex } from './num';\n\n/**\n * Parse Transaction Receipt Event from UDC invoke transaction and\n * create DeployContractResponse compatible response with addition of the UDC Event data\n *\n * @returns DeployContractResponse | UDC Event Response data\n */\nexport function parseUDCEvent(txReceipt: InvokeTransactionReceiptResponse) {\n  if (!txReceipt.events) {\n    throw new Error('UDC emitted event is empty');\n  }\n  const event = txReceipt.events.find(\n    (it) => cleanHex(it.from_address) === cleanHex(UDC.ADDRESS)\n  ) || {\n    data: [],\n  };\n  return {\n    transaction_hash: txReceipt.transaction_hash,\n    contract_address: event.data[0],\n    address: event.data[0],\n    deployer: event.data[1],\n    unique: event.data[2],\n    classHash: event.data[3],\n    calldata_len: event.data[4],\n    calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),\n    salt: event.data[event.data.length - 1],\n  };\n}\n","import { UDC, ZERO } from '../constants';\nimport { Provider, ProviderInterface } from '../provider';\nimport { Signer, SignerInterface } from '../signer';\nimport {\n  Abi,\n  AccountInvocations,\n  AccountInvocationsFactoryDetails,\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareContractTransaction,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployAccountContractTransaction,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  DeployTransactionReceiptResponse,\n  EstimateFee,\n  EstimateFeeAction,\n  EstimateFeeBulk,\n  Invocation,\n  Invocations,\n  InvocationsSignerDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  ProviderOptions,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionResponse,\n  TransactionType,\n  TypedData,\n  UniversalDeployerContractPayload,\n  UniversalDetails,\n} from '../types';\nimport { ETransactionVersion, ETransactionVersion3, ResourceBounds } from '../types/api';\nimport { CallData } from '../utils/calldata';\nimport { extractContractHashes, isSierra } from '../utils/contract';\nimport { starkCurve } from '../utils/ec';\nimport { parseUDCEvent } from '../utils/events';\nimport { calculateContractAddressFromHash } from '../utils/hash';\nimport { toBigInt, toCairoBool } from '../utils/num';\nimport { parseContract } from '../utils/provider';\nimport {\n  estimateFeeToBounds,\n  formatSignature,\n  randomAddress,\n  reduceV2,\n  toFeeVersion,\n  toTransactionVersion,\n  v3Details,\n} from '../utils/stark';\nimport { getExecuteCalldata } from '../utils/transaction';\nimport { getMessageHash } from '../utils/typedData';\nimport { AccountInterface } from './interface';\n\nexport class Account extends Provider implements AccountInterface {\n  public signer: SignerInterface;\n\n  public address: string;\n\n  public cairoVersion: CairoVersion;\n\n  readonly transactionVersion: ETransactionVersion.V2 | ETransactionVersion.V3;\n\n  constructor(\n    providerOrOptions: ProviderOptions | ProviderInterface,\n    address: string,\n    pkOrSigner: Uint8Array | string | SignerInterface,\n    cairoVersion?: CairoVersion,\n    transactionVersion: ETransactionVersion.V2 | ETransactionVersion.V3 = ETransactionVersion.V2 // TODO: Discuss this, set to v2 for backward compatibility\n  ) {\n    super(providerOrOptions);\n    this.address = address.toLowerCase();\n    this.signer =\n      typeof pkOrSigner === 'string' || pkOrSigner instanceof Uint8Array\n        ? new Signer(pkOrSigner)\n        : pkOrSigner;\n\n    if (cairoVersion) {\n      this.cairoVersion = cairoVersion.toString() as CairoVersion;\n    }\n    this.transactionVersion = transactionVersion;\n  }\n\n  // provided version or contract based preferred transactionVersion\n  private getPreferredVersion(type12: ETransactionVersion, type3: ETransactionVersion) {\n    if (this.transactionVersion === ETransactionVersion.V3) return type3;\n    if (this.transactionVersion === ETransactionVersion.V2) return type12;\n\n    return ETransactionVersion.V3;\n  }\n\n  public async getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce> {\n    return super.getNonceForAddress(this.address, blockIdentifier);\n  }\n\n  private async getNonceSafe(nonce?: BigNumberish) {\n    // Patch DEPLOY_ACCOUNT: RPC getNonce for non-existing address will result in error, on Sequencer it is '0x0'\n    try {\n      return toBigInt(nonce ?? (await this.getNonce()));\n    } catch (error) {\n      return 0n;\n    }\n  }\n\n  /**\n   * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor\n   * @param classHash if provided detects Cairo version from classHash, otherwise from the account address\n   */\n  public async getCairoVersion(classHash?: string) {\n    if (!this.cairoVersion) {\n      const { cairo } = classHash\n        ? await super.getContractVersion(undefined, classHash)\n        : await super.getContractVersion(this.address);\n      this.cairoVersion = cairo;\n    }\n    return this.cairoVersion;\n  }\n\n  public async estimateFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    return this.estimateInvokeFee(calls, estimateFeeDetails);\n  }\n\n  public async estimateInvokeFee(\n    calls: AllowArray<Call>,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const {\n      nonce: providedNonce,\n      blockIdentifier,\n      version: providedVersion,\n      skipValidate = true,\n    } = details;\n\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(providedNonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.F1, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n\n    const signerDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      walletAddress: this.address,\n      nonce,\n      maxFee: ZERO,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n      skipValidate,\n    };\n\n    const invocation = await this.buildInvocation(transactions, signerDetails);\n    return super.getInvokeEstimateFee(\n      { ...invocation },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateDeclareFee(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const {\n      blockIdentifier,\n      nonce: providedNonce,\n      version: providedVersion,\n      skipValidate = true,\n    } = details;\n    const nonce = toBigInt(providedNonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      !isSierra(payload.contract)\n        ? ETransactionVersion.F1\n        : this.getPreferredVersion(ETransactionVersion.F2, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    );\n    const chainId = await this.getChainId();\n\n    const declareContractTransaction = await this.buildDeclarePayload(payload, {\n      ...v3Details(details),\n      nonce,\n      chainId,\n      version,\n      walletAddress: this.address,\n      maxFee: ZERO,\n      cairoVersion: undefined, // unused parameter\n      skipValidate,\n    });\n\n    return super.getDeclareEstimateFee(\n      declareContractTransaction,\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateAccountDeployFee(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const { blockIdentifier, version: providedVersion, skipValidate = true } = details;\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.F1, ETransactionVersion.F3),\n      toFeeVersion(providedVersion)\n    ); // TODO: Can Cairo0 be deployed with F3 ?\n    const nonce = ZERO; // DEPLOY_ACCOUNT transaction will have a nonce zero as it is the first transaction in the account\n    const chainId = await this.getChainId();\n\n    const payload = await this.buildAccountDeployPayload(\n      { classHash, addressSalt, constructorCalldata, contractAddress },\n      {\n        ...v3Details(details),\n        nonce,\n        chainId,\n        version,\n        walletAddress: this.address, // unused parameter\n        maxFee: ZERO,\n        cairoVersion: undefined, // unused parameter,\n        skipValidate,\n      }\n    );\n\n    return super.getDeployAccountEstimateFee(\n      { ...payload },\n      { ...v3Details(details), version, nonce },\n      blockIdentifier,\n      details.skipValidate\n    );\n  }\n\n  public async estimateDeployFee(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<EstimateFee> {\n    const calls = this.buildUDCContractPayload(payload);\n    return this.estimateInvokeFee(calls, details);\n  }\n\n  public async estimateFeeBulk(\n    invocations: Invocations,\n    details: UniversalDetails = {}\n  ): Promise<EstimateFeeBulk> {\n    const { nonce, blockIdentifier, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        ETransactionVersion.F1, // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(ETransactionVersion.F2, ETransactionVersion.F3),\n          version\n        ), // sierra\n      ],\n      nonce,\n      blockIdentifier,\n    });\n\n    return super.getEstimateFeeBulk(accountInvocations, {\n      blockIdentifier,\n      skipValidate: details.skipValidate,\n    });\n  }\n\n  public async simulateTransaction(\n    invocations: Invocations,\n    details: SimulateTransactionDetails = {}\n  ): Promise<SimulateTransactionResponse> {\n    const { nonce, blockIdentifier, skipValidate = true, skipExecute, version } = details;\n    const accountInvocations = await this.accountInvocationsFactory(invocations, {\n      ...v3Details(details),\n      versions: [\n        ETransactionVersion.V1, // non-sierra\n        toTransactionVersion(\n          this.getPreferredVersion(ETransactionVersion.V2, ETransactionVersion.V3),\n          version\n        ),\n      ],\n      nonce,\n      blockIdentifier,\n      skipValidate,\n    });\n\n    return super.getSimulateTransaction(accountInvocations, {\n      blockIdentifier,\n      skipValidate,\n      skipExecute,\n    });\n  }\n\n  public async execute(\n    calls: AllowArray<Call>,\n    abis: Abi[] | undefined = undefined,\n    details: UniversalDetails = {}\n  ): Promise<InvokeFunctionResponse> {\n    const transactions = Array.isArray(calls) ? calls : [calls];\n    const nonce = toBigInt(details.nonce ?? (await this.getNonce()));\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.V1, ETransactionVersion.V3), // TODO: does this depend on cairo version ?\n      details.version\n    );\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      { type: TransactionType.INVOKE, payload: calls },\n      {\n        ...details,\n        version,\n      }\n    );\n\n    const chainId = await this.getChainId();\n\n    const signerDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      walletAddress: this.address,\n      nonce,\n      maxFee: estimate.maxFee,\n      version,\n      chainId,\n      cairoVersion: await this.getCairoVersion(),\n    };\n\n    const signature = await this.signer.signTransaction(transactions, signerDetails, abis);\n\n    const calldata = getExecuteCalldata(transactions, await this.getCairoVersion());\n\n    return this.invokeFunction(\n      { contractAddress: this.address, calldata, signature },\n      {\n        ...v3Details(details),\n        resourceBounds: estimate.resourceBounds,\n        nonce,\n        maxFee: estimate.maxFee,\n        version,\n      }\n    );\n  }\n\n  /**\n   * First check if contract is already declared, if not declare it\n   * If contract already declared returned transaction_hash is ''.\n   * Method will pass even if contract is already declared\n   * @param transactionsDetail (optional)\n   */\n  public async declareIfNot(\n    payload: DeclareContractPayload,\n    transactionsDetail: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    try {\n      await this.getClassByHash(declareContractPayload.classHash);\n    } catch (error) {\n      return this.declare(payload, transactionsDetail);\n    }\n    return {\n      transaction_hash: '',\n      class_hash: declareContractPayload.classHash,\n    };\n  }\n\n  public async declare(\n    payload: DeclareContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareContractResponse> {\n    const declareContractPayload = extractContractHashes(payload);\n    const { nonce, version: providedVersion } = details;\n    const version = toTransactionVersion(\n      !isSierra(payload.contract)\n        ? ETransactionVersion.V1\n        : this.getPreferredVersion(ETransactionVersion.V2, ETransactionVersion.V3),\n      providedVersion\n    );\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DECLARE,\n        payload: declareContractPayload,\n      },\n      {\n        ...details,\n        version,\n      }\n    );\n\n    const declareDetails: InvocationsSignerDetails = {\n      ...v3Details(details),\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      nonce: toBigInt(nonce ?? (await this.getNonce())),\n      version,\n      chainId: await this.getChainId(),\n      walletAddress: this.address,\n      cairoVersion: undefined,\n    };\n\n    const declareContractTransaction = await this.buildDeclarePayload(\n      declareContractPayload,\n      declareDetails\n    );\n\n    return this.declareContract(declareContractTransaction, declareDetails);\n  }\n\n  public async deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<MultiDeployContractResponse> {\n    const params = [].concat(payload as []).map((it) => {\n      const {\n        classHash,\n        salt,\n        unique = true,\n        constructorCalldata = [],\n      } = it as UniversalDeployerContractPayload;\n\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n      const deploySalt = salt ?? randomAddress();\n\n      return {\n        call: {\n          contractAddress: UDC.ADDRESS,\n          entrypoint: UDC.ENTRYPOINT,\n          calldata: [\n            classHash,\n            deploySalt,\n            toCairoBool(unique),\n            compiledConstructorCallData.length,\n            ...compiledConstructorCallData,\n          ],\n        },\n        address: calculateContractAddressFromHash(\n          unique ? starkCurve.pedersen(this.address, deploySalt) : deploySalt,\n          classHash,\n          compiledConstructorCallData,\n          unique ? UDC.ADDRESS : 0\n        ),\n      };\n    });\n\n    const calls = params.map((it) => it.call);\n    const addresses = params.map((it) => it.address);\n    const invokeResponse = await this.execute(calls, undefined, details);\n\n    return {\n      ...invokeResponse,\n      contract_address: addresses,\n    };\n  }\n\n  public async deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details: UniversalDetails = {}\n  ): Promise<DeployContractUDCResponse> {\n    const deployTx = await this.deploy(payload, details);\n    const txReceipt = await this.waitForTransaction(deployTx.transaction_hash);\n    return parseUDCEvent(txReceipt as unknown as DeployTransactionReceiptResponse);\n  }\n\n  public async declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeclareDeployUDCResponse> {\n    const { constructorCalldata, salt, unique } = payload;\n    let declare = await this.declareIfNot(payload, details);\n    if (declare.transaction_hash !== '') {\n      const tx = await this.waitForTransaction(declare.transaction_hash);\n      declare = { ...declare, ...tx };\n    }\n    const deploy = await this.deployContract(\n      { classHash: declare.class_hash, salt, unique, constructorCalldata },\n      details\n    );\n    return { declare: { ...declare }, deploy };\n  }\n\n  public deploySelf = this.deployAccount;\n\n  public async deployAccount(\n    {\n      classHash,\n      constructorCalldata = [],\n      addressSalt = 0,\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: UniversalDetails = {}\n  ): Promise<DeployContractResponse> {\n    const version = toTransactionVersion(\n      this.getPreferredVersion(ETransactionVersion.V1, ETransactionVersion.V3),\n      details.version\n    );\n    const nonce = ZERO; // DEPLOY_ACCOUNT transaction will have a nonce zero as it is the first transaction in the account\n    const chainId = await this.getChainId();\n\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const estimate = await this.getUniversalSuggestedFee(\n      version,\n      {\n        type: TransactionType.DEPLOY_ACCOUNT,\n        payload: {\n          classHash,\n          constructorCalldata: compiledCalldata,\n          addressSalt,\n          contractAddress,\n        },\n      },\n      details\n    );\n\n    const signature = await this.signer.signDeployAccountTransaction({\n      ...v3Details(details),\n      classHash,\n      constructorCalldata: compiledCalldata,\n      contractAddress,\n      addressSalt,\n      chainId,\n      resourceBounds: estimate.resourceBounds,\n      maxFee: estimate.maxFee,\n      version,\n      nonce,\n    });\n\n    return this.deployAccountContract(\n      { classHash, addressSalt, constructorCalldata, signature },\n      {\n        ...v3Details(details),\n        nonce,\n        resourceBounds: estimate.resourceBounds,\n        maxFee: estimate.maxFee,\n        version,\n      }\n    );\n  }\n\n  public async signMessage(typedData: TypedData): Promise<Signature> {\n    return this.signer.signMessage(typedData, this.address);\n  }\n\n  public async hashMessage(typedData: TypedData): Promise<string> {\n    return getMessageHash(typedData, this.address);\n  }\n\n  public async verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean> {\n    try {\n      const resp = await this.callContract({\n        contractAddress: this.address,\n        entrypoint: 'isValidSignature',\n        calldata: CallData.compile({\n          hash: toBigInt(hash).toString(),\n          signature: formatSignature(signature),\n        }),\n      });\n      if (BigInt(resp[0]) === 0n) {\n        // OpenZeppelin 0.8.0 invalid signature\n        return false;\n      }\n      // OpenZeppelin 0.8.0, ArgentX 0.3.0 & Braavos Cairo 0 valid signature\n      return true;\n    } catch (err) {\n      if (\n        ['argent/invalid-signature', 'is invalid, with respect to the public key'].some(\n          (errMessage) => (err as Error).message.includes(errMessage)\n        )\n      ) {\n        // ArgentX 0.3.0 invalid signature, Braavos Cairo 0 invalid signature\n        return false;\n      }\n      throw Error(`Signature verification request is rejected by the network: ${err}`);\n    }\n  }\n\n  public async verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean> {\n    const hash = await this.hashMessage(typedData);\n    return this.verifyMessageHash(hash, signature);\n  }\n\n  /*\n   * Support methods\n   */\n\n  private async getUniversalSuggestedFee(\n    version: ETransactionVersion,\n    { type, payload }: EstimateFeeAction,\n    details: UniversalDetails\n  ) {\n    let maxFee: BigNumberish = 0;\n    let resourceBounds: ResourceBounds = estimateFeeToBounds(ZERO);\n    if (version === ETransactionVersion.V3) {\n      resourceBounds =\n        details.resourceBounds ??\n        (await this.getSuggestedFee({ type, payload } as any, details)).resourceBounds;\n    } else {\n      maxFee =\n        details.maxFee ??\n        (await this.getSuggestedFee({ type, payload } as any, details)).suggestedMaxFee;\n    }\n\n    return {\n      maxFee,\n      resourceBounds,\n    };\n  }\n\n  public async getSuggestedFee({ type, payload }: EstimateFeeAction, details: UniversalDetails) {\n    let feeEstimate: EstimateFee;\n\n    switch (type) {\n      case TransactionType.INVOKE:\n        feeEstimate = await this.estimateInvokeFee(payload, details);\n        break;\n\n      case TransactionType.DECLARE:\n        feeEstimate = await this.estimateDeclareFee(payload, details);\n        break;\n\n      case TransactionType.DEPLOY_ACCOUNT:\n        feeEstimate = await this.estimateAccountDeployFee(payload, details);\n        break;\n\n      case TransactionType.DEPLOY:\n        feeEstimate = await this.estimateDeployFee(payload, details);\n        break;\n\n      default:\n        feeEstimate = {\n          gas_consumed: 0n,\n          gas_price: 0n,\n          overall_fee: ZERO,\n          unit: 'FRI',\n          suggestedMaxFee: ZERO,\n          resourceBounds: estimateFeeToBounds(ZERO),\n        };\n        break;\n    }\n\n    return feeEstimate;\n  }\n\n  public async buildInvocation(\n    call: Array<Call>,\n    details: InvocationsSignerDetails\n  ): Promise<Invocation> {\n    const calldata = getExecuteCalldata(call, await this.getCairoVersion());\n    const signature = !details.skipValidate ? await this.signer.signTransaction(call, details) : [];\n\n    return {\n      ...v3Details(details),\n      contractAddress: this.address,\n      calldata,\n      signature,\n    };\n  }\n\n  public async buildDeclarePayload(\n    payload: DeclareContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeclareContractTransaction> {\n    const { classHash, contract, compiledClassHash } = extractContractHashes(payload);\n    const compressedCompiledContract = parseContract(contract);\n\n    if (\n      typeof compiledClassHash === 'undefined' &&\n      (details.version === ETransactionVersion3.F3 || details.version === ETransactionVersion3.V3)\n    ) {\n      throw Error('V3 Transaction work with Cairo1 Contracts and require compiledClassHash');\n    }\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeclareTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          compiledClassHash: compiledClassHash as string, // TODO: TS, cast because optional for v2 and required for v3, thrown if not present\n          senderAddress: details.walletAddress,\n        })\n      : [];\n\n    return {\n      senderAddress: details.walletAddress,\n      signature,\n      contract: compressedCompiledContract,\n      compiledClassHash,\n    };\n  }\n\n  public async buildAccountDeployPayload(\n    {\n      classHash,\n      addressSalt = 0,\n      constructorCalldata = [],\n      contractAddress: providedContractAddress,\n    }: DeployAccountContractPayload,\n    details: InvocationsSignerDetails\n  ): Promise<DeployAccountContractTransaction> {\n    const compiledCalldata = CallData.compile(constructorCalldata);\n    const contractAddress =\n      providedContractAddress ??\n      calculateContractAddressFromHash(addressSalt, classHash, compiledCalldata, 0);\n\n    const signature = !details.skipValidate\n      ? await this.signer.signDeployAccountTransaction({\n          ...details,\n          ...v3Details(details),\n          classHash,\n          contractAddress,\n          addressSalt,\n          constructorCalldata: compiledCalldata,\n        })\n      : [];\n\n    return {\n      ...v3Details(details),\n      classHash,\n      addressSalt,\n      constructorCalldata: compiledCalldata,\n      signature,\n    };\n  }\n\n  public buildUDCContractPayload(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[]\n  ): Call[] {\n    const calls = [].concat(payload as []).map((it) => {\n      const {\n        classHash,\n        salt = '0',\n        unique = true,\n        constructorCalldata = [],\n      } = it as UniversalDeployerContractPayload;\n      const compiledConstructorCallData = CallData.compile(constructorCalldata);\n\n      return {\n        contractAddress: UDC.ADDRESS,\n        entrypoint: UDC.ENTRYPOINT,\n        calldata: [\n          classHash,\n          salt,\n          toCairoBool(unique),\n          compiledConstructorCallData.length,\n          ...compiledConstructorCallData,\n        ],\n      };\n    });\n    return calls;\n  }\n\n  public async accountInvocationsFactory(\n    invocations: Invocations,\n    details: AccountInvocationsFactoryDetails\n  ) {\n    const { nonce, blockIdentifier, skipValidate = true } = details;\n    const safeNonce = await this.getNonceSafe(nonce);\n    const chainId = await this.getChainId();\n    const versions = details.versions.map((it) => toTransactionVersion(it));\n\n    // BULK ACTION FROM NEW ACCOUNT START WITH DEPLOY_ACCOUNT\n    const tx0Payload: any = 'payload' in invocations[0] ? invocations[0].payload : invocations[0];\n    const cairoVersion =\n      invocations[0].type === TransactionType.DEPLOY_ACCOUNT\n        ? await this.getCairoVersion(tx0Payload.classHash)\n        : await this.getCairoVersion();\n\n    return Promise.all(\n      ([] as Invocations).concat(invocations).map(async (transaction, index: number) => {\n        const txPayload: any = 'payload' in transaction ? transaction.payload : transaction;\n        const signerDetails = {\n          ...v3Details(details),\n          walletAddress: this.address,\n          nonce: toBigInt(Number(safeNonce) + index),\n          maxFee: ZERO,\n          chainId,\n          cairoVersion,\n          version: '' as ETransactionVersion,\n          skipValidate,\n        };\n        const common = {\n          type: transaction.type,\n          nonce: toBigInt(Number(safeNonce) + index),\n          blockIdentifier,\n          version: '' as ETransactionVersion,\n        };\n\n        if (transaction.type === TransactionType.INVOKE) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildInvocation(\n            ([] as Call[]).concat(txPayload),\n            signerDetails\n          );\n          return {\n            ...common,\n            ...payload,\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const calls = this.buildUDCContractPayload(txPayload);\n          const payload = await this.buildInvocation(calls, signerDetails);\n          return {\n            ...common,\n            ...payload,\n            type: TransactionType.INVOKE,\n          };\n        }\n        if (transaction.type === TransactionType.DECLARE) {\n          // 1 (Cairo0) or 2 or 3\n          const versionX = !isSierra(txPayload.contract) ? versions[0] : versions[1];\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildDeclarePayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n          };\n        }\n        if (transaction.type === TransactionType.DEPLOY_ACCOUNT) {\n          // 1 or 3\n          const versionX = reduceV2(versions[1]);\n          signerDetails.version = versionX;\n          common.version = versionX;\n\n          const payload = await this.buildAccountDeployPayload(txPayload, signerDetails);\n          return {\n            ...common,\n            ...payload,\n          };\n        }\n        throw Error(`accountInvocationsFactory: unsupported transaction type: ${transaction}`);\n      })\n    ) as Promise<AccountInvocations>;\n  }\n\n  public async getStarkName(\n    address: BigNumberish = this.address, // default to the wallet address\n    StarknetIdContract?: string\n  ): Promise<string> {\n    return super.getStarkName(address, StarknetIdContract);\n  }\n}\n","import { ProviderInterface } from '../provider';\nimport { SignerInterface } from '../signer';\nimport {\n  Abi,\n  AllowArray,\n  BigNumberish,\n  BlockIdentifier,\n  CairoVersion,\n  Call,\n  DeclareAndDeployContractPayload,\n  DeclareContractPayload,\n  DeclareContractResponse,\n  DeclareDeployUDCResponse,\n  DeployAccountContractPayload,\n  DeployContractResponse,\n  DeployContractUDCResponse,\n  EstimateFee,\n  EstimateFeeAction,\n  EstimateFeeDetails,\n  EstimateFeeResponse,\n  EstimateFeeResponseBulk,\n  Invocations,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n  MultiDeployContractResponse,\n  Nonce,\n  Signature,\n  SimulateTransactionDetails,\n  SimulateTransactionResponse,\n  TypedData,\n  UniversalDeployerContractPayload,\n} from '../types';\n\nexport abstract class AccountInterface extends ProviderInterface {\n  public abstract address: string;\n\n  public abstract signer: SignerInterface;\n\n  public abstract cairoVersion: CairoVersion;\n\n  /**\n   * Estimate Fee for executing an INVOKE transaction on starknet\n   *\n   * @param calls the invocation object containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata? - (defaults to []) the calldata\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateInvokeFee(\n    calls: AllowArray<Call>,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a DECLARE transaction on starknet\n   *\n   * @param contractPayload the payload object containing:\n   * - contract - the compiled contract to be declared\n   * - casm? - compiled cairo assembly. Cairo1(casm or compiledClassHash are required)\n   * - classHash? - the class hash of the compiled contract. Precalculate for faster execution.\n   * - compiledClassHash?: class hash of the cairo assembly. Cairo1(casm or compiledClassHash are required)\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateDeclareFee(\n    contractPayload: DeclareContractPayload,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a DEPLOY_ACCOUNT transaction on starknet\n   *\n   * @param contractPayload -\n   * - classHash - the class hash of the compiled contract.\n   * - constructorCalldata? - constructor data;\n   * - contractAddress? - future account contract address. Precalculate for faster execution.\n   * - addressSalt? - salt used for calculation of the contractAddress. Required if contractAddress is provided.\n   *\n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce? = 0\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateAccountDeployFee(\n    contractPayload: DeployAccountContractPayload,\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a UDC DEPLOY transaction on starknet\n   * This is different from the normal DEPLOY transaction as it goes through the Universal Deployer Contract (UDC)\n   \n  * @param deployContractPayload array or singular\n   * - classHash: computed class hash of compiled contract\n   * - salt: address salt\n   * - unique: bool if true ensure unique salt\n   * - constructorCalldata: constructor calldata\n   * \n   * @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce?\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   */\n  public abstract estimateDeployFee(\n    deployContractPayload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    estimateFeeDetails?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Estimate Fee for executing a list of transactions on starknet\n   * Contract must be deployed for fee estimation to be possible\n   *\n   * @param transactions array of transaction object containing :\n   * - type - the type of transaction : 'DECLARE' | (multi)'DEPLOY' | (multi)'INVOKE_FUNCTION' | 'DEPLOY_ACCOUNT'\n   * - payload - the payload of the transaction\n   *\n   *  @param estimateFeeDetails -\n   * - blockIdentifier?\n   * - nonce?\n   * - skipValidate? - default true\n   * - tip? - prioritize order of transactions in the mempool.\n   * - accountDeploymentData? - deploy an account contract (substitution for deploy account transaction)\n   * - paymasterData? - entity other than the transaction sender to pay the transaction fees(EIP-4337)\n   * - nonceDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - feeDataAvailabilityMode? - allows users to choose their preferred data availability mode (Volition)\n   * - version? - specify ETransactionVersion - V3 Transactions fee is in fri, oldV transactions fee is in wei\n   *\n   * @returns response from estimate_fee\n   */\n  public abstract estimateFeeBulk(\n    invocations: Invocations,\n    details?: EstimateFeeDetails\n  ): Promise<EstimateFeeResponseBulk>;\n\n  /**\n   * Gets Suggested Max Fee based on the transaction type\n   *\n   * @param  {EstimateFeeAction} estimateFeeAction\n   * @param  {EstimateFeeDetails} details\n   * @returns EstimateFee (...response, resourceBounds, suggestedMaxFee)\n   */\n  public abstract getSuggestedFee(\n    estimateFeeAction: EstimateFeeAction,\n    details: EstimateFeeDetails\n  ): Promise<EstimateFee>;\n\n  /**\n   * Simulates an array of transaction and returns an array of transaction trace and estimated fee.\n   *\n   * @param invocations Invocations containing:\n   * - type - transaction type: DECLARE, (multi)DEPLOY, DEPLOY_ACCOUNT, (multi)INVOKE_FUNCTION\n   * @param details SimulateTransactionDetails\n   *\n   * @returns response from simulate_transaction\n   */\n  public abstract simulateTransaction(\n    invocations: Invocations,\n    details?: SimulateTransactionDetails\n  ): Promise<SimulateTransactionResponse>;\n\n  /**\n   * Invoke execute function in account contract\n   *\n   * @param transactions the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param abi (optional) the abi of the contract for better displaying\n   *\n   * @returns response from addTransaction\n   */\n  public abstract execute(\n    transactions: AllowArray<Call>,\n    abis?: Abi[],\n    transactionsDetail?: InvocationsDetails\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Declares a given compiled contract (json) to starknet\n   *\n   * @param contractPayload transaction payload to be deployed containing:\n   * - contract: compiled contract code\n   * - (optional) classHash: computed class hash of compiled contract. Pre-compute it for faster execution.\n   * - (required for Cairo1 without compiledClassHash) casm: CompiledContract | string;\n   * - (optional for Cairo1 with casm) compiledClassHash: compiled class hash from casm. Pre-compute it for faster execution.\n   * @param transactionsDetail - InvocationsDetails\n   *\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract declare(\n    contractPayload: DeclareContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeclareContractResponse>;\n\n  /**\n   * Deploys a declared contract to starknet - using Universal Deployer Contract (UDC)\n   * support multicall\n   *\n   * @param payload -\n   * - classHash: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   * - contract_address[]\n   * - transaction_hash\n   */\n  public abstract deploy(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<MultiDeployContractResponse>;\n\n  /**\n   * Simplify deploy simulating old DeployContract with same response + UDC specific response\n   * Internal wait for L2 transaction, support multicall\n   *\n   * @param payload -\n   * - classHash: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   *  - contract_address\n   *  - transaction_hash\n   *  - address\n   *  - deployer\n   *  - unique\n   *  - classHash\n   *  - calldata_len\n   *  - calldata\n   *  - salt\n   */\n  public abstract deployContract(\n    payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],\n    details?: InvocationsDetails\n  ): Promise<DeployContractUDCResponse>;\n\n  /**\n   * Declares and Deploy a given compiled contract (json) to starknet using UDC\n   * Internal wait for L2 transaction, do not support multicall\n   * Method will pass even if contract is already declared (internal using DeclareIfNot)\n   *\n   * @param payload\n   * - contract: compiled contract code\n   * - [casm=cairo1]: CairoAssembly | undefined;\n   * - [compiledClassHash]: string | undefined;\n   * - [classHash]: computed class hash of compiled contract\n   * - [constructorCalldata] contract constructor calldata\n   * - [salt=pseudorandom] deploy address salt\n   * - [unique=true] ensure unique salt\n   * @param details - InvocationsDetails\n   *\n   * @returns\n   * - declare\n   *    - transaction_hash\n   * - deploy\n   *    - contract_address\n   *    - transaction_hash\n   *    - address\n   *    - deployer\n   *    - unique\n   *    - classHash\n   *    - calldata_len\n   *    - calldata\n   *    - salt\n   */\n  public abstract declareAndDeploy(\n    payload: DeclareAndDeployContractPayload,\n    details?: InvocationsDetails\n  ): Promise<DeclareDeployUDCResponse>;\n\n  /**\n   * Deploy the account on Starknet\n   *\n   * @param contractPayload transaction payload to be deployed containing:\n   * - classHash: computed class hash of compiled contract\n   * - optional constructor calldata\n   * - optional address salt\n   * - optional contractAddress\n   * @param transactionsDetail - InvocationsDetails\n   *\n   * @returns a confirmation of sending a transaction on the starknet contract\n   */\n  public abstract deployAccount(\n    contractPayload: DeployAccountContractPayload,\n    transactionsDetail?: InvocationsDetails\n  ): Promise<DeployContractResponse>;\n\n  /**\n   * Signs a JSON object for off-chain usage with the Starknet private key and returns the signature\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param json - JSON object to be signed\n   * @returns the signature of the JSON object\n   * @throws {Error} if the JSON object is not a valid JSON\n   */\n  public abstract signMessage(typedData: TypedData): Promise<Signature>;\n\n  /**\n   * Hash a JSON object with Pedersen hash and return the hash\n   * This adds a message prefix so it can't be interchanged with transactions\n   *\n   * @param json - JSON object to be hashed\n   * @returns the hash of the JSON object\n   * @throws {Error} if the JSON object is not a valid JSON\n   */\n  public abstract hashMessage(typedData: TypedData): Promise<string>;\n\n  /**\n   * Verify a signature of a JSON object\n   *\n   * @param typedData - JSON object to be verified\n   * @param signature - signature of the JSON object\n   * @returns true if the signature is valid, false otherwise\n   * @throws {Error} if the JSON object is not a valid JSON or the signature is not a valid signature\n   */\n  public abstract verifyMessage(typedData: TypedData, signature: Signature): Promise<boolean>;\n\n  /**\n   * Verify a signature of a given hash\n   * @warning This method is not recommended, use verifyMessage instead\n   *\n   * @param hash - hash to be verified\n   * @param signature - signature of the hash\n   * @returns true if the signature is valid, false otherwise\n   * @throws {Error} if the signature is not a valid signature\n   */\n  public abstract verifyMessageHash(hash: BigNumberish, signature: Signature): Promise<boolean>;\n\n  /**\n   * Gets the nonce of the account with respect to a specific block\n   *\n   * @param  {BlockIdentifier} blockIdentifier - optional blockIdentifier. Defaults to 'pending'\n   * @returns nonce of the account\n   */\n  public abstract getNonce(blockIdentifier?: BlockIdentifier): Promise<Nonce>;\n}\n","import {\n  Abi,\n  AbiEnums,\n  AbiEvents,\n  AbiStructs,\n  Cairo1Event,\n  EventAbi,\n  LegacyEvent,\n  ParsedEvent,\n  ParsedEvents,\n  RPC,\n} from '../../types';\nimport responseParser from '../calldata/responseParser';\nimport { starkCurve } from '../ec';\nimport { addHexPrefix, utf8ToArray } from '../encode';\n\nexport function getAbiEvents(abi: Abi): AbiEvents {\n  return abi\n    .filter((abiEntry) => abiEntry.type === 'event' && (abiEntry.size || abiEntry.kind !== 'enum'))\n    .reduce((acc, abiEntry) => {\n      const entryName = abiEntry.name.slice(abiEntry.name.lastIndexOf(':') + 1);\n      const abiEntryMod = { ...abiEntry };\n      abiEntryMod.name = entryName;\n      return {\n        ...acc,\n        [addHexPrefix(starkCurve.keccak(utf8ToArray(entryName)).toString(16))]: abiEntryMod,\n      };\n    }, {});\n}\n\n/**\n * Parse raw events and structure them into response object based on a contract structs and defined events\n * @param providerReceivedEvents ProviderEvent[] - Array of raw events\n * @param abiEvents AbiEvents - Events defined in the abi\n * @param abiStructs AbiStructs - Structs defined in the abi\n * @return ParsedEvents - parsed events corresponding to the abi\n */\nexport function parseEvents(\n  providerReceivedEvents: RPC.Event[],\n  abiEvents: AbiEvents,\n  abiStructs: AbiStructs,\n  abiEnums: AbiEnums\n): ParsedEvents {\n  const ret = providerReceivedEvents.flat().reduce((acc, recEvent) => {\n    const abiEvent: EventAbi = abiEvents[recEvent.keys[0]];\n    if (!abiEvent) {\n      return acc;\n    }\n\n    // Create our final event object\n    const parsedEvent: ParsedEvent = {};\n    parsedEvent[abiEvent.name] = {};\n    // Remove the event's name hashed from the keys array\n    recEvent.keys.shift();\n\n    const keysIter = recEvent.keys[Symbol.iterator]();\n    const dataIter = recEvent.data[Symbol.iterator]();\n\n    const abiEventKeys =\n      (abiEvent as Cairo1Event).members?.filter((it) => it.kind === 'key') ||\n      (abiEvent as LegacyEvent).keys;\n    const abiEventData =\n      (abiEvent as Cairo1Event).members?.filter((it) => it.kind === 'data') ||\n      (abiEvent as LegacyEvent).data;\n\n    abiEventKeys.forEach((key) => {\n      parsedEvent[abiEvent.name][key.name] = responseParser(\n        keysIter,\n        key,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n\n    abiEventData.forEach((data) => {\n      parsedEvent[abiEvent.name][data.name] = responseParser(\n        dataIter,\n        data,\n        abiStructs,\n        abiEnums,\n        parsedEvent[abiEvent.name]\n      );\n    });\n    acc.push(parsedEvent);\n    return acc;\n  }, [] as ParsedEvents);\n  return ret;\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport { AccountInterface } from '../account';\nimport { ProviderInterface, defaultProvider } from '../provider';\nimport {\n  Abi,\n  AbiEvents,\n  ArgsOrCalldata,\n  ArgsOrCalldataWithOptions,\n  AsyncContractFunction,\n  Call,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractOptions,\n  EstimateFeeResponse,\n  FunctionAbi,\n  GetTransactionReceiptResponse,\n  InvokeFunctionResponse,\n  InvokeOptions,\n  InvokeTransactionReceiptResponse,\n  ParsedEvents,\n  RawArgs,\n  Result,\n  StructAbi,\n  ValidateType,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData, cairo } from '../utils/calldata';\nimport { createAbiParser } from '../utils/calldata/parser';\nimport { getAbiEvents, parseEvents as parseRawEvents } from '../utils/events/index';\nimport { cleanHex } from '../utils/num';\nimport { ContractInterface } from './interface';\n\nexport type TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & Contract;\n\nexport const splitArgsAndOptions = (args: ArgsOrCalldataWithOptions) => {\n  const options = [\n    'blockIdentifier',\n    'parseRequest',\n    'parseResponse',\n    'formatResponse',\n    'maxFee',\n    'nonce',\n    'signature',\n    'addressSalt',\n  ];\n  const lastArg = args[args.length - 1];\n  if (typeof lastArg === 'object' && options.some((x) => x in lastArg)) {\n    return { args: args as ArgsOrCalldata, options: args.pop() as ContractOptions };\n  }\n  return { args: args as ArgsOrCalldata };\n};\n\n/**\n * Adds call methods to the contract\n */\nfunction buildCall(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: ArgsOrCalldataWithOptions): Promise<any> {\n    const params = splitArgsAndOptions(args);\n    return contract.call(functionAbi.name, params.args, {\n      parseRequest: true,\n      parseResponse: true,\n      ...params.options,\n    });\n  };\n}\n\n/**\n * Adds invoke methods to the contract\n */\nfunction buildInvoke(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  return async function (...args: Array<any>): Promise<any> {\n    const params = splitArgsAndOptions(args);\n    return contract.invoke(functionAbi.name, params.args, {\n      parseRequest: true,\n      ...params.options,\n    });\n  };\n}\n\n/**\n * Adds call/invoke methods to the contract\n */\nfunction buildDefault(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {\n  if (functionAbi.stateMutability === 'view' || functionAbi.state_mutability === 'view') {\n    return buildCall(contract, functionAbi);\n  }\n  return buildInvoke(contract, functionAbi);\n}\n\n/**\n * Adds populate for methods to the contract\n */\nfunction buildPopulate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.populate(functionAbi.name, args);\n  };\n}\n\n/**\n * Adds estimateFee for methods to the contract\n */\nfunction buildEstimate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {\n  return function (...args: Array<any>): any {\n    return contract.estimate(functionAbi.name, args);\n  };\n}\n\nexport function getCalldata(args: RawArgs, callback: Function): Calldata {\n  // Check if Calldata in args or args[0] else compile\n  if (Array.isArray(args) && '__compiled__' in args) return args as Calldata;\n  if (Array.isArray(args) && Array.isArray(args[0]) && '__compiled__' in args[0])\n    return args[0] as Calldata;\n  return callback();\n}\n\nexport class Contract implements ContractInterface {\n  abi: Abi;\n\n  address: string;\n\n  providerOrAccount: ProviderInterface | AccountInterface;\n\n  deployTransactionHash?: string;\n\n  protected readonly structs: { [name: string]: StructAbi };\n\n  protected readonly events: AbiEvents;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  private callData: CallData;\n\n  /**\n   * Contract class to handle contract methods\n   *\n   * @param abi - Abi of the contract object\n   * @param address (optional) - address to connect to\n   * @param providerOrAccount (optional) - Provider or Account to attach to\n   */\n  constructor(\n    abi: Abi,\n    address: string,\n    providerOrAccount: ProviderInterface | AccountInterface = defaultProvider\n  ) {\n    this.address = address && address.toLowerCase();\n    this.providerOrAccount = providerOrAccount;\n    this.callData = new CallData(abi);\n    this.structs = CallData.getAbiStruct(abi);\n    this.events = getAbiEvents(abi);\n    const parser = createAbiParser(abi);\n    this.abi = parser.getLegacyFormat();\n\n    const options = { enumerable: true, value: {}, writable: false };\n    Object.defineProperties(this, {\n      functions: { enumerable: true, value: {}, writable: false },\n      callStatic: { enumerable: true, value: {}, writable: false },\n      populateTransaction: { enumerable: true, value: {}, writable: false },\n      estimateFee: { enumerable: true, value: {}, writable: false },\n    });\n    this.abi.forEach((abiElement) => {\n      if (abiElement.type !== 'function') return;\n      const signature = abiElement.name;\n      if (!this[signature]) {\n        Object.defineProperty(this, signature, {\n          ...options,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.functions[signature]) {\n        Object.defineProperty(this.functions, signature, {\n          ...options,\n          value: buildDefault(this, abiElement),\n        });\n      }\n      if (!this.callStatic[signature]) {\n        Object.defineProperty(this.callStatic, signature, {\n          ...options,\n          value: buildCall(this, abiElement),\n        });\n      }\n      if (!this.populateTransaction[signature]) {\n        Object.defineProperty(this.populateTransaction, signature, {\n          ...options,\n          value: buildPopulate(this, abiElement),\n        });\n      }\n      if (!this.estimateFee[signature]) {\n        Object.defineProperty(this.estimateFee, signature, {\n          ...options,\n          value: buildEstimate(this, abiElement),\n        });\n      }\n    });\n  }\n\n  public attach(address: string): void {\n    this.address = address;\n  }\n\n  public connect(providerOrAccount: ProviderInterface | AccountInterface) {\n    this.providerOrAccount = providerOrAccount;\n  }\n\n  public async deployed(): Promise<Contract> {\n    if (this.deployTransactionHash) {\n      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);\n      this.deployTransactionHash = undefined;\n    }\n    return this;\n  }\n\n  public async call(\n    method: string,\n    args: ArgsOrCalldata = [],\n    {\n      parseRequest = true,\n      parseResponse = true,\n      formatResponse = undefined,\n      blockIdentifier = undefined,\n    }: CallOptions = {}\n  ): Promise<Result> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.CALL, method, args);\n        return this.callData.compile(method, args);\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    return this.providerOrAccount\n      .callContract(\n        {\n          contractAddress: this.address,\n          calldata,\n          entrypoint: method,\n        },\n        blockIdentifier\n      )\n      .then((it) => {\n        if (!parseResponse) {\n          return it;\n        }\n        if (formatResponse) {\n          return this.callData.format(method, it, formatResponse);\n        }\n        return this.callData.parse(method, it);\n      });\n  }\n\n  public invoke(\n    method: string,\n    args: ArgsOrCalldata = [],\n    { parseRequest = true, maxFee, nonce, signature }: InvokeOptions = {}\n  ): Promise<InvokeFunctionResponse> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    const calldata = getCalldata(args, () => {\n      if (parseRequest) {\n        this.callData.validate(ValidateType.INVOKE, method, args);\n        return this.callData.compile(method, args);\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Invoke skipped parsing but provided rawArgs, possible malfunction request');\n      return args;\n    });\n\n    const invocation = {\n      contractAddress: this.address,\n      calldata,\n      entrypoint: method,\n    };\n    if ('execute' in this.providerOrAccount) {\n      return this.providerOrAccount.execute(invocation, undefined, {\n        maxFee,\n        nonce,\n      });\n    }\n\n    if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);\n    // eslint-disable-next-line no-console\n    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);\n\n    return this.providerOrAccount.invokeFunction(\n      {\n        ...invocation,\n        signature,\n      },\n      {\n        nonce,\n      }\n    );\n  }\n\n  public async estimate(method: string, args: ArgsOrCalldata = []): Promise<EstimateFeeResponse> {\n    assert(this.address !== null, 'contract is not connected to an address');\n\n    if (!getCalldata(args, () => false)) {\n      this.callData.validate(ValidateType.INVOKE, method, args);\n    }\n\n    const invocation = this.populate(method, args);\n    if ('estimateInvokeFee' in this.providerOrAccount) {\n      return this.providerOrAccount.estimateInvokeFee(invocation);\n    }\n    throw Error('Contract must be connected to the account contract to estimate');\n  }\n\n  public populate(method: string, args: RawArgs = []): Call {\n    const calldata: Calldata = getCalldata(args, () => this.callData.compile(method, args));\n    return {\n      contractAddress: this.address,\n      entrypoint: method,\n      calldata,\n    };\n  }\n\n  public parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents {\n    return parseRawEvents(\n      (receipt as InvokeTransactionReceiptResponse).events?.filter(\n        (event) => cleanHex(event.from_address) === cleanHex(this.address),\n        []\n      ) || [],\n      this.events,\n      this.structs,\n      CallData.getAbiEnum(this.abi)\n    );\n  }\n\n  public isCairo1(): boolean {\n    return cairo.isCairo1Abi(this.abi);\n  }\n\n  public async getVersion() {\n    return this.providerOrAccount.getContractVersion(this.address);\n  }\n\n  public typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi> {\n    return this as unknown as TypedContractV2<typeof tAbi>;\n  }\n}\n","import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from 'abi-wan-kanabi';\n\nimport { AccountInterface } from '../account';\nimport { ProviderInterface } from '../provider';\nimport {\n  Abi,\n  ArgsOrCalldata,\n  AsyncContractFunction,\n  BigNumberish,\n  BlockIdentifier,\n  CallOptions,\n  Calldata,\n  ContractFunction,\n  ContractVersion,\n  EstimateFeeResponse,\n  GetTransactionReceiptResponse,\n  Invocation,\n  InvokeFunctionResponse,\n  InvokeOptions,\n  ParsedEvents,\n  RawArgs,\n  Result,\n  Uint256,\n} from '../types';\nimport { CairoCustomEnum } from '../utils/calldata/enum/CairoCustomEnum';\nimport { CairoOption } from '../utils/calldata/enum/CairoOption';\nimport { CairoResult } from '../utils/calldata/enum/CairoResult';\n\ndeclare module 'abi-wan-kanabi' {\n  export interface Config<OptionT = any, ResultT = any, ErrorT = any> {\n    FeltType: BigNumberish;\n    U256Type: number | bigint | Uint256;\n    Option: CairoOption<OptionT>;\n    Tuple: Record<number, BigNumberish | object | boolean>;\n    Result: CairoResult<ResultT, ErrorT>;\n    Enum: CairoCustomEnum;\n    Calldata: RawArgs | Calldata;\n    CallOptions: CallOptions;\n    InvokeOptions: InvokeOptions;\n    InvokeFunctionResponse: InvokeFunctionResponse;\n  }\n}\n\ntype TypedContractV2<TAbi extends AbiKanabi> = AbiWanTypedContract<TAbi> & ContractInterface;\n\nexport abstract class ContractInterface {\n  public abstract abi: Abi;\n\n  public abstract address: string;\n\n  public abstract providerOrAccount: ProviderInterface | AccountInterface;\n\n  public abstract deployTransactionHash?: string;\n\n  readonly functions!: { [name: string]: AsyncContractFunction };\n\n  readonly callStatic!: { [name: string]: AsyncContractFunction };\n\n  readonly populateTransaction!: { [name: string]: ContractFunction };\n\n  readonly estimateFee!: { [name: string]: ContractFunction };\n\n  readonly [key: string]: AsyncContractFunction | any;\n\n  /**\n   * Saves the address of the contract deployed on network that will be used for interaction\n   *\n   * @param address - address of the contract\n   */\n  public abstract attach(address: string): void;\n\n  /**\n   * Attaches to new Provider or Account\n   *\n   * @param providerOrAccount - new Provider or Account to attach to\n   */\n  public abstract connect(providerOrAccount: ProviderInterface | AccountInterface): void;\n\n  /**\n   * Resolves when contract is deployed on the network or when no deployment transaction is found\n   *\n   * @returns Promise that resolves when contract is deployed on the network or when no deployment transaction is found\n   * @throws When deployment fails\n   */\n  public abstract deployed(): Promise<ContractInterface>;\n\n  /**\n   * Calls a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call\n   * @param options optional blockIdentifier\n   * @returns Result of the call as an array with key value pars\n   */\n  public abstract call(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: CallOptions\n  ): Promise<Result>;\n\n  /**\n   * Invokes a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the invoke or Calldata\n   * @param options\n   * @returns Add Transaction Response\n   */\n  public abstract invoke(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: InvokeOptions\n  ): Promise<InvokeFunctionResponse>;\n\n  /**\n   * Estimates a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call or Calldata\n   * @param options optional blockIdentifier\n   */\n  public abstract estimate(\n    method: string,\n    args?: ArgsOrCalldata,\n    options?: {\n      blockIdentifier?: BlockIdentifier;\n    }\n  ): Promise<EstimateFeeResponse>;\n\n  /**\n   * Calls a method on a contract\n   *\n   * @param method name of the method\n   * @param args Array of the arguments for the call or Calldata\n   * @returns Invocation object\n   */\n  public abstract populate(method: string, args?: ArgsOrCalldata): Invocation;\n\n  /**\n   * Parse contract events of a GetTransactionReceiptResponse received from waitForTransaction. Based on contract's abi\n   *\n   * @param receipt transaction receipt\n   * @returns Events parsed\n   */\n  public abstract parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents;\n\n  /**\n   * tells if the contract comes from a Cairo 1 contract\n   *\n   * @returns TRUE if the contract comes from a Cairo1 contract\n   * @example\n   * ```typescript\n   * const isCairo1: boolean = myContract.isCairo1();\n   * ```\n   */\n  public abstract isCairo1(): boolean;\n\n  /**\n   * Retrieves the version of the contract (cairo version & compiler version)\n   */\n  public abstract getVersion(): Promise<ContractVersion>;\n\n  public abstract typedv2<TAbi extends AbiKanabi>(tAbi: TAbi): TypedContractV2<TAbi>;\n}\n","import { AccountInterface } from '../account';\nimport {\n  Abi,\n  ArgsOrCalldataWithOptions,\n  CairoAssembly,\n  CompiledContract,\n  ValidateType,\n} from '../types';\nimport assert from '../utils/assert';\nimport { CallData } from '../utils/calldata';\nimport { Contract, getCalldata, splitArgsAndOptions } from './default';\n\nexport type ContractFactoryParams = {\n  compiledContract: CompiledContract;\n  account: any;\n  casm?: CairoAssembly;\n  classHash?: string;\n  compiledClassHash?: string;\n  abi?: Abi;\n};\n\nexport class ContractFactory {\n  compiledContract: CompiledContract;\n\n  account: AccountInterface;\n\n  abi: Abi;\n\n  classHash?: string;\n\n  casm?: CairoAssembly;\n\n  compiledClassHash?: string;\n\n  private CallData: CallData;\n\n  /**\n   * @param params CFParams\n   *  - compiledContract: CompiledContract;\n   *  - account: AccountInterface;\n   *  - casm?: CairoAssembly;\n   *  - classHash?: string;\n   *  - compiledClassHash?: string;\n   *  - abi?: Abi;\n   */\n  constructor(params: ContractFactoryParams) {\n    this.compiledContract = params.compiledContract;\n    this.account = params.account;\n    this.casm = params.casm;\n    this.abi = params.abi ?? params.compiledContract.abi;\n    this.classHash = params.classHash;\n    this.compiledClassHash = params.compiledClassHash;\n    this.CallData = new CallData(this.abi);\n  }\n\n  /**\n   * Deploys contract and returns new instance of the Contract\n   *\n   * If contract is not declared it will first declare it, and then deploy\n   */\n  public async deploy(...args: ArgsOrCalldataWithOptions): Promise<Contract> {\n    const { args: param, options = { parseRequest: true } } = splitArgsAndOptions(args);\n\n    const constructorCalldata = getCalldata(param, () => {\n      if (options.parseRequest) {\n        this.CallData.validate(ValidateType.DEPLOY, 'constructor', param);\n        return this.CallData.compile('constructor', param);\n      }\n      // eslint-disable-next-line no-console\n      console.warn('Call skipped parsing but provided rawArgs, possible malfunction request');\n      return param;\n    });\n\n    const {\n      deploy: { contract_address, transaction_hash },\n    } = await this.account.declareAndDeploy({\n      contract: this.compiledContract,\n      casm: this.casm,\n      classHash: this.classHash,\n      compiledClassHash: this.compiledClassHash,\n      constructorCalldata,\n      salt: options.addressSalt,\n    });\n    assert(Boolean(contract_address), 'Deployment of the contract failed');\n\n    const contractInstance = new Contract(\n      this.compiledContract.abi,\n      contract_address!,\n      this.account\n    );\n    contractInstance.deployTransactionHash = transaction_hash;\n\n    return contractInstance;\n  }\n\n  /**\n   * Attaches to new Account\n   *\n   * @param account - new Account to attach to\n   */\n  connect(account: AccountInterface): ContractFactory {\n    this.account = account;\n    return this;\n  }\n\n  /**\n   * Attaches current abi and account to the new address\n   */\n  attach(address: string): Contract {\n    return new Contract(this.abi, address, this.account);\n  }\n\n  // ethers.js' getDeployTransaction can't be supported as it requires the account or signer to return a signed transaction which is not possible with the current implementation\n}\n","/* eslint-disable no-bitwise */\nimport { BigNumberish, Uint256 } from '../types';\nimport { CairoUint256, UINT_128_MAX, UINT_256_MAX } from './cairoDataTypes/uint256';\n\n/**\n * @deprecated Legacy support Export\n */\nexport { UINT_128_MAX, UINT_256_MAX };\n\n/**\n * Convert Uint256 to bigint\n * Legacy support Export\n */\nexport function uint256ToBN(uint256: Uint256) {\n  return new CairoUint256(uint256).toBigInt();\n}\n\n/**\n * Test BigNumberish is smaller or equal 2**256-1\n * Legacy support Export\n */\nexport function isUint256(bn: BigNumberish): boolean {\n  return CairoUint256.is(bn);\n}\n\n/**\n * Convert BigNumberish (string | number | bigint) to Uint256 (hex)\n * Legacy support Export\n */\nexport function bnToUint256(bn: BigNumberish): Uint256 {\n  return new CairoUint256(bn).toUint256HexString();\n}\n","/* eslint-disable no-bitwise */\nimport { hexToBytes } from '@noble/curves/abstract/utils';\n\nimport { ADDR_BOUND, ZERO } from '../constants';\nimport { BigNumberish } from '../types';\nimport { addHexPrefix, removeHexPrefix } from './encode';\nimport { keccakBn } from './hash';\nimport { assertInRange, toHex } from './num';\n\nexport function addAddressPadding(address: BigNumberish): string {\n  return addHexPrefix(removeHexPrefix(toHex(address)).padStart(64, '0'));\n}\n\nexport function validateAndParseAddress(address: BigNumberish): string {\n  assertInRange(address, ZERO, ADDR_BOUND - 1n, 'Starknet Address');\n\n  const result = addAddressPadding(address);\n\n  if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {\n    throw new Error('Invalid Address Format');\n  }\n\n  return result;\n}\n\n// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12\nexport function getChecksumAddress(address: BigNumberish): string {\n  const chars = removeHexPrefix(validateAndParseAddress(address)).toLowerCase().split('');\n  const hex = removeHexPrefix(keccakBn(address));\n  const hashed = hexToBytes(hex.padStart(64, '0'));\n\n  for (let i = 0; i < chars.length; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n\n  return addHexPrefix(chars.join(''));\n}\n\nexport function validateChecksumAddress(address: string): boolean {\n  return getChecksumAddress(address) === address;\n}\n","import urljoin from 'url-join';\n\n/**\n * Inspired from https://github.com/segmentio/is-url\n */\n\n/**\n * RegExps.\n * A URL must match #1 and then at least one of #2/#3.\n * Use two levels of REs to avoid REDOS.\n */\nconst protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\n\nconst localhostDomainRE = /^localhost[:?\\d]*(?:[^:?\\d]\\S*)?$/;\nconst nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\n\n/**\n * Loosely validate a URL `string`.\n */\nexport function isUrl(s?: string): boolean {\n  if (!s) {\n    return false;\n  }\n\n  if (typeof s !== 'string') {\n    return false;\n  }\n\n  const match = s.match(protocolAndDomainRE);\n  if (!match) {\n    return false;\n  }\n\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n\n  if (\n    localhostDomainRE.test(everythingAfterProtocol) ||\n    nonLocalhostDomainRE.test(everythingAfterProtocol)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function buildUrl(baseUrl: string, defaultPath: string, urlOrPath?: string) {\n  return isUrl(urlOrPath) ? urlOrPath! : urljoin(baseUrl, urlOrPath ?? defaultPath);\n}\n","/**\n * Main\n */\nexport * from './account';\nexport * from './contract';\nexport * from './provider';\nexport * from './signer';\nexport * from './channel';\n\n// TODO: decide on final export style\nexport * from './types';\nexport * as types from './types';\n\n/**\n * Utils\n */\nexport * as constants from './constants';\nexport * as encode from './utils/encode';\nexport * as hash from './utils/hash';\nexport * as v3hash from './utils/hash/transactionHash/v3';\nexport * as v2hash from './utils/hash/transactionHash/v2';\nexport * as json from './utils/json';\nexport * as num from './utils/num';\nexport * as transaction from './utils/transaction';\nexport * as stark from './utils/stark';\nexport * as eth from './utils/eth';\nexport * as merkle from './utils/merkle';\nexport * as uint256 from './utils/uint256';\nexport * as shortString from './utils/shortString';\nexport * as typedData from './utils/typedData';\nexport * as ec from './utils/ec';\nexport * as starknetId from './utils/starknetId';\nexport * as provider from './utils/provider';\nexport * as selector from './utils/selector';\nexport * as events from './utils/events/index';\nexport * from './utils/address';\nexport * from './utils/url';\nexport * from './utils/calldata';\nexport * from './utils/calldata/enum';\nexport * from './utils/contract';\nexport * from './utils/events';\n\n/**\n * Deprecated\n */\n/* eslint-disable import/first */\nimport * as num from './utils/num';\n\n/** @deprecated prefer the 'num' naming */\nexport const number = num;\n"],"mappings":"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","names":["ETransactionVersion","EBlockTag","EDAMode","EDataAvailabilityMode","ESimulationFlag","ETransactionExecutionStatus","ETransactionFinalityStatus","ETransactionStatus","ETransactionType","ETransactionVersion","ETransactionVersion2","ETransactionVersion3","errors_exports","components_exports","ETransactionType","ESimulationFlag","ETransactionStatus","ETransactionFinalityStatus","ETransactionExecutionStatus","EBlockTag","EDataAvailabilityMode","EDAMode","ETransactionVersion","ETransactionVersion2","ETransactionVersion3","EBlockTag","EDAMode","EDataAvailabilityMode","ESimulationFlag","ETransactionExecutionStatus","ETransactionFinalityStatus","ETransactionStatus","ETransactionType","ETransactionVersion","ETransactionVersion2","ETransactionVersion3","errors_exports","components_exports","errors_exports","components_exports","ETransactionType","ESimulationFlag","ETransactionStatus","ETransactionFinalityStatus","ETransactionExecutionStatus","EBlockTag","EDataAvailabilityMode","EDAMode","ETransactionVersion","ETransactionVersion2","ETransactionVersion3","BaseUrl","NetworkName","StarknetChainId","TransactionHashPrefix","feeMarginPercentage","SIMULATION_FLAG","ValidateType","Uint","Literal","EntryPointType","TransactionType","TransactionStatus","TransactionFinalityStatus","TransactionExecutionStatus","BlockStatus","BlockTag","TypedDataRevision","number","CairoOptionVariant","CairoResultVariant","listTypeVariant","parsedParameter","parseBaseTypes","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateInvokeTransactionHash","computeHashOnElements","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","calculateTransactionHashCommon","calculateTransactionHashCommon","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","calculateInvokeTransactionHash","calculateDeclareTransactionHash","calculateDeployAccountTransactionHash","poseidonHashMany","parse","stringify","computeHashOnElements","poseidonHashMany","json","stringify","parse","stringify","base64","parse","ETransactionVersion","parse","stringify","parse","stringify","RpcChannel","defaultOptions","RpcChannel","stringify","RpcChannel","StarknetIdContract","StarknetIdIdentityContract","StarknetIdVerifierContract","StarknetIdPfpContract","StarknetIdPopContract","StarknetIdContract","StarknetIdIdentityContract","StarknetIdVerifierContract","StarknetIdPfpContract","StarknetIdPopContract","StarknetIdMulticallContract","RpcProvider","ETransactionVersion2","calculateInvokeTransactionHash","ETransactionVersion3","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","secp256k1","secp256k1","ETransactionVersion2","calculateInvokeTransactionHash","ETransactionVersion3","calculateDeployAccountTransactionHash","calculateDeclareTransactionHash","RpcProvider","StarknetIdContract","uint256","hexToBytes","hexToBytes"]}